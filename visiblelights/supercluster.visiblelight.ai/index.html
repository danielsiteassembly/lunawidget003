<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visible Light AI Supercluster</title>
    <link rel="stylesheet" type="text/css" href="https://supercluster.visiblelight.ai/styles.css" />
        <style>
        /* Hide scrollbars in right sidebar and widgets, keep scrolling enabled */
        .vl-right-sidebar,
        .vl-right-sidebar * {
            scrollbar-width: none;           /* Firefox */
            -ms-overflow-style: none;        /* IE/Edge legacy */
        }
        .vl-right-sidebar::-webkit-scrollbar,
        .vl-right-sidebar *::-webkit-scrollbar {
            width: 0;
            height: 0;
            background: transparent;
        }
        .vl-widget-body {
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        .vl-widget-body::-webkit-scrollbar {
            width: 0;
            height: 0;
            background: transparent;
        }

            /* Ensure main menu items are always clickable */
            .vl-main-menu a {
                cursor: pointer;
                pointer-events: auto;
            }
    </style>
</head>
<body>
    <div
        id="vlSuperclusterRoot"
        class="vl-supercluster-root vl-supercluster"
        data-login-path="/supercluster-ai-constellation-login/"
    >


        <!-- Visible Light Supercluster Overlay -->
        <div class="vl-supercluster-overlay">
            <!-- Left Sidebar Container -->
            <div class="left-sidebar-container">
            <!-- Top Left: Logo -->
            <div class="vl-header">
                <div class="vl-logo">
                    <img src="https://visiblelight.ai/wp-content/uploads/2025/10/visible-light-icon-logo.svg" alt="Visible Light Icon Logo" />
                </div>
            </div>

            <!-- Main Navigation Menu -->
            <nav class="vl-main-menu">
                <ul>
                    <li>
                        <a href="#" data-section="supercluster">
                            <span class="icon"><img src="https://visiblelight.ai/wp-content/uploads/2025/10/supercluster-loader.svg" alt="Supercluster Icon" /></span>
                                <span class="label">Data Supercluster</span>
                        </a>
                    </li>
                    <li>
                            <a href="#" data-section="compose" data-path="luna-compose">
                                <span class="icon"><img src="https://visiblelight.ai/wp-content/uploads/2025/11/luna-ai-composer-icon-1.svg" alt="Compose Icon" /></span>
                                <span class="label">AI Composer</span>
                        </a>
                    </li>
                    <li>
                            <a href="#" data-section="report" data-path="luna-report">
                                <span class="icon"><img src="https://visiblelight.ai/wp-content/uploads/2025/10/supercluster-reporting-icon.svg" alt="Report Icon" /></span>
                                <span class="label">AI Reports</span>
                        </a>
                    </li>
                    <li>
                            <a href="#" data-section="automate" data-path="luna-automate">
                                <span class="icon"><img src="https://visiblelight.ai/wp-content/uploads/2025/10/supercluster-loader.svg" alt="Automate Icon" /></span>
                                <span class="label">Automations</span>
                        </a>
                    </li>
                    <li>
                            <a href="#" data-section="connect" data-path="luna-connect">
                                <span class="icon"><img src="https://visiblelight.ai/wp-content/uploads/2025/11/cloudops-icon.svg" alt="Connect Icon" /></span>
                                <span class="label">Connections</span>
                        </a>
                    </li>
                </ul>
            </nav>

                <!-- Right Sidebar: Your Supercluster + Recent Activity (Scrollable) -->
            <aside class="vl-right-sidebar">
                <div class="vl-widget vl-widget-supercluster" id="yourSuperclusterWidget">
                    <div class="vl-widget-header">
                        <h3>Omniscient</h3>
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <button class="vl-widget-toggle" data-widget="yourSuperclusterWidget" aria-label="Show widget">
                                <img src="https://visiblelight.ai/wp-content/uploads/2025/11/vl-eye-icon.svg" alt="Show" class="vl-toggle-icon" />
                            </button>
                        </div>
                    </div>
                    <div class="vl-widget-body vl-widget-body-hidden">
                        <p id="superclusterSummary">Loading your Observatory…</p>
                    </div>
                </div>

                <div class="vl-widget vl-widget-activity" id="recentActivityWidget">
                    <div class="vl-widget-header">
                        <h3>Insights</h3>
                        <button class="vl-widget-toggle" data-widget="recentActivityWidget" aria-label="Show widget">
                            <img src="https://visiblelight.ai/wp-content/uploads/2025/11/vl-eye-icon.svg" alt="Show" class="vl-toggle-icon" />
                        </button>
                    </div>
                    <div class="vl-widget-body vl-widget-body-hidden">
                        <ul id="recentActivityList" class="vl-activity-list">
                            <li class="vl-activity-empty">No recent activity.</li>
                        </ul>
                    </div>
                </div>
            </aside>
        
            </div>
            
            <!-- Client Admin Menu Container -->
            <div class="client-admin-menu-container">
                <div class="vl-client-greeting">
                    <div id="clientAvatar" style="display: inline-block; width: 30px; height: 30px; border: 1px solid #2e2c2a; border-radius: 40px; margin-right: 10px; vertical-align: middle; overflow: hidden; flex-shrink: 0;">
                        <!-- Avatar image or initials will be inserted here -->
                    </div>
                    <h2 style="display: inline-block; vertical-align: middle; margin: 0;">Hello, <span id="clientName">Client</span><span class="dropdown-arrow" id="clientDropdownArrow" style="cursor: pointer; display: inline-block;"><img src="https://visiblelight.ai/wp-content/uploads/2025/08/downarrow.svg" alt="dropdown arrow" style="pointer-events: auto;"></span></h2>
                </div>
            </div>

            <!-- Bottom Right: Controls -->
            <div class="vl-controls">
                <button class="control-btn" id="controlLeft" title="Move Left">
                    <span class="icon">←</span>
                </button>
                <button class="control-btn" id="controlRight" title="Move Right">
                    <span class="icon">→</span>
                </button>
                <button class="control-btn" id="controlZoomIn" title="Zoom In">
                    <span class="icon">+</span>
                </button>
                <button class="control-btn" id="controlZoomOut" title="Zoom Out">
                    <span class="icon">−</span>
                </button>
            </div>

            <!-- Luna Chat Widget Container - Positioned bottom-right -->
            <div id="vlLunaChatContainer"></div>

            <!-- Page Content Container (for category/stream pages) -->
            <div class="vl-page-content" id="vlPageContent" style="display: none;">
                <!-- Category/Stream content will be inserted here -->
            </div>
        </div>

        <!-- Client Dropdown Lightbox -->
        <div class="client-dropdown-lightbox" id="clientDropdownLightbox" style="display: none; position: fixed; z-index: 10000; top: 0; width: 100%; height: 100%; pointer-events: none;">
            <div class="client-dropdown-content" id="clientDropdownContent" style="pointer-events: auto; position: absolute; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); padding: 8px 0; min-width: 150px;left: auto !important;">
                <div class="client-dropdown-item" id="accountSettings" style="font-size:.9rem; cursor: pointer; padding: 2.5px 10px; font-weight:500;">
                    <span class="dropdown-text">Account Settings</span>
                </div>
                <div class="client-dropdown-item" id="logoutOption" style="font-size:.9rem; cursor: pointer; padding: 2.5px 10px; font-weight:500;">
                    <span class="dropdown-text">Log Out</span>
                </div>
                <div class="breakLine"></div>
                <div class="client-dropdown-item" id="launchTutorial" style="font-size:.9rem;cursor: pointer; padding: 15px 10px 2.5px 10px; font-weight:500;">
                    <span class="dropdown-text">Launch Tutorial</span>
                </div>
                <div class="client-dropdown-item" id="contactSupport" style="font-size:.9rem;cursor: pointer; padding: 2.5px 10px 2.5px 10px; font-weight:500;">
                    <span class="dropdown-text"><a href="mailto:support@visiblelight.ai">Contact Support</a></span>
                </div>
                <div class="vl-connection-status" style="border-top: 1px solid #000; margin-top: 8px; padding: 8px 10px 0 10px;">
                    <div class="status-indicator" style="display:inline-block; margin-right:6px; vertical-align:middle;">
                        <span class="status-icon" id="connectionIcon"><img src="https://visiblelight.ai/wp-content/uploads/2025/10/checkmark.svg" alt="check mark" /></span>
                    </div>
                    <div class="status-text" style="display:inline-block; vertical-align:middle; font-size:0.8rem;">
                        <span class="status-label">Hub Status: </span>
                        <span class="status-value" id="connectionStatus">Active</span>
                    </div>
                </div>
                <div class="vl-license-key" style="border-top: 1px solid #000; margin-top: 8px; padding-top: 8px; padding-bottom:0;">
                    <div class="license-label" style="padding: 0; font-size: 0.7rem; color: #8F9193; text-transform: uppercase; letter-spacing: .1rem;">License Key</div>
                    <div class="license-container" id="licenseKeyContainer" style="padding: 0;">
                        <span class="license-value" id="licenseKeyDisplay" style="display: block; color: #fff4e9; font-weight: 600; font-size: 0.9rem; font-family: 'Supercluster Mono'; word-break: break-all;">Loading...</span>
                        <button class="copy-license-btn" id="copyLicenseBtn" title="Copy full license key" style="position: absolute; right: 15px; top: 50%; transform: translateY(-50%); background: transparent; border: none; cursor: pointer; color: rgba(255, 255, 255, 0.7); padding: 3px 0 0;">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Logout Confirmation Modal -->
        <div class="logout-modal" id="logoutModal" style="display: none; position: fixed; z-index: 10001; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); pointer-events: auto;">
            <div class="logout-modal-content" style="pointer-events: auto;">
                <img src="https://visiblelight.ai/wp-content/uploads/2025/10/visible-light-icon-logo.svg" alt="Visible Light Icon Logo">
                <h3>Logging out of Visible Light</h3>
                <p>Are you sure you want to log out of Visible Light?</p>
                <div class="logout-modal-buttons">
                    <button class="logout-cancel" id="logoutCancel">No, stay logged in</button>
                    <button class="logout-confirm" id="logoutConfirm">Yes, log out now</button>
                </div>
            </div>
        </div>

        <!-- Tutorial Overlay - Loaded from external file -->
        <div id="tutorial-container"></div>

    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.js",
                "three/examples/jsm/controls/OrbitControls": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/controls/OrbitControls.js"
            }
        }
    </script>

    <script type="module">
        // Early check for connections page - redirect before three.js initializes
        (function() {
            const urlParams = new URLSearchParams(window.location.search);
            const licenseParam = urlParams.get('license') || '';
            if (licenseParam.includes('/connections/') || licenseParam.includes('/connections')) {
                const licenseMatch = licenseParam.match(/^([^/]+)/);
                if (licenseMatch) {
                    const extractedLicense = licenseMatch[1];
                    console.log('[Connections] Redirecting to connections.html');
                    window.location.href = `connections.html?license=${encodeURIComponent(extractedLicense)}`;
                    return; // Stop execution
                }
            }
        })();
        
        // Custom Visible Light Notification System
        window.showVLNotification = function(message, type = 'success', duration = null) {
            // Remove any existing notifications
            const existing = document.querySelectorAll('.vl-notification');
            existing.forEach(n => n.remove());
            
            // Create notification element
            const notification = document.createElement('div');
            notification.className = 'vl-notification';
            notification.setAttribute('data-type', type);
            
            // Set colors based on type
            const textColor = type === 'error' || type === 'failure' ? '#B41616' : '#fff4e7';
            
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background-color: #000000;
                color: ${textColor};
                padding: 16px 24px;
                border-radius: 8px;
                border: 1px solid ${type === 'error' || type === 'failure' ? '#B41616' : '#fff4e7'};
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
                z-index: 10000;
                max-width: 600px;
                font-size: 0.875rem;
                line-height: 1.5;
                word-wrap: break-word;
                animation: vlNotificationSlideIn 0.3s ease-out;
            `;
            
            notification.textContent = message;
            
            // Add close button for errors (they stay until acknowledged)
            if (type === 'error' || type === 'failure') {
                const closeBtn = document.createElement('button');
                closeBtn.textContent = '×';
                closeBtn.style.cssText = `
                    position: absolute;
                    top: 8px;
                    right: 8px;
                    background: transparent;
                    border: none;
                    color: ${textColor};
                    font-size: 24px;
                    line-height: 1;
                    cursor: pointer;
                    padding: 0;
                    width: 24px;
                    height: 24px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    opacity: 0.7;
                    transition: opacity 0.2s;
                `;
                closeBtn.onmouseover = () => closeBtn.style.opacity = '1';
                closeBtn.onmouseout = () => closeBtn.style.opacity = '0.7';
                closeBtn.onclick = () => notification.remove();
                notification.appendChild(closeBtn);
            }
            
            // Add animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes vlNotificationSlideIn {
                    from {
                        opacity: 0;
                        transform: translateX(-50%) translateY(-20px);
                    }
                    to {
                        opacity: 1;
                        transform: translateX(-50%) translateY(0);
                    }
                }
            `;
            if (!document.querySelector('#vl-notification-styles')) {
                style.id = 'vl-notification-styles';
                document.head.appendChild(style);
            }
            
            document.body.appendChild(notification);
            
            // Auto-dismiss success notifications after 5 seconds (unless duration is explicitly set)
            if ((type === 'success' || !type) && duration !== false) {
                const dismissTime = duration || 5000;
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.style.animation = 'vlNotificationSlideOut 0.3s ease-out';
                        setTimeout(() => notification.remove(), 300);
                    }
                }, dismissTime);
            }
            
            // Add slide-out animation
            if (!document.querySelector('#vl-notification-styles') || !document.querySelector('#vl-notification-styles').textContent.includes('vlNotificationSlideOut')) {
                const slideOutStyle = document.createElement('style');
                slideOutStyle.textContent = `
                    @keyframes vlNotificationSlideOut {
                        from {
                            opacity: 1;
                            transform: translateX(-50%) translateY(0);
                        }
                        to {
                            opacity: 0;
                            transform: translateX(-50%) translateY(-20px);
                        }
                    }
                `;
                document.head.appendChild(slideOutStyle);
            }
        };
        import * as THREE from "three";
        import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";

        // CRITICAL SECURITY: Verify authentication before allowing dashboard access
        const LOGIN_PAGE_URL = 'https://visiblelight.ai/auth/';
        
        // CRITICAL: Prevent redirects to visiblelight.ai/wp-admin - ALWAYS redirect to supercluster subdomain
        (function() {
            // Check if we're on visiblelight.ai (not supercluster subdomain)
            const currentHost = window.location.hostname;
            const currentPath = window.location.pathname;
            const currentUrl = window.location.href;
            
            // ALWAYS redirect visiblelight.ai to supercluster subdomain (except auth pages)
            if ((currentHost === 'visiblelight.ai' || currentHost.includes('visiblelight.ai')) && 
                !currentHost.includes('supercluster') && 
                !currentPath.includes('/auth/') &&
                !currentPath.includes('/wp-json/')) {
                
                // Check if we're being redirected to wp-admin
                if (currentPath.includes('/wp-admin') || currentPath.includes('wp-admin/') || currentUrl.includes('/wp-admin')) {
                    console.error('BLOCKED: Attempted redirect to wp-admin. Redirecting to supercluster subdomain.');
                } else {
                    console.log('Redirecting from visiblelight.ai to supercluster subdomain');
                }
                
                // Get license key from URL or session
                const urlParams = new URLSearchParams(window.location.search);
                let licenseKey = urlParams.get('license') || '';
                if (licenseKey) {
                    // Extract just the license key part (before any path)
                    const licenseMatch = licenseKey.match(/^([^/]+)/);
                    if (licenseMatch) {
                        licenseKey = licenseMatch[1];
                    }
                }
                
                // Try to get license from sessionStorage
                if (!licenseKey) {
                    try {
                        const sessionData = sessionStorage.getItem('vl-session-data');
                        if (sessionData) {
                            const parsed = JSON.parse(sessionData);
                            licenseKey = parsed.license_key || parsed.wp_activation_key || '';
                        }
                    } catch (e) {
                        console.warn('Could not read session data:', e);
                    }
                }
                
                // Preserve path if it exists (e.g., /luna-compose/)
                let path = '';
                if (currentPath && currentPath !== '/' && !currentPath.includes('/wp-admin')) {
                    // Remove leading slash and add to license path
                    path = currentPath.replace(/^\//, '');
                }
                
                // Redirect to supercluster subdomain with license
                if (licenseKey) {
                    const redirectUrl = path 
                        ? `https://supercluster.visiblelight.ai/?license=${encodeURIComponent(licenseKey)}/${path}`
                        : `https://supercluster.visiblelight.ai/?license=${encodeURIComponent(licenseKey)}`;
                    window.location.href = redirectUrl;
                } else {
                    window.location.href = 'https://supercluster.visiblelight.ai/';
                }
                return; // Stop execution
            }
        })();
        
        // Check if we're on the Omniscient App Observatory page
        const currentParams = new URLSearchParams(window.location.search);
        const currentLicense = currentParams.get('license') || '';
        const isOmniscientPage = currentLicense.includes('/omniscient-app-observatory/');
        const isLunaComposePage = currentLicense.includes('/luna-compose') || currentLicense.includes('/luna/compose/');
        const isLunaReportPage = currentLicense.includes('/luna-reports/') || currentLicense.includes('/luna/report/');
        const isLunaAutomatePage = currentLicense.includes('/workflows/automations/') || currentLicense.includes('/luna/automate/');
        
        // Check if we're on a shared document page (invite_from)
        const currentPath = window.location.pathname;
        const isSharedComposePage = currentPath.includes('/invite_from/luna/compose/');
        let sharedDocumentId = null;
        if (isSharedComposePage) {
            const match = currentPath.match(/\/invite_from\/luna\/compose\/([^\/]+)/);
            if (match && match[1]) {
                sharedDocumentId = match[1];
            }
        }
        
        // Only load the loading animation script on the main Supercluster dashboard page
        // NOT on internal pages like /luna/compose/, /luna/report/, /luna/automate/, or /omniscient-app-observatory/
        const isMainDashboardPage = !isOmniscientPage && !isLunaComposePage && !isLunaReportPage && !isLunaAutomatePage;
        
        if (isMainDashboardPage) {
            const script = document.createElement('script');
            script.src = 'https://supercluster.visiblelight.ai/assets/js/supercluster-load-animation.js';
            script.async = true;
            document.head.appendChild(script);
        }
        
        // Helper function to hide/remove galaxy labels
        // Only hides labels on internal pages (stream pages, category pages, etc.), NOT on main dashboard
        function hideSuperclusterLabels() {
            // Check if we're on the main Supercluster dashboard page
            const currentParams = new URLSearchParams(window.location.search);
            const currentLicense = currentParams.get('license') || '';
            const currentPath = window.location.pathname;
            
            // Check if we're on an internal page (stream page, category page, etc.)
            const isStreamPage = currentLicense.includes('/content/data-stream/') || currentPath.includes('/content/data-stream/');
            const isCategoryPage = currentLicense.includes('/content/category/') || currentPath.includes('/content/category/');
            const isOmniscientPage = currentLicense.includes('/omniscient-app-observatory/');
            const isLunaComposePage = currentLicense.includes('/luna-compose') || currentLicense.includes('/luna/compose/');
        const isLunaReportPage = currentLicense.includes('/luna-reports/') || currentLicense.includes('/luna/report/');
        const isLunaAutomatePage = currentLicense.includes('/workflows/automations/') || currentLicense.includes('/luna/automate/');
            
            // If we're on the main dashboard page, DON'T hide the labels
            const isMainDashboardPage = !isStreamPage && !isCategoryPage && !isOmniscientPage && 
                                       !isLunaComposePage && !isLunaReportPage && !isLunaAutomatePage;
            
            if (isMainDashboardPage) {
                // On main dashboard, ensure labels are visible
                const labelsContainer = document.querySelector('.vl-supercluster-labels');
                if (labelsContainer) {
                    labelsContainer.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
                }
                return; // Don't hide labels on main dashboard
            }
            
            // On internal pages, hide/remove the labels
            const labelsContainer = document.querySelector('.vl-supercluster-labels');
            if (labelsContainer) {
                labelsContainer.remove();
            }
        }
        
        // Helper function to hide only the Three.js canvas while keeping the container visible
        // Only hides canvas on internal pages (stream pages, category pages, etc.), NOT on main dashboard
        function hideThreeJSCanvas() {
            // Check if we're on the main Supercluster dashboard page
            const currentParams = new URLSearchParams(window.location.search);
            const currentLicense = currentParams.get('license') || '';
            const currentPath = window.location.pathname;
            
            // Check if we're on an internal page (stream page, category page, etc.)
            const isStreamPage = currentLicense.includes('/content/data-stream/') || currentPath.includes('/content/data-stream/');
            const isCategoryPage = currentLicense.includes('/content/category/') || currentPath.includes('/content/category/');
            const isOmniscientPage = currentLicense.includes('/omniscient-app-observatory/');
            const isLunaComposePage = currentLicense.includes('/luna-compose') || currentLicense.includes('/luna/compose/');
        const isLunaReportPage = currentLicense.includes('/luna-reports/') || currentLicense.includes('/luna/report/');
        const isLunaAutomatePage = currentLicense.includes('/workflows/automations/') || currentLicense.includes('/luna/automate/');
            
            // If we're on the main dashboard page, DON'T hide the canvas
            const isMainDashboardPage = !isStreamPage && !isCategoryPage && !isOmniscientPage && 
                                       !isLunaComposePage && !isLunaReportPage && !isLunaAutomatePage;
            
            // Hide widgets on non-main Supercluster pages
            // BUT: Keep recentActivityWidget visible on Luna Composer page (it will be replaced with History)
            const superclusterWidget = document.getElementById('yourSuperclusterWidget');
            const activityWidget = document.getElementById('recentActivityWidget');
            
            if (!isMainDashboardPage) {
                // Hide supercluster widget on other pages
                if (superclusterWidget) {
                    superclusterWidget.style.display = 'none';
                }
                // Keep activity widget visible on Luna Composer page - it will be replaced with History
                if (activityWidget && !isLunaComposePage) {
                    activityWidget.style.display = 'none';
                } else if (activityWidget && isLunaComposePage) {
                    // Ensure it's visible for Luna Composer (will be replaced with History)
                    activityWidget.style.display = '';
                }
            } else {
                // Show widgets on main Supercluster page
                if (superclusterWidget) {
                    superclusterWidget.style.display = '';
                }
                if (activityWidget) {
                    activityWidget.style.display = '';
                }
            }
            
            if (isMainDashboardPage) {
                // On main dashboard, ensure canvas is visible
            const rootContainer = document.getElementById('vlSuperclusterRoot');
            if (rootContainer) {
                    const canvasElements = rootContainer.querySelectorAll('canvas');
                    canvasElements.forEach(canvas => {
                        const isThreeJSCanvas = canvas.getAttribute('data-engine') === 'three.js r180' || 
                                               canvas.getAttribute('data-engine')?.includes('three.js') ||
                                               (!canvas.getAttribute('data-engine') && canvasElements.length === 1);
                        if (isThreeJSCanvas) {
                            // Ensure canvas is visible on main dashboard
                            canvas.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important; pointer-events: auto !important; z-index: auto !important;';
                        }
                    });
                }
                return; // Don't hide canvas on main dashboard
            }
            
            // On internal pages, hide the canvas
            const rootContainer = document.getElementById('vlSuperclusterRoot');
            if (rootContainer) {
                // Keep the container visible
                rootContainer.style.setProperty('display', 'block', 'important');
                rootContainer.style.setProperty('visibility', 'visible', 'important');
                rootContainer.style.setProperty('opacity', '1', 'important');
                rootContainer.style.setProperty('pointer-events', 'auto', 'important');
                
                // Hide only the canvas element(s) inside the container
                const canvasElements = rootContainer.querySelectorAll('canvas');
                canvasElements.forEach(canvas => {
                    // Check if it's the Three.js canvas (has data-engine="three.js r180" or is the main canvas)
                    const isThreeJSCanvas = canvas.getAttribute('data-engine') === 'three.js r180' || 
                                           canvas.getAttribute('data-engine')?.includes('three.js') ||
                                           (!canvas.getAttribute('data-engine') && canvasElements.length === 1); // If only one canvas, assume it's Three.js
                    if (isThreeJSCanvas) {
                        canvas.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important; pointer-events: none !important; z-index: -1 !important;';
                    }
                });
            }
        }
        
        // Render Omniscient App Observatory page
        async function renderOmniscientAppObservatory() {
            console.log('[Omniscient App Observatory] Rendering page...');
            
            // CRITICAL: Neutralize the Supercluster visualization canvas immediately
            hideThreeJSCanvas();
            
            // Ensure overlays and menus remain visible
            const overlay = document.querySelector('.vl-supercluster-overlay');
            const header = document.querySelector('.vl-header');
            const mainMenu = document.querySelector('.vl-main-menu');
            const rightSidebar = document.querySelector('.vl-right-sidebar');
            
            if (overlay) {
                overlay.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
            }
            if (header) {
                header.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
            }
            if (mainMenu) {
                mainMenu.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
            }
            if (rightSidebar) {
                rightSidebar.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
            }
            
            // Show the page content container
            const pageContent = document.getElementById('vlPageContent');
            if (!pageContent) {
                console.error('[Omniscient App Observatory] Page content element not found!');
                return;
            }
            
            const escapeAttr = (value) => {
                if (value === undefined || value === null) {
                    return '';
                }
                return String(value)
                    .replace(/&/g, '&amp;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;');
            };

            const resolveObservatoryImage = (site) => {
                if (!site || typeof site !== 'object') {
                    return '';
                }

                const candidates = [];
                const pushCandidate = (candidate) => {
                    if (!candidate) {
                        return;
                    }
                    if (Array.isArray(candidate)) {
                        candidate.forEach(pushCandidate);
                        return;
                    }
                    if (typeof candidate === 'string') {
                        const trimmed = candidate.trim();
                        if (trimmed !== '') {
                            candidates.push(trimmed);
                        }
                    }
                };

                pushCandidate(site.og_image);
                pushCandidate(site.ogImage);
                pushCandidate(site.og_image_url);
                pushCandidate(site.ogImageUrl);
                pushCandidate(site.open_graph_image);
                pushCandidate(site.openGraphImage);
                pushCandidate(site.opengraph_image);
                pushCandidate(site.social_image);
                pushCandidate(site.socialImage);
                pushCandidate(site.image);
                pushCandidate(site.preview_image);
                pushCandidate(site.screenshot);

                if (site.opengraph && typeof site.opengraph === 'object') {
                    pushCandidate(site.opengraph.image);
                    pushCandidate(site.opengraph.og_image);
                    pushCandidate(site.opengraph.images);
                }

                if (site.social && typeof site.social === 'object') {
                    pushCandidate(site.social.image);
                    if (site.social.opengraph && typeof site.social.opengraph === 'object') {
                        pushCandidate(site.social.opengraph.image);
                    }
                }

                if (site.meta && typeof site.meta === 'object') {
                    pushCandidate(site.meta.og_image);
                    pushCandidate(site.meta.ogImage);
                }

                if (site.meta_tags && typeof site.meta_tags === 'object') {
                    pushCandidate(site.meta_tags['og:image']);
                    pushCandidate(site.meta_tags['og_image']);
                }

                const unique = candidates.filter((value, index, array) => array.indexOf(value) === index);
                return unique.length > 0 ? unique[0] : '';
            };
            
            // Get license key from URL
            const urlParams = new URLSearchParams(window.location.search);
            const urlLicense = urlParams.get('license') || '';
            let licenseKey = '';
            if (urlLicense) {
                const licenseMatch = urlLicense.match(/^([^/]+)/);
                if (licenseMatch) {
                    licenseKey = licenseMatch[1];
                } else {
                    licenseKey = urlLicense;
                }
            }
            
            if (!licenseKey) {
                pageContent.innerHTML = '<div style="padding: 40px; color: #fff4e9; text-align: center;"><h1>Error</h1><p>License key not found.</p></div>';
                return;
            }
            
            try {
                console.log('[Omniscient App Observatory] Fetching sites for license:', licenseKey);
                
                // Fetch all sites for this client
                const response = await fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/client-sites?license=${encodeURIComponent(licenseKey)}`, {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include'
                });
                
                console.log('[Omniscient App Observatory] Response status:', response.status);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('[Omniscient App Observatory] API error:', response.status, errorText);
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('[Omniscient App Observatory] Response data:', data);
                
                if (!data.ok) {
                    throw new Error(data.error || 'Invalid response from server');
                }
                
                const sites = data.sites || [];
                const rawTotalSites = Number(data.total);
                const totalSites = Number.isFinite(rawTotalSites) ? rawTotalSites : (Array.isArray(sites) ? sites.length : 0);
                const observedLabel = totalSites === 1 ? 'app observed' : 'apps observed';
                
                console.log('[Omniscient App Observatory] Sites found:', totalSites, sites);
                
                // Build HTML with explicit background
                let html = '<div class="omniscient-observatory" style="min-height: 100vh; color: #fff4e9; padding: 40px 0; width: 55%; max-width:100%; margin: 0 auto; position: relative; z-index: 1000;">';
                
                // Header with total count
                html += '<div style="margin-bottom: 30px;">';
                html += '<h1 class="TypeGradient" style="margin-bottom: 10px; font-size: 1.5rem; margin-top:0 !important;">Omniscient App Observatory</h1>';
                html += '<div class="observatory-subtitle" style="color: #9A9793; font-size: 0.875rem; margin: 0 0 20px 0;">' + totalSites + ' ' + observedLabel + '</div>';
                
                // Search and View Toggle
                html += '<div style="display: flex; align-items: center; gap: 20px; margin-bottom: 30px; flex-wrap: wrap;">';
                html += '<div style="flex: 1; min-width: 300px;">';
                html += '<input type="text" id="observatory-search" placeholder="Search sites/apps..." style="width: 100%; padding: 10px 16px; opacity:.7; background: rgba(0,0,0,.1); border: 1px solid #1f1d1a; border-radius: 6px; color: #fff4e9; font-size: 0.875rem; outline: none;" />';
                html += '</div>';
                html += '<div style="display: flex; align-items: center; gap: 10px;">';
                html += '<span style="color: #9A9793; font-size: 0.875rem;">View:</span>';
                html += '<button id="view-list-btn" class="view-toggle-btn active" data-view="list" style="padding: 8px 16px; background: linear-gradient(270deg, #974C00 0%, #8D8C00 100%) !important; border: 1px solid transparent; color: #fff4e9 !important; border-radius: 6px; cursor: pointer; font-size: 0.875rem; transition: all 0.2s ease;">List</button>';
                html += '<button id="view-block-btn" class="view-toggle-btn" data-view="block" style="padding: 8px 16px; background: #2E2C2A50; border: 1px solid #5A575335; color: #9A9793; border-radius: 6px; cursor: pointer; font-size: 0.875rem; transition: all 0.2s ease;">Block</button>';
                html += '</div>';
                html += '</div>';
                
                // Sites Container
                html += '<div id="observatory-sites-container" class="observatory-list-view" style="display: grid; gap: 20px;">';
                
                if (sites.length === 0) {
                    html += '<div style="text-align: center; padding: 60px 20px; color: #9A9793;"><p>No sites/apps found. Assign sites to this client in WP Admin > VL Clients > VL Hub Profile > Client Syncing.</p></div>';
                } else {
                    sites.forEach((site, index) => {
                        const siteId = 'site-' + index;
                        const ogImageUrl = resolveObservatoryImage(site);
                        const hasOgImage = ogImageUrl !== '';
                        const safeOgImage = escapeAttr(ogImageUrl);
                        const safeImageAlt = escapeAttr(site.title || site.domain || 'Site');
                        const fallbackSharedStyles = 'width: 100%; height: 100%; align-items: center; justify-content: center; color: #9A9793; font-size: 0.75rem;';
                        const fallbackShownStyles = 'display: flex; ' + fallbackSharedStyles;
                        const fallbackHiddenStyles = 'display: none; ' + fallbackSharedStyles;
                        const imageErrorHandler = escapeAttr("this.remove(); const fallback = this.nextElementSibling; if (fallback) { fallback.style.display = 'flex'; }");
                        html += '<div class="observatory-site-item" data-site-url="' + (site.url || '').toLowerCase() + '" data-site-title="' + (site.title || '').toLowerCase() + '" data-site-domain="' + (site.domain || '').toLowerCase() + '" style="background: #000000; border: 1px solid #1f1d1a; border-radius: 8px; padding: 20px; transition: all 0.2s ease; cursor: pointer;" onmouseover="this.style.borderColor=\'#5A5753\';" onmouseout="this.style.borderColor=\'#2E2C2A\';" onclick="window.open(\'' + (site.url || '#') + '\', \'_blank\');">';
                        
                        // Block view layout
                        html += '<div class="observatory-site-block" style="display: grid; grid-template-columns: 120px 1fr auto; gap: 20px; align-items: start;">';
                        
                        // OG Image
                        html += '<div style="width: 120px; height: 120px; background: #2E2C2A; border-radius: 6px; overflow: hidden; flex-shrink: 0;">';
                        if (hasOgImage) {
                            html += '<img src="' + safeOgImage + '" alt="' + safeImageAlt + '" style="width: 100%; height: 100%; object-fit: cover;" onerror="' + imageErrorHandler + '" />';
                            html += '<div class="observatory-no-image" style="' + fallbackHiddenStyles + '">No Image</div>';
                        } else {
                            html += '<div class="observatory-no-image" style="' + fallbackShownStyles + '">No Image</div>';
                        }
                        html += '</div>';
                        
                        // Site Info
                        html += '<div style="flex: 1;">';
                        html += '<h3 style="color: #fff4e9; margin: 0 0 8px 0; font-size: 1.2rem; font-weight: 400;">' + (site.title || site.domain || site.url || 'Untitled Site') + '</h3>';
                        html += '<p style="color: #9A9793; margin: 0 0 12px 0; font-size: 0.875rem; word-break: break-all;">' + (site.url || '') + '</p>';
                        
                        // Status badges
                        html += '<div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 12px;">';
                        
                        // Ping Status
                        html += '<span style="padding: 4px 12px; border-radius: 12px; font-size: 0.75rem; font-weight: 600; background: ' + (site.ping_color || '#9A9793') + '; color: #fff4e9;">' + (site.ping_label || 'Unknown') + '</span>';
                        
                        // SSL/TLS Status
                        let sslLabel = 'Unknown';
                        let sslColor = '#9A9793';
                        if (site.ssl_status === 'valid') {
                            sslLabel = 'HTTPS';
                            sslColor = '#0F9900';
                        } else if (site.ssl_status === 'expiring_soon') {
                            sslLabel = 'SSL Expiring Soon';
                            sslColor = '#dba617';
                        } else if (site.ssl_status === 'expired') {
                            sslLabel = 'SSL Expired';
                            sslColor = '#d63638';
                        } else if (site.ssl_status === 'not_https') {
                            sslLabel = 'Not HTTPS';
                            sslColor = '#9A9793';
                        }
                        html += '<span style="padding: 4px 12px; border-radius: 12px; font-size: 0.75rem; font-weight: 600; background: ' + sslColor + '; color: #fff4e9;">' + sslLabel + '</span>';
                        
                        html += '</div>';
                        
                        // New Metrics Section
                        html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 12px; margin-top: 12px; padding-top: 12px; border-top: 1px solid #1f1d1a;">';
                        
                        // Uptime Percentage
                        if (site.uptime_percent !== null && site.uptime_percent !== undefined) {
                            html += '<div style="display: flex; flex-direction: column; gap: 4px;">';
                            html += '<span style="color: #9A9793; font-size: 0.75rem;">Uptime (30d)</span>';
                            html += '<span style="color: #fff4e9; font-size: 0.875rem; font-weight: 600;">' + parseFloat(site.uptime_percent).toFixed(1) + '%</span>';
                            html += '</div>';
                        }
                        
                        // Total Visitors (GA4 Active Users)
                        if (site.total_visitors !== null && site.total_visitors !== undefined) {
                            html += '<div style="display: flex; flex-direction: column; gap: 4px;">';
                            html += '<span style="color: #9A9793; font-size: 0.75rem;">Total Visitors</span>';
                            html += '<span style="color: #fff4e9; font-size: 0.875rem; font-weight: 600;">' + parseInt(site.total_visitors).toLocaleString() + '</span>';
                            html += '</div>';
                        }
                        
                        // New Visits (GA4 New Users)
                        if (site.new_visits !== null && site.new_visits !== undefined) {
                            html += '<div style="display: flex; flex-direction: column; gap: 4px;">';
                            html += '<span style="color: #9A9793; font-size: 0.75rem;">New Visits</span>';
                            html += '<span style="color: #fff4e9; font-size: 0.875rem; font-weight: 600;">' + parseInt(site.new_visits).toLocaleString() + '</span>';
                            html += '</div>';
                        }
                        
                        // WordPress Admin Login URL
                        if (site.wp_admin_url) {
                            html += '<div style="display: flex; flex-direction: column; gap: 4px;">';
                            html += '<span style="color: #9A9793; font-size: 0.75rem;">WP Admin</span>';
                            html += '<a href="' + escapeAttr(site.wp_admin_url) + '" target="_blank" rel="noopener noreferrer" onclick="event.stopPropagation();" style="color: #fff4e9; font-size: 0.8rem; text-decoration: none; word-break: break-all;">Login →</a>';
                            html += '</div>';
                        }
                        
                        // SEO Score (placeholder)
                        if (site.seo_score !== null && site.seo_score !== undefined) {
                            html += '<div style="display: flex; flex-direction: column; gap: 4px;">';
                            html += '<span style="color: #9A9793; font-size: 0.75rem;">SEO Score</span>';
                            html += '<span style="color: #fff4e9; font-size: 0.875rem; font-weight: 600;">' + (site.seo_score !== null ? site.seo_score : 'N/A') + '</span>';
                            html += '</div>';
                        }
                        
                        html += '</div>';
                        html += '</div>';
                        
                        html += '</div>';
                        
                        // List view layout (hidden by default)
                        html += '<div class="observatory-site-list" style="display: none; grid-template-columns: 80px 1fr auto auto auto; gap: 16px; align-items: center;">';
                        html += '<div style="width: 80px; height: 80px; background: #2E2C2A; border-radius: 6px; overflow: hidden; flex-shrink: 0; border: 1px solid #1f1d1a;">';
                        if (hasOgImage) {
                            html += '<img src="' + safeOgImage + '" alt="' + safeImageAlt + '" style="width: 100%; height: 100%; object-fit: cover;" onerror="' + imageErrorHandler + '" />';
                            html += '<div class="observatory-no-image" style="' + fallbackHiddenStyles + '">No Image</div>';
                        } else {
                            html += '<div class="observatory-no-image" style="' + fallbackShownStyles + '">No Image</div>';
                        }
                        html += '</div>';
                        html += '<div style="flex: 1; min-width: 0;">';
                        html += '<h3 style="color: #fff4e9; margin: 0 0 4px 0; font-size: 1rem; font-weight: 400; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">' + (site.title || site.domain || site.url || 'Untitled Site') + '</h3>';
                        html += '<p style="color: #9A9793; margin: 0; font-size: 0.875rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">' + (site.url || '') + '</p>';
                        // Add metrics in list view (compact)
                        html += '<div style="display: flex; gap: 12px; margin-top: 4px; flex-wrap: wrap;">';
                        if (site.uptime_percent !== null && site.uptime_percent !== undefined) {
                            html += '<span style="color: #9A9793; font-size: 0.9rem;">Uptime: <span style="color: #fff4e9;">' + parseFloat(site.uptime_percent).toFixed(1) + '%</span></span>';
                        }
                        if (site.total_visitors !== null && site.total_visitors !== undefined) {
                            html += '<span style="color: #9A9793; font-size: 0.9rem;">Visitors: <span style="color: #fff4e9;">' + parseInt(site.total_visitors).toLocaleString() + '</span></span>';
                        }
                        if (site.new_visits !== null && site.new_visits !== undefined) {
                            html += '<span style="color: #9A9793; font-size: 0.9rem;">New: <span style="color: #fff4e9;">' + parseInt(site.new_visits).toLocaleString() + '</span></span>';
                        }
                        if (site.wp_admin_url) {
                            html += '<a href="' + escapeAttr(site.wp_admin_url) + '" target="_blank" rel="noopener noreferrer" onclick="event.stopPropagation();" style="color: #58a6ff; font-size: 0.7rem; text-decoration: none; font-size:.9rem;">WP Admin →</a>';
                        }
                        html += '</div>';
                        html += '</div>';
                        html += '<div style="display: flex; gap: 8px; flex-direction: column; text-align:center;">';
                        html += '<span style="padding: 4px 12px; border-radius: 12px; font-size: 0.75rem; font-weight: 600; background: ' + (site.ping_color || '#9A9793') + '; color: #fff4e9;">' + (site.ping_label || 'Unknown') + '</span>';
                        html += '<span style="padding: 4px 12px; border-radius: 12px; font-size: 0.75rem; font-weight: 600; background: ' + sslColor + '; color: #fff4e9;">' + sslLabel + '</span>';
                        html += '</div>';
                        html += '</div>';
                        
                        html += '</div>';
                    });
                }
                
                html += '</div>';
                html += '</div>';
                
                // Add CSS
                html += '<style>';
                html += '.observatory-list-view .observatory-site-item > .observatory-site-list { display: grid !important; }';
                html += '.observatory-list-view .observatory-site-item > .observatory-site-block { display: none !important; }';
                html += '.observatory-block-view .observatory-site-item > .observatory-site-block { display: grid !important; }';
                html += '.observatory-block-view .observatory-site-item > .observatory-site-list { display: none !important; }';
                html += '.view-toggle-btn.active { background: linear-gradient(270deg, #974C00 0%, #8D8C00 100%) !important; color: #000 !important; border:none !important;}';
                html += '.view-toggle-btn:not(.active) { background: #2E2C2A50 !important; color: #9A9793 !important; }';
                html += '</style>';
                
                pageContent.innerHTML = html;
                
                // Initialize heading style selector
                setTimeout(function() {
                    initHeadingStyleSelector();
                }, 100);
                
                // CRITICAL: Force page content to be visible with !important styles
                pageContent.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important; position: relative !important; z-index: 1000 !important; background: #000000 !important; min-height: 100vh !important;';
                
                // Keep the Supercluster container visible while suppressing only the Three.js canvas
                hideThreeJSCanvas();
                
                // Force overlays to remain visible
                const overlay = document.querySelector('.vl-supercluster-overlay');
                const header = document.querySelector('.vl-header');
                const mainMenu = document.querySelector('.vl-main-menu');
                const rightSidebar = document.querySelector('.vl-right-sidebar');
                
                if (overlay) {
                    overlay.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
                }
                if (header) {
                    header.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
                }
                if (mainMenu) {
                    mainMenu.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
                }
                if (rightSidebar) {
                    rightSidebar.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
                }
                
                // Use MutationObserver to prevent content from being hidden
                const observer = new MutationObserver(function(mutations) {
                    mutations.forEach(function(mutation) {
                        if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
                            const target = mutation.target;
                            if (target === pageContent) {
                                const display = window.getComputedStyle(target).display;
                                if (display === 'none') {
                                    console.warn('[Omniscient] Page content was hidden, forcing it visible');
                                    target.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important; position: relative !important; z-index: 10 !important;';
                                }
                            }
                        }
                    });
                });
                
                observer.observe(pageContent, {
                    attributes: true,
                    attributeFilter: ['style', 'class']
                });
                
                // Also set up periodic checks to ensure content stays visible
                // Only run visibility check on supercluster subdomain
                const currentHost = window.location.hostname;
                const isSuperclusterDomain = currentHost.includes('supercluster.visiblelight.ai');
                
                if (isSuperclusterDomain) {
                const visibilityCheck = setInterval(() => {
                    const computedDisplay = window.getComputedStyle(pageContent).display;
                    if (pageContent.style.display === 'none' || computedDisplay === 'none') {
                        console.warn('[Omniscient] Page content hidden, restoring visibility');
                        pageContent.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important; position: relative !important; z-index: 1000 !important; background: transparent !important;';
                    }
                    
                    // Ensure the Supercluster container remains visible for UI elements
                    if (rootContainer) {
                        const rootDisplay = window.getComputedStyle(rootContainer).display;
                        if (rootDisplay === 'none') {
                            rootContainer.style.setProperty('display', 'block', 'important');
                            rootContainer.style.setProperty('visibility', 'visible', 'important');
                            rootContainer.style.setProperty('opacity', '1', 'important');
                            rootContainer.style.setProperty('pointer-events', 'auto', 'important');
                        }
                    }
                    
                    // Ensure canvas stays hidden
                    const canvasElements = document.querySelectorAll('canvas');
                    canvasElements.forEach(canvas => {
                        const canvasDisplay = window.getComputedStyle(canvas).display;
                        if (canvasDisplay !== 'none') {
                            canvas.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important; pointer-events: none !important; z-index: -1 !important;';
                        }
                    });
                }, 500);
                    }
                
                // Store interval ID for cleanup if needed
                window.omniscientVisibilityCheck = visibilityCheck;
                
                // Initialize search and view toggle
                const searchInput = document.getElementById('observatory-search');
                const viewListBtn = document.getElementById('view-list-btn');
                const viewBlockBtn = document.getElementById('view-block-btn');
                const sitesContainer = document.getElementById('observatory-sites-container');
                
                // Search functionality
                if (searchInput) {
                    searchInput.addEventListener('input', function(e) {
                        const searchTerm = e.target.value.toLowerCase().trim();
                        const siteItems = document.querySelectorAll('.observatory-site-item');
                        
                        siteItems.forEach(item => {
                            const url = item.getAttribute('data-site-url') || '';
                            const title = item.getAttribute('data-site-title') || '';
                            const domain = item.getAttribute('data-site-domain') || '';
                            
                            if (!searchTerm || url.includes(searchTerm) || title.includes(searchTerm) || domain.includes(searchTerm)) {
                                item.style.display = '';
                            } else {
                                item.style.display = 'none';
                            }
                        });
                    });
                }
                
                // View toggle functionality
                if (viewListBtn && viewBlockBtn && sitesContainer) {
                    viewListBtn.addEventListener('click', function() {
                        sitesContainer.className = 'observatory-list-view';
                        viewListBtn.classList.add('active');
                        viewBlockBtn.classList.remove('active');
                    });
                    
                    viewBlockBtn.addEventListener('click', function() {
                        sitesContainer.className = 'observatory-block-view';
                        viewBlockBtn.classList.add('active');
                        viewListBtn.classList.remove('active');
                    });
                }
                
            } catch (error) {
                console.error('[Omniscient App Observatory] Error rendering:', error);
                pageContent.innerHTML = '<div style="padding: 40px; color: #fff4e9; text-align: center;"><h1>Error</h1><p>Failed to load Omniscient App Observatory: ' + error.message + '</p></div>';
            }
        }
        
        // Render shared Luna Composer page (public access without license key)
        // Define this function early so it can be called for shared documents
        async function renderSharedLunaComposer(shareId) {
            try {
                console.log('[Luna Composer] Rendering shared document:', shareId);
                
                // Fetch shared document from WordPress
                let docData = null;
                try {
                    const response = await fetch(`https://visiblelight.ai/wp-json/luna_widget/v1/composer/shared?share_id=${encodeURIComponent(shareId)}`, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include'
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        if (data.document) {
                            docData = data.document;
                            console.log('[Luna Composer] Shared document loaded:', docData);
                        } else {
                            console.error('[Luna Composer] Document not found');
                            const pageContentEl = document.getElementById('vlPageContent');
                            if (pageContentEl) {
                                pageContentEl.innerHTML = '<div style="padding: 40px; color: #fff4e9; text-align: center;"><h1>Document Not Found</h1><p>The shared document could not be found or has been removed.</p></div>';
                            }
                            return;
                        }
                    } else {
                        console.error('[Luna Composer] Failed to load shared document:', response.status);
                        const pageContentEl = document.getElementById('vlPageContent');
                        if (pageContentEl) {
                            pageContentEl.innerHTML = '<div style="padding: 40px; color: #fff4e9; text-align: center;"><h1>Error</h1><p>Failed to load shared document.</p></div>';
                        }
                        return;
                    }
                } catch (e) {
                    console.error('[Luna Composer] Error loading shared document:', e);
                    const pageContentEl = document.getElementById('vlPageContent');
                    if (pageContentEl) {
                        pageContentEl.innerHTML = '<div style="padding: 40px; color: #fff4e9; text-align: center;"><h1>Error</h1><p>Failed to load shared document.</p></div>';
                    }
                    return;
                }
                
                // Hide only the Three.js canvas, keep container visible
                hideThreeJSCanvas();
                
                const pageContent = document.getElementById('vlPageContent');
                if (pageContent) {
                    pageContent.style.display = 'block';
                }
                
                // Remove three.js and other Supercluster elements
                const controls = document.querySelector('.vl-controls');
                if (controls) controls.remove();
                // Use helper function to hide labels (only hides on internal pages)
                hideSuperclusterLabels();
                const canvas = document.querySelector('canvas');
                if (canvas) canvas.style.display = 'none';
                
                // Build shared document viewer (read-only)
                let html = '<style>@media (min-width: 991px) { .luna-composer-page { max-width: 55% !important; } }</style>';
                html += '<div class="luna-composer-page" style="min-height: 100vh; background: transparent; color: #fff4e9; padding: 40px 0; max-width: 1200px; margin: 0 auto; position: relative; z-index: 2;">';
                html += '<div class="luna-composer__editor" style="margin-bottom: 0; min-width: 100%;">';
                html += '<h1 class="TypeGradient" style="margin-bottom: 20px; font-size: 1.5rem; margin-top: 0;">Shared Document</h1>';
                html += '<div id="luna-composer-shared-editor" style="min-height: 400px; padding: 20px; background: #000; border: 1px solid #1f1d1a; border-radius: 8px; color: #fff4e9; font-size: 1rem; line-height: 1.6;">';
                html += docData.content || '<p>No content available.</p>';
                html += '</div>';
                html += '</div>';
                html += '</div>';
                
                const pageContentEl = document.getElementById('vlPageContent');
                if (pageContentEl) {
                    pageContentEl.innerHTML = html;
                    pageContentEl.style.display = 'block';
                }
            } catch (error) {
                console.error('[Luna Composer] Error rendering shared document:', error);
                const pageContentEl = document.getElementById('vlPageContent');
                if (pageContentEl) {
                    pageContentEl.innerHTML = '<div style="padding: 40px; color: #fff4e9; text-align: center;"><h1>Error</h1><p>Failed to load shared document: ' + error.message + '</p></div>';
                }
            }
        }
        
        // Authentication check function
        async function verifyAuthenticationAndLicense() {
            try {
                // First, verify user is authenticated by checking VL Hub session
                // Include license in session check to allow cookie-less fallback
                const sessionUrl = new URL('https://visiblelight.ai/wp-json/vl-hub/v1/session');
                const currentParams = new URLSearchParams(window.location.search);
                const currentUrlLicenseParam = currentParams.get('license');
                
                // Extract just the license key (before first /) if URL contains path segments
                let extractedLicenseKey = '';
                if (currentUrlLicenseParam) {
                    // Check if license param contains path segments (e.g., "VL-XXX/category/data-stream/...")
                    const licenseMatch = currentUrlLicenseParam.match(/^([^/]+)/);
                    if (licenseMatch) {
                        extractedLicenseKey = licenseMatch[1];
                    } else {
                        extractedLicenseKey = currentUrlLicenseParam;
                    }
                }
                
                // Send only the license key (not the full path) to the session endpoint
                if (extractedLicenseKey) {
                    sessionUrl.searchParams.set('license', extractedLicenseKey);
                }

                const sessionResponse = await fetch(sessionUrl.toString(), {
                    method: 'GET',
                    credentials: 'include', // Send cookies
                    cache: 'no-store',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                });

                if (!sessionResponse.ok) {
                    console.log('Session check failed - redirecting to login');
                    window.location.href = LOGIN_PAGE_URL;
                    return null;
                }

                const sessionData = await sessionResponse.json();
                
                if (!sessionData || sessionData.authenticated !== true) {
                    console.log('User not authenticated - redirecting to login');
                    window.location.href = LOGIN_PAGE_URL;
                    return null;
                }
                
                // Get user's actual license key from session
                const userLicenseKey = sessionData.license_key || sessionData.wp_activation_key || '';
                
                console.log('Extracted license key from URL:', extractedLicenseKey);
                console.log('User license key from session:', userLicenseKey);

                // SECURITY: Verify URL license key matches authenticated user's license key
                if (!userLicenseKey) {
                    console.log('No license key found for authenticated user - redirecting to login');
                    window.location.href = LOGIN_PAGE_URL;
                    return null;
                }

                // If URL has a license key, it MUST match the user's actual license key
                // Compare only the extracted license key (not the full path)
                if (extractedLicenseKey && extractedLicenseKey.toUpperCase() !== userLicenseKey.toUpperCase()) {
                    console.error('SECURITY VIOLATION: URL license key does not match authenticated user license key');
                    console.error('URL License:', extractedLicenseKey);
                    console.error('User License:', userLicenseKey);
                    window.showVLNotification('Access denied: License key mismatch. Redirecting to login...', 'error');
                    window.location.href = LOGIN_PAGE_URL;
                    return null;
                }

                // Use the authenticated user's license key (not from URL)
                console.log('Authentication verified. Using license key:', userLicenseKey);
                
                // SECURITY: Update URL license parameter only if it doesn't match user's license key
                // But preserve the full path if it exists (for stream data pages)
                const currentUrl = new URL(window.location.href);
                const currentLicenseParam = currentUrl.searchParams.get('license');
                
                // If license param doesn't start with user's license key, update it
                // But preserve path segments if they exist
                if (currentLicenseParam && !currentLicenseParam.startsWith(userLicenseKey)) {
                    // If there's a path after the license key, preserve it
                    const pathMatch = currentLicenseParam.match(/^[^/]+(\/.+)$/);
                    if (pathMatch) {
                        // This shouldn't happen if we extracted correctly, but handle it
                        currentUrl.searchParams.set('license', userLicenseKey + pathMatch[1]);
                    } else {
                    currentUrl.searchParams.set('license', userLicenseKey);
                    }
                    // Update URL without page reload (for security - ensures URL matches user)
                    window.history.replaceState({}, '', currentUrl.toString());
                }
                
                return userLicenseKey;

            } catch (error) {
                console.error('Authentication verification failed:', error);
                window.location.href = LOGIN_PAGE_URL;
                return null;
            }
        }

        // For shared documents, skip authentication and render directly
        if (isSharedComposePage && sharedDocumentId) {
            console.log('[Supercluster] Shared document detected, bypassing authentication');
            // Render shared document without authentication
            async function renderSharedDocumentDirectly() {
                try {
                    // Hide only the Three.js canvas, keep container visible
                    hideThreeJSCanvas();
                    
                    const pageContent = document.getElementById('vlPageContent');
                    if (pageContent) {
                        pageContent.style.display = 'block';
                    }
                    
                    // Remove three.js and other Supercluster elements
                    const controls = document.querySelector('.vl-controls');
                    if (controls) controls.remove();
                    const labelsContainer = document.querySelector('.vl-supercluster-labels');
                    if (labelsContainer) labelsContainer.remove();
                    const canvas = document.querySelector('canvas');
                    if (canvas) canvas.style.display = 'none';
                    
                    // Fetch and render shared document
                    await renderSharedLunaComposer(sharedDocumentId);
                } catch (error) {
                    console.error('[Supercluster] Error rendering shared document:', error);
                    const pageContentEl = document.getElementById('vlPageContent');
                    if (pageContentEl) {
                        pageContentEl.innerHTML = '<div style="padding: 40px; color: #fff4e9; text-align: center;"><h1>Error</h1><p>Failed to load shared document: ' + error.message + '</p></div>';
                    }
                }
            }
            
            // Render immediately without authentication
            renderSharedDocumentDirectly();
        } else {
            // Verify authentication BEFORE doing anything else (for non-shared pages)
            var licenseKey = await verifyAuthenticationAndLicense();
        
        if (!licenseKey) {
            // Authentication failed - page will redirect, but prevent further execution
            // Show loading message while redirect happens
            document.body.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100vh;color:#fff4e9;font-family:Inter,sans-serif">Verifying authentication...</div>';
            // Stop execution - user is being redirected
            throw new Error('Authentication required');
        }

        // Data fetching from VL Hub
        let constellationData = null;
        let dataFetchError = null;

        // Inactivity timeout - 1 hour
        let inactivityTimeout = null;
        const INACTIVITY_TIMEOUT_MS = 60 * 60 * 1000; // 1 hour in milliseconds

        // Track user activity and reset timeout
        function resetInactivityTimer() {
            if (inactivityTimeout) {
                clearTimeout(inactivityTimeout);
            }
            
            inactivityTimeout = setTimeout(() => {
                console.log('Inactivity timeout reached - logging out');
                // Clear any stored data
                try {
                    localStorage.removeItem('vl-cms-data');
                    sessionStorage.clear();
                } catch (e) {
                    console.warn('Error clearing storage:', e);
                }
                
                // Redirect to login page (LOGIN_PAGE_URL is defined at top of script)
                window.location.href = LOGIN_PAGE_URL;
            }, INACTIVITY_TIMEOUT_MS);
        }

        // Listen for user activity events
        const activityEvents = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'click'];
        activityEvents.forEach(event => {
            document.addEventListener(event, resetInactivityTimer, { passive: true });
        });

        // Initialize inactivity timer on page load
        resetInactivityTimer();

        async function fetchConstellationData() {
            try {
                const endpoint = 'https://visiblelight.ai/wp-json/vl-hub/v1/constellation';
                const url = licenseKey ? `${endpoint}?license=${encodeURIComponent(licenseKey)}` : endpoint;
                
                console.log('Fetching constellation data from:', url);
                
                // Update debug info
                updateDebugInfo(`Fetching: ${url}`);
                
                const response = await fetch(url, {
                    method: 'GET',
                    credentials: 'include', // Send cookies for CORS
                    headers: {
                        'Content-Type': 'application/json',
                    },
                });

                console.log('Response status:', response.status);
                console.log('Response headers:', [...response.headers.entries()]);

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Error response body:', errorText);
                    throw new Error(`HTTP ${response.status}: ${response.statusText}\nResponse: ${errorText}`);
                }

                const data = await response.json();
                console.log('Constellation data received:', data);
                updateDebugInfo(`Success: ${data.total_clients || 0} clients found`);
                return data;
            } catch (error) {
                console.error('Failed to fetch constellation data:', error);
                dataFetchError = error.message;
                updateDebugInfo(`Error: ${error.message}`);
                return null;
            }
        }

        function updateDebugInfo(message) {
            const debugEl = document.getElementById('debugInfo');
            if (debugEl) {
                const timestamp = new Date().toLocaleTimeString();
                debugEl.innerHTML = `[${timestamp}] ${message}`;
            }
        }

        // Function to update galaxy data with real VL Hub data
        function updateGalaxyDataWithRealData(clientData) {
            console.log('Updating galaxy data with real data:', clientData);
            
            // Check if galaxyData is defined
            if (typeof galaxyData === 'undefined' || !galaxyData || !Array.isArray(galaxyData)) {
                console.warn('[Supercluster] galaxyData not yet initialized, skipping update');
                return;
            }
            
            // Update galaxy data with real metrics
            galaxyData.forEach(galaxy => {
                const matchingCategory = clientData.categories?.find(cat => 
                    galaxy.datasetSlugs.some(slug => 
                        cat.name.toLowerCase().includes(slug.toLowerCase()) ||
                        cat.name.toLowerCase().includes('infrastructure') && slug === 'infrastructure' ||
                        cat.name.toLowerCase().includes('content') && slug === 'content' ||
                        cat.name.toLowerCase().includes('security') && slug === 'security' ||
                        cat.name.toLowerCase().includes('plugins') && slug === 'plugins' ||
                        cat.name.toLowerCase().includes('users') && slug === 'users' ||
                        cat.name.toLowerCase().includes('ai') && slug === 'ai' ||
                        cat.name.toLowerCase().includes('sessions') && slug === 'sessions' ||
                        cat.name.toLowerCase().includes('integrations') && slug === 'integrations'
                    )
                );

                if (matchingCategory) {
                    galaxy.metrics = {
                        categoryName: matchingCategory.name,
                        clientName: clientData.client,
                        nodesCount: matchingCategory.nodes?.length || 0,
                        topNodes: matchingCategory.nodes?.slice(0, 4).map(node => ({
                            label: node.label,
                            detail: node.detail
                        })) || []
                    };
                    galaxy.description = `Real-time data from ${clientData.client}: ${matchingCategory.nodes?.length || 0} active signals`;
                }
            });
        }

        // Update verification panel with data
        function updateVerificationPanel(data, error = null) {
            const licenseEl = document.getElementById('verificationLicense');
            const endpointEl = document.getElementById('verificationEndpoint');
            const statusEl = document.getElementById('verificationStatus');
            const clientsEl = document.getElementById('verificationClients');
            const lastUpdateEl = document.getElementById('verificationLastUpdate');
            const dataEl = document.getElementById('verificationData');

            if (licenseEl) licenseEl.textContent = licenseKey || 'No license key';
            if (endpointEl) endpointEl.textContent = '/wp-json/vl-hub/v1/constellation';
            
            if (error) {
                if (statusEl) statusEl.textContent = `Error: ${error}`;
                if (statusEl) statusEl.style.color = '#f85149';
                if (clientsEl) clientsEl.textContent = 'Failed';
                if (lastUpdateEl) lastUpdateEl.textContent = new Date().toLocaleTimeString();
                if (dataEl) dataEl.textContent = `Error: ${error}`;
            } else if (data) {
                if (statusEl) statusEl.textContent = 'Connected';
                if (statusEl) statusEl.style.color = '#56d364';
                if (clientsEl) clientsEl.textContent = data.total_clients || 0;
                if (lastUpdateEl) lastUpdateEl.textContent = new Date().toLocaleTimeString();
                if (dataEl) dataEl.textContent = JSON.stringify(data, null, 2);
            } else {
                if (statusEl) statusEl.textContent = 'No data';
                if (statusEl) statusEl.style.color = '#f2cc60';
                if (clientsEl) clientsEl.textContent = '0';
                if (lastUpdateEl) lastUpdateEl.textContent = new Date().toLocaleTimeString();
                if (dataEl) dataEl.textContent = 'No data received';
            }
        }

        // Toggle verification panel
        function toggleVerificationPanel() {
            const content = document.getElementById('verificationContent');
            const button = document.getElementById('toggleVerification');
            if (content && button) {
                const isVisible = content.style.display !== 'none';
                content.style.display = isVisible ? 'none' : 'block';
                content.classList.toggle('show', !isVisible);
                button.textContent = isVisible ? 'Show Details' : 'Hide Details';
            }
        }

        // Manual sync function
        async function syncFromHub() {
            const syncBtn = document.getElementById('syncFromHub');
            if (syncBtn) {
                syncBtn.disabled = true;
                syncBtn.textContent = 'Syncing...';
            }

            updateDebugInfo('Manual sync initiated...');
            updateVerificationPanel(null, 'Syncing...');

            try {
                const data = await fetchConstellationData();
                constellationData = data;
                updateVerificationPanel(data, dataFetchError);
                
                // ALWAYS attempt to update with real data
                if (data && data.clients && data.clients.length > 0) {
                    updateGalaxyDataWithRealData(data.clients[0]);
                    updateDebugInfo(`Sync complete: ${data.total_clients} clients loaded`);
                    // Refresh client name after constellation data is loaded
                    await updateClientName();
                    
                    // Start galaxy updates with real connection/stream data
                    const urlParams = new URLSearchParams(window.location.search);
                    let licenseKey = urlParams.get('license') || '';
                    if (licenseKey) {
                        const licenseMatch = licenseKey.match(/^([^/]+)/);
                        if (licenseMatch) licenseKey = licenseMatch[1];
                        startGalaxyUpdates(licenseKey);
                    }
                } else {
                    // No data available - show error message
                    const errorMsg = 'error: no data able to populate your Supercluster';
                    console.error(errorMsg);
                    updateDebugInfo(errorMsg);
                    const debugEl = document.getElementById('debugInfo');
                    if (debugEl) {
                        debugEl.innerHTML = `<span style="color: #f85149;">${errorMsg}</span>`;
                    }
                }
            } catch (error) {
                updateDebugInfo(`Sync failed: ${error.message}`);
                updateVerificationPanel(null, error.message);
            } finally {
                if (syncBtn) {
                    syncBtn.disabled = false;
                    syncBtn.textContent = 'Sync From Hub';
                }
            }
        }

        // Add event listeners
        document.addEventListener('DOMContentLoaded', () => {
            const toggleBtn = document.getElementById('toggleVerification');
            const syncBtn = document.getElementById('syncFromHub');
            
            if (toggleBtn) {
                toggleBtn.addEventListener('click', toggleVerificationPanel);
            }
            
            if (syncBtn) {
                syncBtn.addEventListener('click', syncFromHub);
            }

            // Initialize Visible Light overlay
            initializeVLOverlay();
            
            // Also refresh client name after a delay to ensure constellation data is loaded
            setTimeout(async () => {
                console.log('Delayed client name refresh...');
                await refreshClientName();
            }, 2000);
        });

        // Initialize Visible Light overlay functionality
        async function initializeVLOverlay() {
            // Update client name from license key
            await updateClientName();
            
            // Update license key display
            updateLicenseKeyDisplay();
            
            // Setup menu navigation FIRST - critical functionality
            try {
            setupMenuNavigation();
            } catch (e) {
                console.error('Failed to setup menu navigation:', e);
            }
            
            // Setup connection status
            try {
            setupConnectionStatus();
            } catch (e) {
                console.error('Failed to setup connection status:', e);
            }
            
            // Setup control buttons
            try {
            setupControlButtons();
            } catch (e) {
                console.error('Failed to setup control buttons:', e);
            }
            
            // Setup client dropdown - retry if needed
            try {
            setupClientDropdown();
            } catch (e) {
                console.error('Failed to setup client dropdown:', e);
            }
            
            // Retry dropdown setup after a delay if elements weren't found
            setTimeout(() => {
                const arrow = document.getElementById('clientDropdownArrow');
                const lightbox = document.getElementById('clientDropdownLightbox');
                if (!arrow || !lightbox) {
                    console.log('Retrying dropdown setup...');
                    try {
            setupClientDropdown();
                    } catch (e) {
                        console.error('Failed to retry dropdown setup:', e);
                    }
                }
            }, 1000);
            
            // Tutorial is now initialized inline - no external file needed
        }

        // Update client name from license key
        async function updateClientName() {
            const clientNameEl = document.getElementById('clientName');
            if (clientNameEl) {
                console.log('Starting client name update process...');
                
                // First priority: Fetch VL Client Name from license data
                try {
                    const urlParams = new URLSearchParams(window.location.search);
                    const licenseKey = urlParams.get('license') || '';
                    const licenseMatch = licenseKey.match(/^([^/]+)/);
                    const extractedLicense = licenseMatch ? licenseMatch[1] : licenseKey;
                    
                    if (extractedLicense) {
                        // Try to get client_name from session endpoint (includes license data)
                        const sessionUrl = `https://visiblelight.ai/wp-json/vl-hub/v1/session?license=${encodeURIComponent(extractedLicense)}`;
                        const sessionResponse = await fetch(sessionUrl, {
                            method: 'GET',
                            credentials: 'include'
                        });
                        
                        if (sessionResponse.ok) {
                            const sessionData = await sessionResponse.json();
                            console.log('Session data:', sessionData);
                            
                            // Check for client_name in license data
                            if (sessionData && sessionData.license && sessionData.license.client_name) {
                                const clientName = sessionData.license.client_name;
                                console.log('Using VL Client Name from session endpoint:', clientName);
                                clientNameEl.textContent = clientName;
                                // Update avatar after name is set
                                await updateClientAvatar();
                                return;
                            }
                            
                            // Fallback: Check all-connections endpoint for client_name
                            const connectionsUrl = `https://visiblelight.ai/wp-json/vl-hub/v1/all-connections?license=${encodeURIComponent(extractedLicense)}`;
                            const connectionsResponse = await fetch(connectionsUrl, {
                                method: 'GET',
                                credentials: 'include'
                            });
                            
                            if (connectionsResponse.ok) {
                                const connectionsData = await connectionsResponse.json();
                                console.log('Connections data:', connectionsData);
                                
                                // Check for client_name in license data
                                if (connectionsData && connectionsData.license && connectionsData.license.client_name) {
                                    const clientName = connectionsData.license.client_name;
                                    console.log('Using VL Client Name from all-connections endpoint:', clientName);
                                    clientNameEl.textContent = clientName;
                                    // Update avatar after name is set
                                    await updateClientAvatar();
                                    return;
                                }
                            }
                        }
                    }
                } catch (e) {
                    console.warn('Could not fetch VL Client Name:', e);
                }
                
                // Second priority: Use tutorialUsername (same source as tutorial checkbox)
                // This ensures consistency - same username shown in greeting and tutorial
                // Check window.tutorialUsername (set by tutorial-popup.html) or try to fetch it
                if (window.tutorialUsername) {
                    console.log('Using tutorialUsername from tutorial-status endpoint:', window.tutorialUsername);
                    clientNameEl.textContent = window.tutorialUsername;
                    // Update avatar after name is set
                    await updateClientAvatar();
                    return;
                }
                
                // Try to fetch tutorial username if not already loaded
                try {
                    const urlParams = new URLSearchParams(window.location.search);
                    const licenseKey = urlParams.get('license') || '';
                    const licenseMatch = licenseKey.match(/^([^/]+)/);
                    const extractedLicense = licenseMatch ? licenseMatch[1] : licenseKey;
                    
                    if (extractedLicense) {
                        const tutorialStatusUrl = `https://visiblelight.ai/wp-json/vl-hub/v1/tutorial-status?license=${encodeURIComponent(extractedLicense)}`;
                        const response = await fetch(tutorialStatusUrl, {
                            method: 'GET',
                            credentials: 'include'
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            if (data && data.username) {
                                window.tutorialUsername = data.username;
                                console.log('Fetched tutorialUsername:', window.tutorialUsername);
                                clientNameEl.textContent = window.tutorialUsername;
                                // Update avatar after name is set
                                await updateClientAvatar();
                                return;
                            }
                        }
                    }
                } catch (e) {
                    console.warn('Could not fetch tutorial username:', e);
                }
                
                // Second priority: Try to get user data from constellation data
                if (constellationData && constellationData.clients && constellationData.clients.length > 0) {
                    const clientData = constellationData.clients[0];
                    console.log('Checking constellation data for user info:', clientData);
                    
                    // Try to get client name from constellation client field first
                    console.log('clientData.client value:', clientData.client);
                    if (clientData.client && clientData.client !== 'Unassigned Client') {
                        const firstName = clientData.client.split(' ')[0];
                        console.log('Using first name from constellation client field:', firstName);
                        console.log('Setting clientNameEl.textContent to:', firstName);
                        clientNameEl.textContent = firstName;
                        // Update avatar after name is set
                        await updateClientAvatar();
                        return;
                    }
                    
                    // Check if there's user data in the constellation response
                    if (clientData.user_data && clientData.user_data.display_name) {
                        const firstName = clientData.user_data.display_name.split(' ')[0];
                        console.log('Using first name from constellation user_data:', firstName);
                        clientNameEl.textContent = firstName;
                        await updateClientAvatar();
                        return;
                    }
                    
                    // Check if there's a user_id in the constellation data
                    if (clientData.user_id) {
                        try {
                            console.log('Trying to get user data by user_id:', clientData.user_id);
                            const response = await fetch(`/wp-json/wp/v2/users/${clientData.user_id}`, {
                                method: 'GET',
                                credentials: 'same-origin'
                            });
                            
                            if (response.ok) {
                                const userData = await response.json();
                                console.log('User data by user_id:', userData);
                                if (userData && userData.name) {
                                    const firstName = userData.name.split(' ')[0];
                                    console.log('Using first name from user_id lookup:', firstName);
                                    clientNameEl.textContent = firstName;
                                    await updateClientAvatar();
                                    return;
                                }
                            }
                        } catch (error) {
                            console.log('User_id lookup error:', error);
                        }
                    }
                }

                // Second priority: Try to get current user's display name using custom endpoint
                try {
                    console.log('Trying custom endpoint: /wp-json/myplugin/v1/current-user');
                    const response = await fetch('/wp-json/myplugin/v1/current-user', {
                        method: 'GET',
                        credentials: 'same-origin'
                    });
                    
                    console.log('Custom endpoint response status:', response.status);
                    if (response.ok) {
                        const userData = await response.json();
                        console.log('Custom endpoint user data:', userData);
                        if (userData && userData.display_name) {
                            // Extract first name from display_name
                            const firstName = userData.display_name.split(' ')[0];
                            console.log('Using first name from custom endpoint:', firstName);
                            clientNameEl.textContent = firstName;
                            await updateClientAvatar();
                            return;
                        }
                    }
                } catch (error) {
                    console.log('Custom endpoint error:', error);
                }

                // Second priority: Try default WordPress users endpoint
                try {
                    console.log('Trying WordPress API: /wp-json/wp/v2/users/me');
                    const response = await fetch('/wp-json/wp/v2/users/me', {
                        method: 'GET',
                        credentials: 'same-origin'
                    });
                    
                    console.log('WordPress API response status:', response.status);
                    if (response.ok) {
                        const userData = await response.json();
                        console.log('WordPress API user data:', userData);
                        if (userData && userData.name) {
                            // Extract first name from name field
                            const firstName = userData.name.split(' ')[0];
                            console.log('Using first name from WordPress API:', firstName);
                            clientNameEl.textContent = firstName;
                            await updateClientAvatar();
                            return;
                        }
                    } else {
                        const errorText = await response.text();
                        console.log('WordPress API error response:', errorText);
                    }
                } catch (error) {
                    console.log('WordPress API error:', error);
                }

                // Third priority: Try to get display name from Luna License Manager session
                if (licenseKey) {
                    console.log('Trying Luna License Manager session...');
                    const sessionData = await fetchUserDisplayName();
                    console.log('Luna License Manager session data:', sessionData);
                    if (sessionData && sessionData.user && sessionData.user.display_name) {
                        // Extract first word from display_name
                        const firstName = sessionData.user.display_name.split(' ')[0];
                        console.log('Using first name from Luna License Manager:', firstName);
                        clientNameEl.textContent = firstName;
                        await updateClientAvatar();
                        return;
                    }
                    
                    // Try to get first name from WordPress user data as fallback
                    console.log('Trying WordPress user data fallback...');
                    const userData = await fetchUserData();
                    console.log('WordPress user data fallback:', userData);
                    if (userData && userData.first_name) {
                        console.log('Using first name from WordPress user data:', userData.first_name);
                        clientNameEl.textContent = userData.first_name;
                        await updateClientAvatar();
                        return;
                    }
                    
                    // Final fallback - DON'T use license key, just use default
                    console.log('No name found, using default "Client"');
                    clientNameEl.textContent = 'Client';
                    await updateClientAvatar();
                } else {
                    // No license key, use default
                    console.log('No license key, using default "Client"');
                    clientNameEl.textContent = 'Client';
                    await updateClientAvatar();
                }
            }
        }

        // Refresh client name when constellation data is updated
        async function refreshClientName() {
            await updateClientName();
            await updateClientAvatar();
        }

        // Update client avatar (og:image or initials)
        async function updateClientAvatar() {
            const avatarEl = document.getElementById('clientAvatar');
            if (!avatarEl) return;

            try {
                // Get license key and client name
                const urlParams = new URLSearchParams(window.location.search);
                const licenseKey = urlParams.get('license') || '';
                const licenseMatch = licenseKey.match(/^([^/]+)/);
                const extractedLicense = licenseMatch ? licenseMatch[1] : licenseKey;
                
                const clientNameEl = document.getElementById('clientName');
                const clientName = clientNameEl ? clientNameEl.textContent.trim() : '';

                if (!extractedLicense) {
                    // No license, show default initials
                    showAvatarInitials(avatarEl, clientName || 'Client');
                    return;
                }

                // Try to get client site URL from profile
                let clientSiteUrl = null;
                try {
                    const profileUrl = `https://visiblelight.ai/wp-json/vl-hub/v1/profile?license=${encodeURIComponent(extractedLicense)}`;
                    const profileResponse = await fetch(profileUrl, {
                        method: 'GET',
                        credentials: 'include'
                    });

                    if (profileResponse.ok) {
                        const profileData = await profileResponse.json();
                        // Try multiple possible locations for site URL
                        if (profileData.site?.home_url) {
                            clientSiteUrl = profileData.site.home_url;
                        } else if (profileData.home_url) {
                            clientSiteUrl = profileData.home_url;
                        } else if (profileData.site && typeof profileData.site === 'string') {
                            clientSiteUrl = profileData.site;
                        }
                    }
                } catch (e) {
                    console.warn('[Client Avatar] Could not fetch profile:', e);
                }

                // If we have a site URL, try to fetch og:image
                if (clientSiteUrl) {
                    try {
                        // Try to get og:image from client sites endpoint
                        const sitesUrl = `https://visiblelight.ai/wp-json/vl-hub/v1/client-sites?license=${encodeURIComponent(extractedLicense)}`;
                        const sitesResponse = await fetch(sitesUrl, {
                            method: 'GET',
                            credentials: 'include'
                        });

                        if (sitesResponse.ok) {
                            const sitesData = await sitesResponse.json();
                            if (sitesData && sitesData.sites && Array.isArray(sitesData.sites) && sitesData.sites.length > 0) {
                                // Find the site matching our clientSiteUrl
                                const matchingSite = sitesData.sites.find(site => {
                                    const siteUrl = site.url || site.home_url || '';
                                    return siteUrl.toLowerCase().replace(/\/$/, '') === clientSiteUrl.toLowerCase().replace(/\/$/, '');
                                }) || sitesData.sites[0]; // Fallback to first site

                                // Try to extract og:image from site data
                                const ogImage = extractOgImage(matchingSite);
                                
                                if (ogImage) {
                                    // Show og:image
                                    showAvatarImage(avatarEl, ogImage);
                                    return;
                                }
                            }
                        }
                    } catch (e) {
                        console.warn('[Client Avatar] Could not fetch client sites:', e);
                    }

                    // Fallback: Try to fetch og:image directly from the site
                    try {
                        const ogImageUrl = await fetchOgImageFromSite(clientSiteUrl);
                        if (ogImageUrl) {
                            showAvatarImage(avatarEl, ogImageUrl);
                            return;
                        }
                    } catch (e) {
                        console.warn('[Client Avatar] Could not fetch og:image from site:', e);
                    }
                }

                // No og:image found, show initials
                showAvatarInitials(avatarEl, clientName || 'Client');
            } catch (error) {
                console.error('[Client Avatar] Error updating avatar:', error);
                // Fallback to initials on error
                const clientNameEl = document.getElementById('clientName');
                const clientName = clientNameEl ? clientNameEl.textContent.trim() : 'Client';
                showAvatarInitials(avatarEl, clientName);
            }
        }

        // Extract og:image from site data (similar to existing extractOgImage function)
        function extractOgImage(site) {
            if (!site || typeof site !== 'object') return null;

            const candidates = [];
            const pushCandidate = (candidate) => {
                if (typeof candidate === 'string') {
                    const trimmed = candidate.trim();
                    if (trimmed !== '') {
                        candidates.push(trimmed);
                    }
                }
            };

            pushCandidate(site.og_image);
            pushCandidate(site.ogImage);
            pushCandidate(site.og_image_url);
            pushCandidate(site.ogImageUrl);
            pushCandidate(site.open_graph_image);
            pushCandidate(site.openGraphImage);
            pushCandidate(site.opengraph_image);
            pushCandidate(site.social_image);
            pushCandidate(site.socialImage);
            pushCandidate(site.image);
            pushCandidate(site.preview_image);
            pushCandidate(site.screenshot);

            if (site.opengraph && typeof site.opengraph === 'object') {
                pushCandidate(site.opengraph.image);
                pushCandidate(site.opengraph.og_image);
                if (Array.isArray(site.opengraph.images)) {
                    pushCandidate(site.opengraph.images[0]);
                }
            }

            if (site.social && typeof site.social === 'object') {
                pushCandidate(site.social.image);
                if (site.social.opengraph && typeof site.social.opengraph === 'object') {
                    pushCandidate(site.social.opengraph.image);
                }
            }

            if (site.meta && typeof site.meta === 'object') {
                pushCandidate(site.meta.og_image);
                pushCandidate(site.meta.ogImage);
            }

            if (site.meta_tags && typeof site.meta_tags === 'object') {
                pushCandidate(site.meta_tags['og:image']);
                pushCandidate(site.meta_tags['og_image']);
            }

            const unique = candidates.filter((value, index, array) => array.indexOf(value) === index);
            return unique.length > 0 ? unique[0] : null;
        }

        // Fetch og:image directly from site HTML
        async function fetchOgImageFromSite(siteUrl) {
            try {
                // Use a proxy or CORS-enabled endpoint to fetch the site's HTML
                // For now, we'll try to construct a common og:image URL pattern
                // This is a fallback - the client-sites endpoint should provide this
                return null; // Return null to fall back to initials
            } catch (e) {
                return null;
            }
        }

        // Show avatar image
        function showAvatarImage(avatarEl, imageUrl) {
            avatarEl.innerHTML = '';
            avatarEl.style.background = 'transparent';
            avatarEl.style.display = 'flex';
            avatarEl.style.alignItems = 'center';
            avatarEl.style.justifyContent = 'center';
            
            const img = document.createElement('img');
            img.src = imageUrl;
            img.alt = 'Client Avatar';
            img.style.width = '100%';
            img.style.height = '100%';
            img.style.objectFit = 'cover';
            img.style.borderRadius = '40px';
            img.onerror = function() {
                // If image fails to load, show initials instead
                const clientNameEl = document.getElementById('clientName');
                const clientName = clientNameEl ? clientNameEl.textContent.trim() : 'Client';
                showAvatarInitials(avatarEl, clientName);
            };
            avatarEl.appendChild(img);
        }

        // Show avatar initials with gradient background
        function showAvatarInitials(avatarEl, clientName) {
            avatarEl.innerHTML = '';
            avatarEl.style.background = 'linear-gradient(90deg, #974C00 0%, #8D8C00 100%)';
            avatarEl.style.color = '#fff4e9';
            avatarEl.style.display = 'flex';
            avatarEl.style.alignItems = 'center';
            avatarEl.style.justifyContent = 'center';
            avatarEl.style.fontWeight = '600';
            avatarEl.style.fontSize = '16px';
            
            // Extract initials: first letter of first word + first letter of second word
            const words = clientName.trim().split(/\s+/).filter(w => w.length > 0);
            let initials = '';
            if (words.length >= 2) {
                initials = (words[0][0] || '').toUpperCase() + (words[1][0] || '').toUpperCase();
            } else if (words.length === 1) {
                initials = words[0][0] ? words[0][0].toUpperCase() : 'C';
            } else {
                initials = 'C'; // Default to 'C' for "Client"
            }
            
            avatarEl.textContent = initials;
        }

        // Fetch user data from WordPress API
        async function fetchUserData() {
            try {
                const response = await fetch('https://visiblelight.ai/wp-json/wp/v2/users/me', {
                    credentials: 'include'
                });
                if (response.ok) {
                    const userData = await response.json();
                    console.log('User data from WordPress:', userData);
                    return userData;
                }
            } catch (error) {
                console.log('Could not fetch user data:', error);
            }
            return null;
        }

        // Fetch user display name from Luna License Manager API
        async function fetchUserDisplayName() {
            try {
                const response = await fetch('https://visiblelight.ai/wp-json/vl-hub/v1/session', {
                    credentials: 'include'
                });
                if (response.ok) {
                    const sessionData = await response.json();
                    console.log('Session data from Luna License Manager:', sessionData);
                    return sessionData;
                }
            } catch (error) {
                console.log('Could not fetch session data:', error);
            }
            return null;
        }

        // Get client name from license key or VL Hub data
        function getClientNameFromLicense(license) {
            console.log('Getting client name, constellationData:', constellationData);
            
            // Try to get client name from constellation data first
            if (constellationData && constellationData.clients && constellationData.clients.length > 0) {
                const clientData = constellationData.clients[0];
                console.log('Client data found:', clientData);
                if (clientData.client && clientData.client !== 'Unassigned Client') {
                    // Extract first name from client name
                    const firstName = clientData.client.split(' ')[0];
                    console.log('Using first name from VL Hub:', firstName);
                    return firstName;
                }
            }
            
            // For "Unassigned Client", try to get first name from user data or site URL
            if (constellationData && constellationData.clients && constellationData.clients.length > 0) {
                const clientData = constellationData.clients[0];
                
                // Try to get first name from user data if available
                if (clientData.user_data && clientData.user_data.first_name) {
                    console.log('Using first name from user data:', clientData.user_data.first_name);
                    return clientData.user_data.first_name;
                }
                
                // Fallback to site URL extraction
                if (clientData.site) {
                    try {
                        const url = new URL(clientData.site);
                        const domain = url.hostname.replace('www.', '');
                        const siteName = domain.split('.')[0];
                        if (siteName && siteName.length > 2) {
                            console.log('Using site name as fallback:', siteName);
                            return siteName.charAt(0).toUpperCase() + siteName.slice(1);
                        }
                    } catch (e) {
                        console.log('Could not parse site URL:', e);
                    }
                }
                
                // Try to get name from display_name if available
                if (clientData.user_data && clientData.user_data.display_name) {
                    const firstName = clientData.user_data.display_name.split(' ')[0];
                    console.log('Using first name from display_name:', firstName);
                    return firstName;
                }
                
                // Try to get name from the name field if available
                if (clientData.name) {
                    const firstName = clientData.name.split(' ')[0];
                    console.log('Using first name from name field:', firstName);
                    return firstName;
                }
            }
            
            // Fallback to license key parsing - REMOVED: Don't use license key as it's sensitive
            // Instead, just return 'Client' as the default
            console.log('Using default client name');
            return 'Client';
        }

        // Update license key display
        function updateLicenseKeyDisplay() {
            console.log('updateLicenseKeyDisplay called, licenseKey:', licenseKey);
            const licenseKeyEl = document.getElementById('licenseKeyDisplay');
            const copyBtn = document.getElementById('copyLicenseBtn');
            console.log('licenseKeyEl:', licenseKeyEl, 'copyBtn:', copyBtn);
            
            if (licenseKeyEl) {
                if (licenseKey) {
                    // Only show "VL-" plus first four characters, then blurred fake text
                    const prefix = licenseKey.startsWith('VL-') ? 'VL-' : 'VL-';
                    const firstFourChars = licenseKey.substring(licenseKey.indexOf('-') + 1, licenseKey.indexOf('-') + 5);
                    const blurredText = '<span class="blurred-text">-XXXX</span>';
                    console.log('Displaying license:', prefix + firstFourChars + blurredText);
                    licenseKeyEl.innerHTML = prefix + firstFourChars + blurredText;
                    
                    // Setup copy button if it exists
                    if (copyBtn) {
                        console.log('Setting up copy button click handler');
                        copyBtn.onclick = async function() {
                            console.log('Copy button clicked, copying:', licenseKey);
                            try {
                                await navigator.clipboard.writeText(licenseKey);
                                console.log('License key copied to clipboard');
                                // Show feedback
                                const originalHTML = copyBtn.innerHTML;
                                copyBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6L9 17l-5-5"></path></svg>';
                                setTimeout(() => {
                                    copyBtn.innerHTML = originalHTML;
                                }, 2000);
                            } catch (err) {
                                console.error('Failed to copy license key:', err);
                                // Fallback for older browsers
                                const textArea = document.createElement('textarea');
                                textArea.value = licenseKey;
                                document.body.appendChild(textArea);
                                textArea.select();
                                document.execCommand('copy');
                                document.body.removeChild(textArea);
                            }
                        };
                    } else {
                        console.error('Copy button not found!');
                    }
                } else {
                    licenseKeyEl.textContent = 'No license key';
                    console.log('No license key found');
                }
            } else {
                console.error('License key element not found!');
            }
        }

        // Setup menu navigation - simplified and more reliable
        function setupMenuNavigation() {
            try {
            console.log('Setting up menu navigation...');
            const menuItems = document.querySelectorAll('.vl-main-menu a');
            console.log('Found menu items:', menuItems.length);
            
            if (menuItems.length === 0) {
                console.error('No menu items found!');
                return;
                }
            
            // CRITICAL: Always use supercluster subdomain for all navigation
            const SUPERCLUSTER_BASE_URL = 'https://supercluster.visiblelight.ai';
            
            // Get license key from URL or session
            function getLicenseKey() {
                // First try URL parameter
                const urlParams = new URLSearchParams(window.location.search);
                let licenseKey = urlParams.get('license') || '';
                if (licenseKey) {
                    // Extract just the license key part (before any path)
                    const licenseMatch = licenseKey.match(/^([^/]+)/);
                    if (licenseMatch) {
                        licenseKey = licenseMatch[1];
                    }
                }
                
                // If not in URL, try sessionStorage
                if (!licenseKey) {
                    try {
                        const sessionData = sessionStorage.getItem('vl-session-data');
                        if (sessionData) {
                            const parsed = JSON.parse(sessionData);
                            licenseKey = parsed.license_key || parsed.wp_activation_key || '';
                        }
                    } catch (e) {
                        console.warn('Could not read session data:', e);
                    }
                }
                
                return licenseKey;
            }
            
            // Map logical paths to actual Supercluster app routes
            const PATH_MAP = {
                'luna-compose': 'luna-compose/',
                'luna-report': 'luna-reports/',
                'luna-automate': 'workflows/automations/',
                'luna-connect': 'connections/'
            };
            
            // Determine current active section based on URL
            function getCurrentActiveSection() {
                const urlParams = new URLSearchParams(window.location.search);
                const currentLicense = urlParams.get('license') || '';
                const currentPath = window.location.pathname;
                
                // Check for specific pages in license parameter or path
                if (currentLicense.includes('/luna-compose') || currentLicense.includes('/luna/compose/') || 
                    currentPath.includes('/luna-compose') || currentPath.includes('/luna/compose/')) {
                    return 'compose';
                }
                if (currentLicense.includes('/luna-reports/') || currentLicense.includes('/luna/report/') ||
                    currentPath.includes('/luna-reports') || currentPath.includes('/luna/report')) {
                    return 'report';
                }
                if (currentLicense.includes('/workflows/automations/') || currentLicense.includes('/luna/automate/') ||
                    currentPath.includes('/workflows/automations') || currentPath.includes('/luna/automate')) {
                    return 'automate';
                }
                if (currentLicense.includes('/connections/') || currentPath.includes('/connections')) {
                    return 'connect';
                }
                if (currentLicense.includes('/omniscient-app-observatory/') || currentPath.includes('/omniscient-app-observatory')) {
                    return 'supercluster'; // Omniscient is part of main dashboard
                }
                
                // Default to supercluster (main dashboard) if no specific page detected
                return 'supercluster';
            }
            
            // Set active menu item based on current page
            function updateActiveMenuItem() {
                const currentSection = getCurrentActiveSection();
                console.log('Current active section:', currentSection);
                
                // Remove active class from all menu items
                menuItems.forEach(item => {
                    const li = item.parentElement;
                    if (li) {
                        li.classList.remove('active');
                    }
                });
                
                // Find and activate the correct menu item
                menuItems.forEach(item => {
                    const section = item.getAttribute('data-section');
                    if (section === currentSection) {
                        const li = item.parentElement;
                        if (li) {
                            li.classList.add('active');
                            console.log('Set active menu item:', section);
                        }
                    }
                });
            }
            
            // Set initial active state
            updateActiveMenuItem();
            
            menuItems.forEach((item, index) => {
                    const section = item.getAttribute('data-section');
                const path = item.getAttribute('data-path');
                console.log(`Setting up menu item ${index}: ${section}, path: ${path}`);
                
                // Handle Supercluster section (main dashboard)
                if (section === 'supercluster') {
                    // Set href to Supercluster Dashboard with license key if available
                    const initialLicenseKey = getLicenseKey();
                    if (initialLicenseKey) {
                        item.href = `${SUPERCLUSTER_BASE_URL}/?license=${encodeURIComponent(initialLicenseKey)}`;
                    } else {
                        item.href = '#supercluster';
                    }
                
                    // Add click handler for Supercluster with VL license key validation
                    item.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                        console.log('Supercluster menu item clicked');
                    
                        const currentLicenseKey = getLicenseKey();
                        if (!currentLicenseKey) {
                            console.error('No license key available for Supercluster navigation');
                            if (typeof window.showVLNotification === 'function') {
                                window.showVLNotification('License key not found. Please log in again.', 'error');
                            }
                            window.location.href = LOGIN_PAGE_URL;
                            return false;
                        }

                        // Update active state before navigation
                        updateActiveMenuItem();
                        
                        const dashboardUrl = `${SUPERCLUSTER_BASE_URL}/?license=${encodeURIComponent(currentLicenseKey)}`;
                        console.log('Navigating to Supercluster Dashboard:', dashboardUrl);
                        window.location.href = dashboardUrl;
                    
                    return false;
                    }, true);
                } else if (path) {
                    // For other menu items (Compose, Report, Automate, Connect), build license-validated URL
                    const licenseKey = getLicenseKey();
                    const targetPath = PATH_MAP[path] || `${path}/`;
                    
                if (licenseKey) {
                        // Set href immediately so it works even without JavaScript
                        const validatedUrl = `${SUPERCLUSTER_BASE_URL}/?license=${encodeURIComponent(licenseKey)}/${targetPath}`;
                        item.href = validatedUrl;
                        console.log(`Menu item ${index} href set to:`, validatedUrl);
                    } else {
                        item.href = '#';
                    }
                    
                    item.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const currentLicenseKey = getLicenseKey();
                        if (!currentLicenseKey) {
                            console.error('No license key available for navigation');
                            if (typeof window.showVLNotification === 'function') {
                                window.showVLNotification('License key not found. Please log in again.', 'error');
                            }
                            window.location.href = LOGIN_PAGE_URL;
                            return false;
                        }
                        
                        // Update active state before navigation
                        updateActiveMenuItem();
                        
                        // Build license-validated URL with supercluster subdomain
                        const targetPath = PATH_MAP[path] || `${path}/`;
                        const validatedUrl = `${SUPERCLUSTER_BASE_URL}/?license=${encodeURIComponent(currentLicenseKey)}/${targetPath}`;
            
                        console.log('Navigating to:', validatedUrl);
                        window.location.href = validatedUrl;
                        
                        return false;
                    }, true);
                }
            });
            } catch (e) {
                console.error('Error setting up menu navigation:', e);
            }
        }

        // Handle section navigation
        // Old menu section navigation removed - new menu uses direct URL redirects

        // Highlight specific galaxy
        function highlightGalaxy(galaxyName) {
            // Remove existing highlights
            if (window.galaxyObjects) {
                window.galaxyObjects.forEach(galaxy => {
                    if (galaxy.mesh) {
                        galaxy.mesh.material.emissive.setHex(0x000000);
                        galaxy.mesh.material.opacity = 0.8;
                    }
                });
            }
            
            // Highlight the specified galaxy
            if (galaxyName && window.galaxyObjects) {
                const targetGalaxy = window.galaxyObjects.find(galaxy => 
                    galaxy.name === galaxyName
                );
                
                if (targetGalaxy && targetGalaxy.mesh) {
                    targetGalaxy.mesh.material.emissive.setHex(0x2B6AFF);
                    targetGalaxy.mesh.material.opacity = 1.0;
                }
            }
        }


        // Setup connection status
        function setupConnectionStatus() {
            const superIconImg = document.getElementById('superclusterStatusIcon');
            const connectionIcon = document.getElementById('connectionIcon');
            const connectionStatus = document.getElementById('connectionStatus');
            
            // Check VL Hub connection status
            async function checkConnectionStatus() {
                try {
                    // Try to verify authentication and license
                    const licenseKey = await verifyAuthenticationAndLicense();
                    if (!licenseKey) {
                        updateConnectionStatus(false, 'Authentication failed');
                        return;
                    }
                    
                    // Use a lightweight endpoint check instead of full data fetch
                    const endpoint = 'https://visiblelight.ai/wp-json/vl-hub/v1/constellation';
                    const url = licenseKey ? `${endpoint}?license=${encodeURIComponent(licenseKey)}` : endpoint;
                    
                    const response = await fetch(url, {
                        method: 'GET',
                        credentials: 'include',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                    });
                    
                    const isConnected = response.ok;
                    updateConnectionStatus(isConnected, isConnected ? null : `HTTP ${response.status}`);
                } catch (error) {
                    console.error('Connection check failed:', error);
                    updateConnectionStatus(false, error.message);
                }
            }
            
            // Update connection status for both widget icon and hidden status section
            function updateConnectionStatus(isConnected, error = null) {
                const checkmarkUrl = 'https://visiblelight.ai/wp-content/uploads/2025/10/checkmark.svg';
                const xIconUrl = 'https://visiblelight.ai/wp-content/uploads/2025/10/x-close-icon.svg';
                
                if (isConnected) {
                    // Update widget icon (green checkmark)
                    if (superIconImg) {
                        superIconImg.src = checkmarkUrl;
                        superIconImg.alt = 'Connected';
                        superIconImg.className = 'status-icon';
                        // Set green background on the img element itself
                        superIconImg.style.background = '#0F9900';
                        superIconImg.style.borderRadius = '50%';
                        superIconImg.style.padding = '3px';
                    }
                    
                    // Update hidden connection status section
                    if (connectionIcon) {
                        const iconImg = connectionIcon.querySelector('img');
                        if (iconImg) {
                            iconImg.src = checkmarkUrl;
                            iconImg.alt = 'check mark';
                        }
                        connectionIcon.className = 'status-icon';
                    }
                    if (connectionStatus) {
                        connectionStatus.textContent = 'Active';
                    }
                } else {
                    // Update widget icon (red X)
                    if (superIconImg) {
                        superIconImg.src = xIconUrl;
                        superIconImg.alt = 'Disconnected';
                        superIconImg.className = 'status-icon error';
                        // Set red background on the img element itself
                        superIconImg.style.background = '#f85149';
                        superIconImg.style.borderRadius = '50%';
                        superIconImg.style.padding = '3px';
                    }
                    
                    // Update hidden connection status section
                    if (connectionIcon) {
                        const iconImg = connectionIcon.querySelector('img');
                        if (iconImg) {
                            iconImg.src = xIconUrl;
                            iconImg.alt = 'error mark';
                        }
                        connectionIcon.className = 'status-icon error';
                    }
                    if (connectionStatus) {
                        connectionStatus.textContent = 'Inactive';
                    }
                }
            }

            // REMOVED: Automatic connection status checks to prevent interference with Luna Composer
            // Connection status will only be checked on initial page load
            const currentHost = window.location.hostname;
            const isSuperclusterDomain = currentHost.includes('supercluster.visiblelight.ai');
            
            if (isSuperclusterDomain) {
                // Check once on page load only
            checkConnectionStatus();
            
                // REMOVED: Hourly interval that was causing interference
            }
        }

        const INACTIVE_STREAM_STATUSES = ['inactive', 'disabled', 'offline', 'terminated', 'cancelled', 'canceled', 'archived', 'deleted', 'removed', 'suspended', 'paused', 'disconnected', 'decommissioned', 'retired'];

        function isStreamInactive(stream) {
            if (!stream || typeof stream !== 'object') return false;

            const directStatus = typeof stream.status === 'string' ? stream.status.toLowerCase().trim() : '';
            if (directStatus) {
                if (INACTIVE_STREAM_STATUSES.some(status => directStatus.includes(status))) {
                    return true;
                }
            }

            const metadataStatus = typeof stream.metadata?.status === 'string' ? stream.metadata.status.toLowerCase().trim() : '';
            if (metadataStatus && INACTIVE_STREAM_STATUSES.some(status => metadataStatus.includes(status))) {
                return true;
            }

            if (typeof stream.active !== 'undefined') {
                const activeValue = stream.active;
                if (typeof activeValue === 'boolean') {
                    return activeValue === false;
                }
                if (typeof activeValue === 'string') {
                    const normalized = activeValue.toLowerCase().trim();
                    if (['false', '0', 'no'].includes(normalized)) {
                        return true;
                    }
                }
            }

            if (typeof stream.connected !== 'undefined') {
                const connectedValue = stream.connected;
                if (typeof connectedValue === 'boolean') {
                    return connectedValue === false;
                }
                if (typeof connectedValue === 'string') {
                    const normalized = connectedValue.toLowerCase().trim();
                    if (['false', '0', 'no', 'disconnected'].includes(normalized)) {
                        return true;
                    }
                }
            }

            return false;
        }

        function extractActiveStreams(streams) {
            const values = Array.isArray(streams) ? streams : Object.values(streams || {});
            return values.filter(stream => !isStreamInactive(stream));
        }

        function getActiveStreamCountFromResponse(streamsData) {
            if (!streamsData) return 0;
            if (typeof streamsData.active_count === 'number') {
                return streamsData.active_count;
            }
            if (typeof streamsData.count === 'number') {
                return streamsData.count;
            }
            // Use client_streams instead of streams (unified naming)
            return extractActiveStreams(streamsData.client_streams || streamsData.streams || []).length;
        }

        function getInactiveStreamCountFromResponse(streamsData, activeCount) {
            if (!streamsData) return 0;
            if (typeof streamsData.inactive_count === 'number') {
                return streamsData.inactive_count;
            }
            if (typeof streamsData.total === 'number') {
                return Math.max(streamsData.total - activeCount, 0);
            }
            // Use client_streams instead of streams (unified naming)
            const streamsObj = streamsData.client_streams || streamsData.streams || {};
            const totalStreams = Array.isArray(streamsObj)
                ? streamsObj.length
                : Object.keys(streamsObj).length;
            return Math.max(totalStreams - activeCount, 0);
        }

        // Build "Your Supercluster" summary sentence with links
        // Track last known counts for polling-based updates
        let lastStreamCount = null;
        let lastConnectionCount = null;
        
        async function updateSuperclusterSummary() {
            try {
                const summaryEl = document.getElementById('superclusterSummary');
                if (!summaryEl) return;

                // Sites count from constellationData
                const sitesCount = (constellationData && typeof constellationData.total_clients === 'number')
                    ? constellationData.total_clients
                    : 0;

                // Streams and data source counts from VL Hub all-connections endpoint for current license
                // Using all-connections endpoint (same as Luna) instead of data-streams
                let streamsCount = 0;
                let sourcesCount = 0;
                if (licenseKey) {
                    // Fetch all connections for stream count (with cache-busting)
                    const connectionsResp = await fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/all-connections?license=${encodeURIComponent(licenseKey)}&_t=${Date.now()}`, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include'
                    });
                    if (connectionsResp.ok) {
                        const connectionsResponse = await connectionsResp.json();
                        // all-connections returns {ok: true, data: {...}} structure
                        // Extract data from response
                        const connectionsData = connectionsResponse?.ok && connectionsResponse?.data ? connectionsResponse.data : connectionsResponse;
                        
                        // all-connections returns active_streams (matches luna-license-manager structure)
                        // Check for active_streams first, then fallback to stream_count
                        const activeCount = connectionsData?.active_streams || connectionsData?.stream_count || (connectionsData?.client_streams ? Object.keys(connectionsData.client_streams).length : 0);
                        streamsCount = parseInt(activeCount, 10) || 0;
                        if (lastStreamCount === null) {
                            lastStreamCount = activeCount;
                        }

                        console.log('[Supercluster] Streams count from all-connections:', {
                            active: activeCount,
                            stream_count: connectionsData?.stream_count,
                            client_streams_count: connectionsData?.client_streams ? Object.keys(connectionsData.client_streams).length : 0,
                            response: connectionsData
                        });
                        
                        // Use the same all-connections response to count all connections
                        // This endpoint returns structured connection data by category
                        console.log('[Supercluster] All-connections response:', connectionsData);
                        console.log('[Supercluster] Connections data keys:', Object.keys(connectionsData || {}));
                        
                        // Count all actual connections from all-connections endpoint
                        let connectionCount = 0;
                        const connectionDetails = {};
                        
                        // Cloudflare connection (from security category)
                        if (connectionsData.cloudflare && connectionsData.cloudflare.connected === true) {
                            connectionCount += 1;
                            connectionDetails.cloudflare = true;
                        }
                        
                        // SSL/TLS Status connection (from security category)
                        if (connectionsData.ssl_tls && (connectionsData.ssl_tls.connected === true || connectionsData.ssl_tls.certificate)) {
                            connectionCount += 1;
                            connectionDetails.ssl_tls = true;
                        }
                        
                        // Liquid Web connection (from cloudops/infrastructure category)
                        if (connectionsData.liquidweb && connectionsData.liquidweb.connected === true) {
                            connectionCount += 1;
                            connectionDetails.liquidweb = true;
                        }
                        
                        // AWS S3 connection (from cloudops/infrastructure category)
                        if (connectionsData.aws_s3 && connectionsData.aws_s3.connected === true) {
                            connectionCount += 1;
                            connectionDetails.aws_s3 = true;
                        }
                        
                        // GA4 connection (from analytics category)
                        if (connectionsData.ga4 && (connectionsData.ga4.property_id || connectionsData.ga4.metrics)) {
                            connectionCount += 1;
                            connectionDetails.ga4 = true;
                        }
                        
                        // Lighthouse/PageSpeed connection - check from profile endpoint
                        // (Not included in all-connections endpoint, need to check separately)
                        
                        // Google Search Console connection (from search category)
                        if (connectionsData.gsc && connectionsData.gsc.connected === true) {
                            connectionCount += 1;
                            connectionDetails.gsc = true;
                        }
                        
                        // Competitive category connection (from competitive category)
                        // Count as 1 connection if either competitor_reports OR vldr_metrics exists
                        const hasCompetitorReports = connectionsData.competitor_reports && Array.isArray(connectionsData.competitor_reports) && connectionsData.competitor_reports.length > 0;
                        const hasVldrMetrics = connectionsData.vldr_metrics && Object.keys(connectionsData.vldr_metrics).length > 0;
                        if (hasCompetitorReports || hasVldrMetrics) {
                            connectionCount += 1;
                            connectionDetails.competitive = true;
                            if (hasCompetitorReports) connectionDetails.competitor_reports = true;
                            if (hasVldrMetrics) connectionDetails.vldr = true;
                        }
                        
                        // WordPress Users connection (from identity category)
                        if (connectionsData.wordpress_users && connectionsData.wordpress_users.total > 0) {
                            connectionCount += 1;
                            connectionDetails.wordpress_users = true;
                        }
                        
                        // WordPress Content connection (from content category in all-connections)
                        if (connectionsData.wordpress_content && (connectionsData.wordpress_content.total_posts > 0 || connectionsData.wordpress_content.total_pages > 0 || (connectionsData.wordpress_content.posts && connectionsData.wordpress_content.posts.length > 0) || (connectionsData.wordpress_content.pages && connectionsData.wordpress_content.pages.length > 0))) {
                                connectionCount += 1;
                                connectionDetails.wordpress_content = true;
                            }
                            
                        // Lighthouse/PageSpeed connection (from analytics category in all-connections)
                        if (connectionsData.pagespeed && connectionsData.pagespeed.connected === true) {
                            connectionCount += 1;
                            connectionDetails.pagespeed = true;
                        }
                        
                        sourcesCount = connectionCount;
                        console.log('[Supercluster] Cloud Connections count:', sourcesCount, 'Connection details:', connectionDetails);
                        console.log('[Supercluster] Full connections data sample:', {
                            cloudflare: connectionsData.cloudflare,
                            ssl_tls: connectionsData.ssl_tls,
                            liquidweb: connectionsData.liquidweb,
                            aws_s3: connectionsData.aws_s3,
                            ga4: connectionsData.ga4,
                            pagespeed: connectionsData.pagespeed,
                            gsc: connectionsData.gsc,
                            competitor_reports: connectionsData.competitor_reports,
                            vldr_metrics: connectionsData.vldr_metrics,
                            wordpress_users: connectionsData.wordpress_users,
                            wordpress_content: connectionsData.wordpress_content
                        });
                        console.log('[Supercluster] Content connection check:', {
                            hasWordpressContent: !!connectionsData.wordpress_content,
                            totalPosts: connectionsData.wordpress_content?.total_posts,
                            totalPages: connectionsData.wordpress_content?.total_pages,
                            postsArray: connectionsData.wordpress_content?.posts?.length,
                            pagesArray: connectionsData.wordpress_content?.pages?.length
                        });
                        console.log('[Supercluster] Competitive connection check:', {
                            hasCompetitorReports: hasCompetitorReports,
                            hasVldrMetrics: hasVldrMetrics,
                            competitorReportsCount: connectionsData.competitor_reports?.length,
                            vldrMetricsKeys: connectionsData.vldr_metrics ? Object.keys(connectionsData.vldr_metrics).length : 0
                        });
                    } else {
                        console.error('[Supercluster] All-connections fetch failed:', connectionsResp.status, connectionsResp.statusText);
                    }
                }

                // Get license key from URL for redirect
                const currentParams = new URLSearchParams(window.location.search);
                const currentLicense = currentParams.get('license') || '';
                const licenseKeyForUrl = currentLicense.split('/')[0]; // Get just the license key, not the path
                const sitesLinkHref = licenseKeyForUrl ? `?license=${encodeURIComponent(licenseKeyForUrl)}/omniscient-app-observatory/` : '#';
                const sitesLink = `<a id="sitesLink" href="${sitesLinkHref}">${sitesCount}</a>`;
                const sourcesLink = `<a id="sourcesLink" href="#">${sourcesCount}</a>`;
                const streamsLink = `<a id="streamsLink" href="#">${streamsCount}</a>`;

                // Dynamic pluralization for "Web App(s)"
                const webAppText = sitesCount === 1 ? 'Web App' : 'Web Apps';
                const galaxyText = 'Cloud Connections';
                const streamText = 'Data Streams';

                summaryEl.innerHTML = `Observing ${sitesLink} ${webAppText} spawning ${sourcesLink} ${galaxyText}, totaling ${streamsLink} ${streamText}.`;
            } catch (e) {
                console.error('[Supercluster] Error updating summary:', e);
                const summaryEl = document.getElementById('superclusterSummary');
                if (summaryEl) {
                    // Show error details in console but don't break the UI
                    summaryEl.textContent = 'Supercluster summary unavailable.';
                }
            }
        }

        // Listen for real-time stream count updates from VL Hub admin
        if (typeof BroadcastChannel !== 'undefined') {
            const streamUpdateChannel = new BroadcastChannel('vl_streams_updates');
            streamUpdateChannel.addEventListener('message', (event) => {
                if (event.data && event.data.type === 'streams_updated') {
                    console.log('[Supercluster] Streams updated, refreshing summary...');
                    updateSuperclusterSummary();
                }
            });
        }

        // Also listen for storage events (fallback for cross-tab communication)
        window.addEventListener('storage', (e) => {
            if (e.key === 'vl_streams_updated' && e.newValue) {
                console.log('[Supercluster] Streams updated via storage event, refreshing summary...');
                updateSuperclusterSummary();
            }
        });

        // Removed 30-second polling interval - data updates are handled via:
        // 1. Initial page load
        // 2. 24-hour refresh system (on connections page)
        // 3. User-initiated force refresh (on connections page)
        // 4. 5-minute constellation data refresh (background only, no visible refresh)
        // This prevents unnecessary API calls and page refreshes

        // Populate Recent Activity from VL Hub data
        async function loadRecentActivity() {
            const listEl = document.getElementById('recentActivityList');
            if (!listEl) return;

            // Show loading state immediately
            listEl.innerHTML = '<li class="vl-activity-empty">Loading activity...</li>';

            const items = [];
            const now = Date.now();
            const withinDays = (ts, days = 7) => {
                const t = Date.parse(ts);
                return !isNaN(t) && (now - t) <= days * 24 * 60 * 60 * 1000;
            };

            // New Site Connected from constellation last_seen
            if (constellationData && Array.isArray(constellationData.clients)) {
                constellationData.clients.forEach(c => {
                    if (c.last_seen && withinDays(c.last_seen, 14)) {
                        items.push({ label: 'New Site Connected', time: c.last_seen });
                    }
                });
            }

            // Streams-based activity - NO timeout, allow full loading of all data streams
            if (licenseKey) {
                try {
                    const resp = await fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/all-connections?license=${encodeURIComponent(licenseKey)}`, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include'
                    });
                    
                    if (resp.ok) {
                        const responseData = await resp.json();
                        // all-connections returns {ok: true, data: {...}} structure
                        const data = responseData?.ok && responseData?.data ? responseData.data : responseData;
                        // all-connections returns client_streams in the data object
                        const streamArray = extractActiveStreams(data && data.client_streams ? data.client_streams : {});
                        streamArray.forEach(s => {
                            if (s.connected_at && withinDays(s.connected_at, 14)) {
                                items.push({ 
                                    label: 'New Data Source Connected', 
                                    time: s.connected_at,
                                    streamName: s.name || 'Unknown Source',
                                    streamId: s.id || null,
                                    streamData: s // Store full stream data for URL building
                                });
                            }
                            if (s.last_updated && withinDays(s.last_updated, 7)) {
                                items.push({ 
                                    label: 'New Data Stream Was Synced', 
                                    time: s.last_updated,
                                    streamName: s.name || 'Unknown Stream',
                                    streamId: s.id || null,
                                    streamData: s // Store full stream data for URL building
                                });
                            }
                        });
                        
                        // Add removed streams to activity feed
                        if (data.removed_streams && typeof data.removed_streams === 'object') {
                            const removedArray = Array.isArray(data.removed_streams) ? data.removed_streams : Object.values(data.removed_streams);
                            removedArray.forEach(removed => {
                                if (removed.removed_at && withinDays(removed.removed_at, 14)) {
                                    items.push({ 
                                        label: 'Data Stream Removed', 
                                        time: removed.removed_at,
                                        streamName: removed.stream_name || removed.stream_id || 'Unknown Stream',
                                        streamId: removed.stream_id || null,
                                        isRemoved: true
                                    });
                                }
                            });
                        }
                    }
                } catch (err) {
                    // Log error but don't block - allow other data to load
                    console.warn('[Activity] Fetch error:', err);
                }
            }

            // Placeholder for reports (requires hub events)
            // items.push({ label: 'New Report Run', time: new Date().toISOString() });

            // Render
            listEl.innerHTML = '';
            if (items.length === 0) {
                listEl.innerHTML = '<li class="vl-activity-empty">No recent activity.</li>';
                return;
            }
            // Sort newest first
            items.sort((a, b) => Date.parse(b.time) - Date.parse(a.time));
            for (const it of items.slice(0, 10)) {
                const when = new Date(it.time);
                const pretty = isNaN(when.getTime()) ? '' : when.toLocaleString();
                const li = document.createElement('li');
                li.className = 'vl-activity-item';
                
                // Create structure: date/time above, activity label below
                if (pretty) {
                    const timeSpan = document.createElement('span');
                    timeSpan.id = 'activityTimeStamp';
                    timeSpan.textContent = pretty;
                    li.appendChild(timeSpan);
                    li.appendChild(document.createElement('br'));
                }
                
                // Build the label - just use the label text
                const labelText = it.label;
                
                // Create text node for the base label
                const labelTextNode = document.createTextNode(labelText);
                li.appendChild(labelTextNode);
                
                // If stream name exists, add a line break and then the stream name
                if (it.streamName) {
                    // Add line break
                    li.appendChild(document.createElement('br'));
                    
                    // If stream has an ID, make it clickable
                    if (it.streamId) {
                        const streamLink = document.createElement('a');
                        streamLink.href = `#stream-${it.streamId}`;
                        streamLink.textContent = it.streamName;
                        streamLink.addEventListener('click', (e) => {
                            e.preventDefault();
                            // Navigate to data stream page with proper URL structure
                            const streamUrl = buildStreamDataUrl(licenseKey, it.streamData || it);
                            window.location.href = streamUrl;
                        });
                        li.appendChild(streamLink);
                    } else {
                        // If stream name exists but no ID, just show it as text
                        const streamNameText = document.createTextNode(it.streamName);
                        li.appendChild(streamNameText);
                    }
                }
                
                listEl.appendChild(li);
            }
        }

        // Setup client dropdown functionality - simplified and more reliable
        function setupClientDropdown() {
            console.log('Setting up client dropdown...');
            
            // Get elements
            const dropdownArrow = document.getElementById('clientDropdownArrow');
            const dropdownLightbox = document.getElementById('clientDropdownLightbox');
            const dropdownContent = document.getElementById('clientDropdownContent');
            const launchTutorial = document.getElementById('launchTutorial');
            const accountSettings = document.getElementById('accountSettings');
            const logoutOption = document.getElementById('logoutOption');
            const logoutModal = document.getElementById('logoutModal');
            const logoutCancel = document.getElementById('logoutCancel');
            const logoutConfirm = document.getElementById('logoutConfirm');
            
            console.log('Dropdown elements:', {
                arrow: !!dropdownArrow,
                lightbox: !!dropdownLightbox,
                content: !!dropdownContent,
                accountSettings: !!accountSettings,
                logoutOption: !!logoutOption,
                logoutModal: !!logoutModal
            });

            if (!dropdownArrow || !dropdownLightbox || !dropdownContent) {
                console.error('Dropdown elements not found!');
                return;
            }

            // Prevent double-initialization
            if (dropdownLightbox.dataset.initialized === 'true') {
                console.log('Client dropdown already initialized, skipping re-init');
                return;
            }
            dropdownLightbox.dataset.initialized = 'true';

            // Make arrow clickable
            dropdownArrow.style.cursor = 'pointer';
            dropdownArrow.style.userSelect = 'none';
            dropdownArrow.style.pointerEvents = 'auto';
            dropdownArrow.style.position = 'relative';
            dropdownArrow.style.zIndex = '10001';
            
            // Position dropdown content near the arrow
            function positionDropdown() {
                const arrowRect = dropdownArrow.getBoundingClientRect();
                dropdownContent.style.top = (60) + 'px';
                dropdownContent.style.right = (20) + 'px';
            }

            // Toggle dropdown
            function toggleDropdown() {
                console.log('toggleDropdown called');
                const isVisible = dropdownLightbox.style.display === 'block';
                
                if (isVisible) {
                    dropdownLightbox.style.display = 'none';
                    dropdownLightbox.style.pointerEvents = 'none';
                    console.log('Hiding dropdown');
                } else {
                    positionDropdown();
                    dropdownLightbox.style.display = 'block';
                    dropdownLightbox.style.pointerEvents = 'auto';
                    console.log('Showing dropdown');
                }
            }

            // Close dropdown
            function closeDropdown() {
                dropdownLightbox.style.display = 'none';
                dropdownLightbox.style.pointerEvents = 'none';
            }

            // Show logout modal
            function showLogoutModal() {
                console.log('Showing logout modal');
                logoutModal.style.display = 'block';
            }

            // Hide logout modal
            function hideLogoutModal() {
                logoutModal.style.display = 'none';
            }

            // Perform logout
            function performLogout() {
                console.log('Performing logout...');
                localStorage.removeItem('vl-cms-data');
                localStorage.removeItem('vl-supercluster-tutorial-completed');
                sessionStorage.clear();
                if (inactivityTimeout) clearTimeout(inactivityTimeout);
                window.location.href = LOGIN_PAGE_URL;
            }

            // Direct onclick handler on arrow - most reliable
            dropdownArrow.addEventListener('click', function(e) {
                console.log('Dropdown arrow clicked');
                e.preventDefault();
                    e.stopPropagation();
                    toggleDropdown();
                return false;
            }, true); // Use capture phase to ensure it fires
            
            // Also add to image if it exists
            const arrowImage = dropdownArrow.querySelector('img');
            if (arrowImage) {
                arrowImage.style.pointerEvents = 'auto';
                arrowImage.style.cursor = 'pointer';
                arrowImage.addEventListener('click', function(e) {
                    console.log('Arrow image clicked');
                    e.preventDefault();
                    e.stopPropagation();
                    toggleDropdown();
                    return false;
                }, true); // Use capture phase
            }
            
            // Also handle clicks on the span itself (not just the image)
            dropdownArrow.style.pointerEvents = 'auto';

            // Close when clicking outside the dropdown content
            dropdownLightbox.addEventListener('click', function(e) {
                // If click is directly on the lightbox background (outside content), close
                if (!dropdownContent.contains(e.target)) {
                    console.log('Clicked outside dropdown content, closing dropdown');
                    closeDropdown();
                }
            });

            // Prevent clicks inside the dropdown content from bubbling to the lightbox
            dropdownContent.addEventListener('click', function(e) {
                e.stopPropagation();
            });

            // Close on Escape key
            document.addEventListener('keydown', function onKeyDown(e) {
                if (e.key === 'Escape' || e.key === 'Esc') {
                    if (dropdownLightbox.style.display === 'block') {
                        console.log('Escape pressed, closing dropdown');
                        closeDropdown();
                    }
                }
            });

            // Launch Tutorial click - force launch tutorial even if previously run
            if (launchTutorial) {
                launchTutorial.onclick = async function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    closeDropdown();
                    
                    // Launch tutorial (now inline, no external file needed)
                    if (typeof window.showTutorial === 'function') {
                        // Clear tutorial completion flag to allow re-showing
                        localStorage.removeItem('vl-supercluster-tutorial-completed');
                        try {
                            window.showTutorial();
                        } catch (e) {
                            console.error('Error calling showTutorial:', e);
                            if (typeof window.showVLNotification === 'function') {
                                window.showVLNotification('Error launching tutorial. Please try again.', 'error');
                            }
                        }
                    } else {
                        console.error('showTutorial function not available.');
                        if (typeof window.showVLNotification === 'function') {
                            window.showVLNotification('Tutorial not initialized. Please refresh the page.', 'error');
                        }
                    }
                };
            }

            // Account Settings click
            if (accountSettings) {
                accountSettings.onclick = function(e) {
                    e.preventDefault();
                    closeDropdown();
                };
            }

            // Logout option click
            if (logoutOption) {
                logoutOption.onclick = function(e) {
                    console.log('Logout option clicked');
                    e.preventDefault();
                    e.stopPropagation();
                    closeDropdown();
                    showLogoutModal();
                };
            }

            // Logout modal buttons
            if (logoutCancel) {
                logoutCancel.onclick = hideLogoutModal;
            }

            if (logoutConfirm) {
                logoutConfirm.onclick = performLogout;
            }

            // Close dropdown when clicking outside
            document.addEventListener('click', function(e) {
                const target = e.target;
                const lightbox = document.getElementById('clientDropdownLightbox');
                const arrow = document.getElementById('clientDropdownArrow');
                const modal = document.getElementById('logoutModal');
                
                // Check if click is on arrow or its children (including the image)
                const isArrowClick = arrow && (arrow === target || arrow.contains(target));
                
                if (lightbox && lightbox.style.display === 'block') {
                    if (!lightbox.contains(target) && 
                        !isArrowClick && 
                        (!modal || !modal.contains(target))) {
                    closeDropdown();
                    }
                }
            }, false); // Use bubble phase so arrow click handler fires first

            // Update position on resize
            window.addEventListener('resize', positionDropdown);
        }

        // Tutorial system - Fixed center popup with sliding images
        (function initTutorialSystem() {
            let currentStep = 0;
            let tutorialActive = false;
            
            // Tutorial steps with images and content
            const tutorialSteps = [
                {
                    image: 'https://visiblelight.ai/wp-content/uploads/2025/10/visible-light-icon-logo.svg',
                    title: 'Welcome to Supercluster',
                    content: 'Explore your data universe with the Supercluster dashboard. Navigate through galaxies of information and insights.'
                },
                {
                    image: 'https://visiblelight.ai/wp-content/uploads/2025/11/luna-ai-composer-icon-1.svg',
                    title: 'AI Composer',
                    content: 'Create and edit content with AI assistance. Use the AI Composer to generate, refine, and optimize your content.'
                },
                {
                    image: 'https://visiblelight.ai/wp-content/uploads/2025/10/supercluster-reporting-icon.svg',
                    title: 'AI Reports',
                    content: 'Get intelligent insights and reports about your data. Analyze trends, performance, and key metrics.'
                },
                {
                    image: 'https://visiblelight.ai/wp-content/uploads/2025/10/supercluster-loader.svg',
                    title: 'Automations',
                    content: 'Automate workflows and processes. Set up automations to streamline your operations and save time.'
                },
                {
                    image: 'https://visiblelight.ai/wp-content/uploads/2025/11/cloudops-icon.svg',
                    title: 'Connections',
                    content: 'Manage your integrations and connections. Connect your tools and services for seamless data flow.'
                }
            ];
            
            // Create tutorial HTML structure
            function createTutorialHTML() {
                const container = document.getElementById('tutorial-container');
                if (!container) return;
                
                container.innerHTML = `
                    <div id="tutorial-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); z-index: 20000; align-items: center; justify-content: center;">
                        <div id="tutorial-popup" style="position: relative; background: #000000; border: 1px solid #2E2C2A; border-radius: 12px; max-width: 600px; width: 90%; max-height: 90vh; overflow: hidden; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);">
                            <!-- Image carousel container -->
                            <div id="tutorial-image-container" style="position: relative; width: 100%; height: 300px; background: #1f1d1a; overflow: hidden;">
                                <div id="tutorial-image-slider" style="display: flex; width: ${tutorialSteps.length * 100}%; height: 100%; transition: transform 0.4s ease-in-out;">
                                    ${tutorialSteps.map((step, index) => `
                                        <div class="tutorial-image-slide" style="width: ${100 / tutorialSteps.length}%; height: 100%; display: flex; align-items: center; justify-content: center; padding: 40px;">
                                            <img src="${step.image}" alt="${step.title}" style="max-width: 100%; max-height: 100%; object-fit: contain; filter: brightness(0) invert(1); opacity: 0.9;">
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                            
                            <!-- Content area -->
                            <div style="padding: 32px;">
                                <h2 id="tutorial-title" style="color: #fff4e9; font-size: 1.5rem; font-weight: 600; margin: 0 0 16px 0;">${tutorialSteps[0].title}</h2>
                                <p id="tutorial-content" style="color: #9A9793; font-size: 1rem; line-height: 1.6; margin: 0 0 32px 0;">${tutorialSteps[0].content}</p>
                                
                                <!-- Progress dots -->
                                <div id="tutorial-dots" style="display: flex; justify-content: center; gap: 8px; margin-bottom: 32px;">
                                    ${tutorialSteps.map((_, index) => `
                                        <div class="tutorial-dot" data-step="${index}" style="width: 8px; height: 8px; border-radius: 50%; background: ${index === 0 ? '#fff4e9' : '#5A5753'}; cursor: pointer; transition: background 0.3s ease;"></div>
                                    `).join('')}
                                </div>
                                
                                <!-- Navigation buttons -->
                                <div style="display: flex; justify-content: space-between; align-items: center; gap: 16px;">
                                    <button id="tutorial-back" style="display: none; background: #2E2C2A50; border: 1px solid #5A575335; color: #fff4e9; padding: 12px 24px; border-radius: 6px; cursor: pointer; font-size: 0.875rem; font-weight: 500; transition: all 0.2s ease;" onmouseover="this.style.background='#2E2C2A'; this.style.borderColor='#5A5753';" onmouseout="this.style.background='#2E2C2A50'; this.style.borderColor='#5A575335';">Back</button>
                                    <div style="flex: 1;"></div>
                                    <button id="tutorial-next" style="background: linear-gradient(270deg, #974C00 0%, #8D8C00 100%); border: none; color: #000; padding: 12px 24px; border-radius: 6px; cursor: pointer; font-size: 0.875rem; font-weight: 500; transition: all 0.2s ease;">Continue</button>
                                    <button id="tutorial-close" style="display: none; background: transparent; border: 1px solid #5A575335; color: #9A9793; padding: 12px 24px; border-radius: 6px; cursor: pointer; font-size: 0.875rem; font-weight: 500; transition: all 0.2s ease;" onmouseover="this.style.color='#fff4e9'; this.style.borderColor='#5A5753';" onmouseout="this.style.color='#9A9793'; this.style.borderColor='#5A575335';">Close</button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // Update tutorial step
            function updateTutorialStep(step) {
                currentStep = step;
                const stepData = tutorialSteps[step];
                
                // Update image slider position
                const slider = document.getElementById('tutorial-image-slider');
                if (slider) {
                    slider.style.transform = `translateX(-${step * (100 / tutorialSteps.length)}%)`;
                }
                
                // Update content
                const title = document.getElementById('tutorial-title');
                const content = document.getElementById('tutorial-content');
                if (title) title.textContent = stepData.title;
                if (content) content.textContent = stepData.content;
                
                // Update progress dots
                const dots = document.querySelectorAll('.tutorial-dot');
                dots.forEach((dot, index) => {
                    dot.style.background = index === step ? '#fff4e9' : '#5A5753';
                });
                
                // Update navigation buttons
                const backBtn = document.getElementById('tutorial-back');
                const nextBtn = document.getElementById('tutorial-next');
                const closeBtn = document.getElementById('tutorial-close');
                
                if (backBtn) {
                    backBtn.style.display = step > 0 ? 'block' : 'none';
                }
                if (nextBtn) {
                    nextBtn.style.display = step < tutorialSteps.length - 1 ? 'block' : 'none';
                    nextBtn.textContent = step === tutorialSteps.length - 1 ? 'Finish' : 'Continue';
                }
                if (closeBtn) {
                    closeBtn.style.display = step === tutorialSteps.length - 1 ? 'block' : 'none';
                }
            }
            
            // Show tutorial
            window.showTutorial = function() {
                if (tutorialActive) return;
                
                tutorialActive = true;
                currentStep = 0;
                
                const overlay = document.getElementById('tutorial-overlay');
                if (overlay) {
                    overlay.style.display = 'flex';
                    updateTutorialStep(0);
                }
            };
            
            // Hide tutorial
            function hideTutorial() {
                tutorialActive = false;
                const overlay = document.getElementById('tutorial-overlay');
                if (overlay) {
                    overlay.style.display = 'none';
                }
                localStorage.setItem('vl-supercluster-tutorial-completed', 'true');
            }
            
            // Initialize tutorial HTML
            createTutorialHTML();
            
            // Setup event listeners
            setTimeout(() => {
                const nextBtn = document.getElementById('tutorial-next');
                const backBtn = document.getElementById('tutorial-back');
                const closeBtn = document.getElementById('tutorial-close');
                const overlay = document.getElementById('tutorial-overlay');
                const dots = document.querySelectorAll('.tutorial-dot');
                
                if (nextBtn) {
                    nextBtn.addEventListener('click', () => {
                        if (currentStep < tutorialSteps.length - 1) {
                            updateTutorialStep(currentStep + 1);
                        } else {
                            hideTutorial();
                        }
                    });
                }
                
                if (backBtn) {
                    backBtn.addEventListener('click', () => {
                        if (currentStep > 0) {
                            updateTutorialStep(currentStep - 1);
                        }
                    });
                }
                
                if (closeBtn) {
                    closeBtn.addEventListener('click', hideTutorial);
                }
                
                // Close on overlay click (outside popup)
                if (overlay) {
                    overlay.addEventListener('click', (e) => {
                        if (e.target === overlay) {
                            hideTutorial();
                        }
                    });
                }
                
                // Dot navigation
                dots.forEach((dot, index) => {
                    dot.addEventListener('click', () => {
                        updateTutorialStep(index);
                    });
                });
                
                // Close on Escape key
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && tutorialActive) {
                        hideTutorial();
                    }
                });
            }, 100);
        })();

        // Setup control buttons
        function setupControlButtons() {
            // Left/Right controls
            const controlLeft = document.getElementById('controlLeft');
            const controlRight = document.getElementById('controlRight');
            
            if (controlLeft) {
                controlLeft.addEventListener('click', () => {
                    // Move supercluster left
                    if (camera) {
                        camera.position.x -= 2;
                        camera.lookAt(0, 0, 0);
                    }
                });
            }
            
            if (controlRight) {
                controlRight.addEventListener('click', () => {
                    // Move supercluster right
                    if (camera) {
                        camera.position.x += 2;
                        camera.lookAt(0, 0, 0);
                    }
                });
            }

            // Zoom controls
            const controlZoomIn = document.getElementById('controlZoomIn');
            const controlZoomOut = document.getElementById('controlZoomOut');
            
            if (controlZoomIn) {
                controlZoomIn.addEventListener('click', () => {
                    // Zoom in
                    if (camera) {
                        camera.position.multiplyScalar(0.9);
                    }
                });
            }
            
            if (controlZoomOut) {
                controlZoomOut.addEventListener('click', () => {
                    // Zoom out
                    if (camera) {
                        camera.position.multiplyScalar(1.1);
                    }
                });
            }

        }

        // Build stream data URL with proper format
        function buildStreamDataUrl(licenseKey, streamData) {
            const baseUrl = window.location.origin + window.location.pathname;
            const urlParams = new URLSearchParams(window.location.search);
            
            // Check if this is a WordPress stream
            const isWordPressStream = streamData.wp_version || streamData.wp_core_data || streamData.posts_data || streamData.pages_data ||
                                      streamData.plugins_data || streamData.themes_data || streamData.users_data || streamData.wordpress_content ||
                                      streamData.wordpress_users || (streamData.id && streamData.id.includes('wordpress')) ||
                                      (streamData.categories && Array.isArray(streamData.categories) && streamData.categories.includes('cms')) ||
                                      (streamData.name && streamData.name.toLowerCase().includes('wordpress'));
            
            // Determine category from stream categories
            let category = 'competitive'; // default
            if (isWordPressStream) {
                // WordPress streams always go to content category
                category = 'content';
            } else if (streamData.categories && Array.isArray(streamData.categories)) {
                // Map categories to URL segments
                const categoryMap = {
                    'competitive': 'competitive',
                    'search': 'search-intel',
                    'analytics': 'reporting',
                    'marketing': 'marketing-ads',
                    'ecommerce': 'ecommerce',
                    'security': 'security-compliance',
                    'cloudops': 'cloudops',
                    'identity': 'user-identity',
                    'content': 'content',
                    'infrastructure': 'web-infra'
                };
                
                for (const cat of streamData.categories) {
                    if (categoryMap[cat]) {
                        category = categoryMap[cat];
                        break;
                    }
                }
            }
            
            // Determine stream type (e.g., 'competitive-analysis', 'lighthouse-insights', etc.)
            let streamType = 'data-stream';
            if (isWordPressStream) {
                streamType = 'wordpress-data';
            } else if (streamData.id) {
                // Map stream IDs to stream types
                if (streamData.id.includes('competitor_') || streamData.id.includes('competitive')) {
                    streamType = 'competitive-analysis';
                } else if (streamData.id.includes('lighthouse_') || streamData.id.includes('pagespeed')) {
                    streamType = 'lighthouse-insights';
                } else if (streamData.id.includes('aws_s3')) {
                    streamType = 'aws-s3-storage';
                } else if (streamData.id.includes('liquidweb')) {
                    streamType = 'liquid-web-assets';
                } else if (streamData.id.includes('google_search_console')) {
                    streamType = 'google-search-console';
                        } else {
                    streamType = streamData.id.replace(/[^a-z0-9-]/gi, '-').toLowerCase();
                }
            }
            
            // Get unique identifier
            // CRITICAL: For WordPress streams, NEVER use wp-admin URLs - always use stream ID
            let uniqueId = streamData.id || streamData.streamId || 'unknown';
            
            // Helper function to check if URL is a wp-admin URL
            const isWpAdminUrl = (url) => {
                if (!url || typeof url !== 'string') return false;
                return url.includes('/wp-admin') || url.includes('wp-admin/');
            };
            
            // For competitor analysis, use the competitor URL
            if (streamData.competitor_url && !isWpAdminUrl(streamData.competitor_url)) {
                uniqueId = encodeURIComponent(streamData.competitor_url);
            } else if (streamData.source_url && !isWpAdminUrl(streamData.source_url)) {
                uniqueId = encodeURIComponent(streamData.source_url);
            } else if (streamData.url && !isWpAdminUrl(streamData.url) && !isWordPressStream) {
                // Only use streamData.url if it's NOT a wp-admin URL and NOT a WordPress stream
                // WordPress streams should always use their ID, not a URL
                uniqueId = encodeURIComponent(streamData.url);
            } else {
                // Always use stream ID for WordPress streams or if URL is wp-admin
                uniqueId = encodeURIComponent(uniqueId);
            }
            
            // Build URL: ?license=XXX/category/data-stream/stream-type/unique-id
            const pathSegments = `${category}/data-stream/${streamType}/${uniqueId}`;
            return `${baseUrl}?license=${encodeURIComponent(licenseKey)}/${pathSegments}`;
        }

        // Check for category-level page URL (e.g., ?license=XXX/website-infrastructure-performance/)
        function checkUrlForCategoryPage() {
            const urlParams = new URLSearchParams(window.location.search);
            const licenseParam = urlParams.get('license');
            
            if (!licenseParam) return false;
            
            // Skip if this is the connections page
            if (licenseParam.includes('/connections/') || licenseParam.includes('/connections')) {
                return false;
            }
            
            // Check if URL contains category path: license=XXX/category-slug/
            // Pattern: license key followed by /category-slug/ (ends with /)
            const categoryMatch = licenseParam.match(/^([^/]+)\/([^/]+)\/?$/);
            if (!categoryMatch) {
                return false;
            }
            
            const [, extractedLicense, categorySlug] = categoryMatch;
            
            // Verify license matches authenticated user
            if (extractedLicense !== licenseKey) {
                console.error('License mismatch in URL');
                return false;
            }
            
            // Render the category page
            renderCategoryPage(licenseKey, categorySlug);
            return true;
        }
        
        // Check for stream data page URL and render data stream page
        function checkUrlForStreamDataPage() {
            const urlParams = new URLSearchParams(window.location.search);
            const licenseParam = urlParams.get('license');
            
            if (!licenseParam) return false;
            
            // Check if URL contains data stream path: license=XXX/category/data-stream/stream-type/unique-id
            const pathMatch = licenseParam.match(/^([^/]+)\/([^/]+)\/data-stream\/([^/]+)\/(.+)$/);
            if (!pathMatch) {
                // Old format: ?license=XXX&stream=YYY
                const streamId = urlParams.get('stream');
                if (streamId && licenseKey) {
                    // Legacy support - redirect to new format
                    return false;
                }
                return false;
            }
            
            const [, extractedLicense, category, streamType, uniqueId] = pathMatch;
            
            // Verify license matches authenticated user
            if (extractedLicense !== licenseKey) {
                console.error('License mismatch in URL');
                return false;
            }
            
            // Render the data stream page
            renderStreamDataPage(licenseKey, category, streamType, decodeURIComponent(uniqueId));
            return true;
        }
        
        // Render category page - shows all streams/data for a category
        async function renderCategoryPage(licenseKey, categorySlug) {
            console.log('Rendering category page:', { licenseKey, categorySlug });
            
            // Hide only the Three.js canvas, keep container visible
            hideThreeJSCanvas();
            // Hide labels on internal pages
            hideSuperclusterLabels();
            
            // Show the page content container
            const pageContent = document.getElementById('vlPageContent');
            if (pageContent) {
                pageContent.style.display = 'block';
            }
            
            // Ensure overlays and menus remain visible (same as initialization)
            const overlay = document.querySelector('.vl-supercluster-overlay');
            const header = document.querySelector('.vl-header');
            const mainMenu = document.querySelector('.vl-main-menu');
            const rightSidebar = document.querySelector('.vl-right-sidebar');
            
            if (overlay) {
                overlay.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
            }
            if (header) {
                header.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
            }
            if (mainMenu) {
                mainMenu.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
            }
            if (rightSidebar) {
                rightSidebar.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
            }
            
            // Map category slug to galaxy name
            const slugToGalaxyMap = {
                'website-infrastructure-performance': 'Website Infrastructure & Performance',
                'content-management-structure': 'Content Management & Structure',
                'search-engine-intelligence': 'Search Engine Intelligence',
                'analytics-engagement': 'Analytics & Engagement',
                'marketing-campaign-data': 'Marketing & Campaign Data',
                'e-commerce-conversion-data': 'E-Commerce & Conversion Data',
                'security-compliance-data': 'Security & Compliance Data',
                'cloudops-infrastructure-metrics': 'CloudOps & Infrastructure Metrics',
                'user-identity-layer': 'User & Identity Layer',
                'competitive-market-data': 'Competitive & Market Data'
            };
            
            const galaxyName = slugToGalaxyMap[categorySlug] || categorySlug;
            
            // Find the galaxy data
            const galaxy = galaxyData.find(g => g.name === galaxyName);
            if (!galaxy) {
                document.body.innerHTML = '<div><h1>Category Not Found</h1><p>Unable to find category: ' + categorySlug + '</p></div>';
                return;
            }
            
            // Fetch all streams for this category
            try {
                const connectionsResponse = await fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/all-connections?license=${encodeURIComponent(licenseKey)}`, {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include'
                });
                
                if (!connectionsResponse.ok) {
                    throw new Error('Failed to fetch connections data');
                }
                
                const connectionsResponseData = await connectionsResponse.json();
                // all-connections returns {ok: true, data: {...}} structure
                const connectionsData = connectionsResponseData?.ok && connectionsResponseData?.data ? connectionsResponseData.data : connectionsResponseData;
                // all-connections returns client_streams in the data object
                const streams = connectionsData && connectionsData.client_streams ? connectionsData.client_streams : {};
                const streamArray = extractActiveStreams(streams);
                
                // Filter streams by category (match datasetSlugs)
                const categoryStreams = streamArray.filter(s => {
                    if (!s.categories || !Array.isArray(s.categories)) return false;
                    // Check if any stream category matches any galaxy dataset slug
                    return s.categories.some(cat => 
                        galaxy.datasetSlugs.some(slug => 
                            cat.toLowerCase().includes(slug.toLowerCase()) || 
                            slug.toLowerCase().includes(cat.toLowerCase())
                        )
                    );
                });
                
                // Build HTML
                let html = '<div class="category-page-content">';
                html += '<h1>' + galaxyName + '</h1>';
                html += '<p>' + (galaxy.description || galaxy.fallbackDescription || '') + '</p>';
                
                if (categoryStreams.length === 0) {
                    html += '<p>No data streams found for this category.</p>';
                } else {
                    html += '<h2>Data Streams (' + categoryStreams.length + ')</h2>';
                    html += '<div class="streams-grid">';
                    
                    categoryStreams.forEach(stream => {
                        html += '<div class="stream-card">';
                        html += '<h3>' + (stream.name || 'Unnamed Stream') + '</h3>';
                        html += '<div><strong>Stream ID:</strong> ' + (stream.id || 'N/A') + '</div>';
                        html += '<div><strong>Health Score:</strong> ' + (stream.health_score || 'N/A') + '</div>';
                        html += '<div><strong>Status:</strong> ' + (stream.status || 'N/A') + '</div>';
                        if (stream.last_updated) {
                            html += '<div><strong>Last Updated:</strong> ' + stream.last_updated + '</div>';
                        }
                        // Add link to view stream details
                        const streamUrl = buildStreamDataUrl(licenseKey, stream);
                        html += '<div class="stream-link"><a href="' + streamUrl + '">View Stream Details</a></div>';
                        html += '</div>';
                    });
                    
                    html += '</div>';
                }
                
                html += '</div>';
                
                // Insert content into page content container (preserving overlay)
                const pageContent = document.getElementById('vlPageContent');
                if (pageContent) {
                    pageContent.innerHTML = html;
            } else {
                    console.error('Page content container not found');
                }
            } catch (error) {
                console.error('Error rendering category page:', error);
                const pageContent = document.getElementById('vlPageContent');
                if (pageContent) {
                    pageContent.innerHTML = '<div class="error-content"><h1>Error</h1><p>Failed to load category data: ' + error.message + '</p></div>';
                }
            }
        }

        // Render stream data page - replaces Supercluster visualization with data stream view
        async function renderStreamDataPage(licenseKey, category, streamType, uniqueId) {
            console.log('Rendering stream data page:', { licenseKey, category, streamType, uniqueId });
            
            // Hide only the Three.js canvas, keep container visible
            hideThreeJSCanvas();
            // Hide labels on internal pages
            hideSuperclusterLabels();
            
            // Show the page content container
            const pageContent = document.getElementById('vlPageContent');
            if (pageContent) {
                pageContent.style.display = 'block';
            }
            
            // Ensure body has black background
            document.body.style.backgroundColor = '#000000';
            
            // Ensure overlays and menus remain visible (same as initialization)
            const overlay = document.querySelector('.vl-supercluster-overlay');
            const header = document.querySelector('.vl-header');
            const mainMenu = document.querySelector('.vl-main-menu');
            const rightSidebar = document.querySelector('.vl-right-sidebar');
            
            if (overlay) {
                overlay.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
            }
            if (header) {
                header.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
            }
            if (mainMenu) {
                mainMenu.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
            }
            if (rightSidebar) {
                rightSidebar.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
            }
            
            // Fetch stream data from VL Hub
            // Try /content endpoint first for WordPress data, then fallback to /all-connections
            try {
                let streams = {};
                let connectionsData = {};
                let contentData = null;

                const mergeWordPressData = (target, source) => {
                    if (!target || !source || typeof source !== 'object') return;

                    const candidates = [
                        source,
                        source.data,
                        source.wordpress_content,
                        source.data && source.data.wordpress_content
                    ].filter(Boolean);

                    const coerceArray = (value) => Array.isArray(value) ? value : [];

                    const mergeList = (key, list) => {
                        if (Array.isArray(list) && list.length > 0 && (!target[key] || target[key].length === 0)) {
                            target[key] = list;
                        }
                    };

                    candidates.forEach(candidate => {
                        mergeList('posts_data', coerceArray(candidate.posts_data || candidate.posts || candidate.wordpress_posts || (candidate.content && candidate.content.posts)));
                        mergeList('pages_data', coerceArray(candidate.pages_data || candidate.pages || candidate.wordpress_pages || (candidate.content && candidate.content.pages)));
                        mergeList('plugins_data', coerceArray(candidate.plugins_data || candidate.plugins));
                        mergeList('themes_data', coerceArray(candidate.themes_data || candidate.themes));
                        mergeList('users_data', coerceArray(candidate.users_data || candidate.users || candidate.wordpress_users));
                        mergeList('comments_data', coerceArray(candidate.comments_data || candidate.comments));

                        if (!target.wp_core_data && candidate.wp_core_data && typeof candidate.wp_core_data === 'object') {
                            target.wp_core_data = candidate.wp_core_data;
                        }

                        const totals = [
                            ['posts_total', 'total_posts', candidate.posts_total],
                            ['pages_total', 'total_pages', candidate.pages_total],
                            ['users_total', 'total_users', candidate.users_total],
                            ['comments_total', 'total_comments', candidate.comments_total],
                            ['plugins_total', 'total_plugins', candidate.plugins_total],
                            ['plugins_active', 'active_plugins', candidate.plugins_active],
                            ['plugins_needing_update', 'plugins_needing_update', candidate.plugins_needing_update],
                            ['themes_total', 'total_themes', candidate.themes_total],
                            ['themes_needing_update', 'themes_needing_update', candidate.themes_needing_update]
                        ];

                        totals.forEach(([targetKey, altKey, directValue]) => {
                            if (target[targetKey] === undefined) {
                                if (directValue !== undefined) {
                                    target[targetKey] = directValue;
                                } else if (candidate[altKey] !== undefined) {
                                    target[targetKey] = candidate[altKey];
                                }
                            }
                        });
                    });

                    if (target.posts_total === undefined && target.posts_data && target.posts_data.length) {
                        target.posts_total = target.posts_data.length;
                    }
                    if (target.pages_total === undefined && target.pages_data && target.pages_data.length) {
                        target.pages_total = target.pages_data.length;
                    }
                    if (target.users_total === undefined && target.users_data && target.users_data.length) {
                        target.users_total = target.users_data.length;
                    }
                    if (target.plugins_total === undefined && target.plugins_data && target.plugins_data.length) {
                        target.plugins_total = target.plugins_data.length;
                    }
                    if (target.themes_total === undefined && target.themes_data && target.themes_data.length) {
                        target.themes_total = target.themes_data.length;
                    }
                };
                
                // Fetch from both endpoints in parallel for better performance
                console.log('[Stream Data] Fetching from both endpoints in parallel...');
                const [contentResponse, connectionsResponse] = await Promise.allSettled([
                    fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/content?license=${encodeURIComponent(licenseKey)}`, {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include'
                    }),
                    fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/all-connections?license=${encodeURIComponent(licenseKey)}`, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include'
                    })
                ]);
                
                // Process /content endpoint response
                if (contentResponse.status === 'fulfilled' && contentResponse.value.ok) {
                    try {
                        const contentResponseData = await contentResponse.value.json();
                        contentData = contentResponseData?.ok && contentResponseData?.data ? contentResponseData.data : contentResponseData;
                        console.log('[Stream Data] /content endpoint response received');
                        
                        if (contentData && typeof contentData === 'object') {
                            if (contentData.client_streams) {
                                streams = contentData.client_streams;
                                connectionsData = contentData;
                                console.log('[Stream Data] Found client_streams in /content response');
                            } else if (contentData.streams) {
                                streams = contentData.streams;
                                connectionsData = contentData;
                                console.log('[Stream Data] Found streams in /content response');
                        }
                    }
                } catch (contentError) {
                        console.warn('[Stream Data] Could not parse /content endpoint response:', contentError);
                }
                } else if (contentResponse.status === 'rejected') {
                    console.warn('[Stream Data] Could not fetch from /content endpoint:', contentResponse.reason);
                }
                
                // Process /all-connections endpoint response
                if (connectionsResponse.status === 'fulfilled' && connectionsResponse.value.ok) {
                    try {
                        const connectionsResponseData = await connectionsResponse.value.json();
                    const allConnectionsData = connectionsResponseData?.ok && connectionsResponseData?.data ? connectionsResponseData.data : connectionsResponseData;
                    
                    // Merge data from all-connections if we don't have it from content
                    if (!streams || Object.keys(streams).length === 0) {
                        streams = allConnectionsData && allConnectionsData.client_streams ? allConnectionsData.client_streams : {};
                        connectionsData = allConnectionsData;
                        console.log('[Stream Data] Using streams from /all-connections');
                    } else {
                        // Merge streams from both endpoints
                        const allConnectionsStreams = allConnectionsData && allConnectionsData.client_streams ? allConnectionsData.client_streams : {};
                        if (allConnectionsStreams && typeof allConnectionsStreams === 'object') {
                            // Merge streams, preferring content endpoint data
                            for (const key in allConnectionsStreams) {
                                if (!streams[key]) {
                                    streams[key] = allConnectionsStreams[key];
                                }
                            }
                            console.log('[Stream Data] Merged streams from both endpoints');
                        }
                        connectionsData = allConnectionsData;
                    }
                    } catch (connectionsError) {
                        console.warn('[Stream Data] Could not parse /all-connections endpoint response:', connectionsError);
                    }
                } else if (connectionsResponse.status === 'rejected') {
                    console.warn('[Stream Data] Could not fetch from /all-connections endpoint:', connectionsResponse.reason);
                }
                
                // If we still don't have streams, throw an error
                    if (!streams || Object.keys(streams).length === 0) {
                    throw new Error('Failed to fetch stream data from both endpoints');
                }
                
                const streamArray = extractActiveStreams(streams);
                
                // Find the matching stream - prioritize exact matches first
                let stream = null;
                let streamId = null;
                
                console.log('[Stream Data] Searching for stream:', { streamType, uniqueId, totalStreams: streamArray.length });
                
                // FIRST: Try exact ID match (highest priority)
                stream = streamArray.find(s => s.id === uniqueId);
                if (stream) {
                    console.log('[Stream Data] Found stream by exact ID match:', stream.id);
                }
                
                // SECOND: For SOC2 streams, match by exact ID or stream_type
                if (!stream && (streamType === 'soc2-report' || uniqueId.includes('soc2-report'))) {
                    stream = streamArray.find(s => 
                        s.id === uniqueId || // Exact ID match
                        (s.id && s.id.startsWith('soc2-report') && uniqueId.includes(s.id)) || // Partial ID match
                        (s.stream_type === 'soc2-report' && s.id && uniqueId.includes(s.id)) || // Stream type + ID
                        (s.report_type === 'soc2-type-ii' && s.id && uniqueId.includes(s.id)) // Report type + ID
                    );
                    if (stream) {
                        console.log('[Stream Data] Found SOC2 stream:', stream.id, stream.stream_type);
                    }
                }
                
                // THIRD: For WCAG streams, match by exact ID or stream_type
                if (!stream && (streamType === 'wcag-audit-report' || uniqueId.includes('wcag-audit'))) {
                    stream = streamArray.find(s => 
                        s.id === uniqueId || // Exact ID match
                        (s.id && s.id.startsWith('wcag-audit') && uniqueId.includes(s.id)) || // Partial ID match
                        (s.stream_type === 'wcag-audit-report' && s.id && uniqueId.includes(s.id)) || // Stream type + ID
                        (s.report_type === 'wcag' && s.id && uniqueId.includes(s.id)) // Report type + ID
                    );
                    if (stream) {
                        console.log('[Stream Data] Found WCAG stream:', stream.id, stream.stream_type);
                    }
                }
                
                // FOURTH: For competitor analysis, find by competitor_url, source_url, or name
                if (!stream && streamType === 'competitive-analysis') {
                    stream = streamArray.find(s => {
                        // Check if stream name contains the competitor URL
                        if (s.name && s.name.includes(uniqueId)) {
                            return true;
                        }
                        // Check various URL fields
                        if (s.competitor_url === uniqueId || 
                            s.source_url === uniqueId || 
                            s.url === uniqueId) {
                            return true;
                        }
                        // Check report_data
                        if (s.report_data && (
                            s.report_data.competitor_url === uniqueId ||
                            s.report_data.url === uniqueId
                        )) {
                            return true;
                        }
                        // Check if stream ID contains competitor URL
                        if (s.id && s.id.includes(uniqueId.replace(/[^a-zA-Z0-9]/g, '_'))) {
                            return true;
                        }
                        return false;
                    });
                    if (stream) {
                        console.log('[Stream Data] Found competitor stream:', stream.id);
                    }
                }
                
                // FIFTH: For other streams, find by ID or URL (but exclude WordPress streams if not looking for WordPress)
                if (!stream) {
                    const isWordPressStreamType = streamType === 'wordpress-data' || streamType === 'wp-data';
                    stream = streamArray.find(s => {
                        // Skip WordPress streams if we're not looking for WordPress
                        if (!isWordPressStreamType && (s.wp_version || s.wp_core_data || s.posts_data || 
                            (s.id && s.id.includes('wordpress')) || (s.id && s.id.includes('vl-las_')))) {
                            return false;
                        }
                        return s.id === uniqueId || 
                        s.source_url === uniqueId || 
                        s.url === uniqueId ||
                        s.competitor_url === uniqueId ||
                               (s.name && s.name.includes(uniqueId));
                    });
                    if (stream) {
                        console.log('[Stream Data] Found stream by ID/URL match:', stream.id);
                }
                }
                
                // SIXTH: Try to find by stream ID pattern (but exclude WordPress streams if not looking for WordPress)
                if (!stream) {
                    const streamIdPattern = streamType.replace(/-/g, '_');
                    const isWordPressStreamType = streamType === 'wordpress-data' || streamType === 'wp-data';
                    stream = streamArray.find(s => {
                        // Skip WordPress streams if we're not looking for WordPress
                        if (!isWordPressStreamType && (s.wp_version || s.wp_core_data || s.posts_data || 
                            (s.id && s.id.includes('wordpress')) || (s.id && s.id.includes('vl-las_')))) {
                            return false;
                        }
                        return s.id && s.id.includes(streamIdPattern);
                    });
                    if (stream) {
                        console.log('[Stream Data] Found stream by pattern match:', stream.id);
                    }
                }
                
                // LAST RESORT: If still not found and it's a competitor analysis, try to find any competitor stream
                if (!stream && streamType === 'competitive-analysis') {
                    stream = streamArray.find(s => 
                        s.id && s.id.includes('competitor') ||
                        (s.categories && s.categories.includes('competitive'))
                    );
                }
                
                if (!stream) {
                    const pageContent = document.getElementById('vlPageContent');
                    if (pageContent) {
                        pageContent.innerHTML = '<div class="error-content"><h1>Stream Data Not Found</h1><p>Unable to find stream data for: ' + uniqueId + '</p></div>';
                    }
                    return;
                }
                
                // Get the stream ID to look up full data in original streams object
                streamId = stream.id;
                
                // CRITICAL: For WordPress streams, get the FULL stream data from the original streams object
                // The extractActiveStreams might have lost nested data, so we need to get it from the original structure
                
                console.log('[Stream Data] === SEARCHING FOR WORDPRESS DATA ===');
                console.log('[Stream Data] Stream ID:', streamId);
                console.log('[Stream Data] Stream name:', stream.name);
                console.log('[Stream Data] Stream type:', streamType);
                console.log('[Stream Data] Current stream.posts_data:', !!stream.posts_data, stream.posts_data?.length);
                console.log('[Stream Data] Current stream.pages_data:', !!stream.pages_data, stream.pages_data?.length);
                console.log('[Stream Data] Current stream.plugins_data:', !!stream.plugins_data, stream.plugins_data?.length);
                console.log('[Stream Data] Current stream.themes_data:', !!stream.themes_data, stream.themes_data?.length);
                console.log('[Stream Data] Current stream.users_data:', !!stream.users_data, stream.users_data?.length);
                console.log('[Stream Data] Streams object type:', typeof streams);
                console.log('[Stream Data] Streams object keys count:', streams && typeof streams === 'object' ? Object.keys(streams).length : 0);
                
                // ALWAYS search for WordPress data in original streams object and merge it
                // This ensures we get ALL the data, not just what's in the extracted stream
                if (streams && typeof streams === 'object' && !Array.isArray(streams)) {
                    console.log('[Stream Data] Data missing, searching in original streams object...');
                    console.log('[Stream Data] streams object type:', typeof streams);
                    console.log('[Stream Data] streams keys:', Object.keys(streams).slice(0, 20));
                    
                    // Search through ALL streams to find WordPress data
                    // Don't rely on ID matching - search by content
                    console.log('[Stream Data] Searching through ALL streams for WordPress data...');
                    let foundWordPressData = false;
                    
                    for (const key in streams) {
                        if (streams.hasOwnProperty(key)) {
                            const candidateStream = streams[key];
                            if (candidateStream && typeof candidateStream === 'object') {
                                // Check if this is a WordPress stream by looking for WordPress-specific data
                                const hasWordPressData = candidateStream.wp_version || 
                                                        candidateStream.posts_data || 
                                                        candidateStream.pages_data || 
                                                        candidateStream.plugins_data || 
                                                        candidateStream.themes_data ||
                                                        candidateStream.users_data ||
                                                        (candidateStream.id && candidateStream.id.includes('wordpress')) ||
                                                        (candidateStream.categories && Array.isArray(candidateStream.categories) && candidateStream.categories.includes('cms')) ||
                                                        (candidateStream.name && candidateStream.name.toLowerCase().includes('wordpress'));
                                
                                if (hasWordPressData) {
                                    console.log('[Stream Data] ✓✓✓ FOUND WORDPRESS STREAM in streams[' + key + ']');
                                    console.log('[Stream Data] Candidate stream ID:', candidateStream.id);
                                    console.log('[Stream Data] Candidate stream name:', candidateStream.name);
                                    console.log('[Stream Data] Candidate stream ALL keys:', Object.keys(candidateStream));
                                    console.log('[Stream Data] Candidate has posts_data:', !!candidateStream.posts_data, candidateStream.posts_data?.length);
                                    console.log('[Stream Data] Candidate has pages_data:', !!candidateStream.pages_data, candidateStream.pages_data?.length);
                                    console.log('[Stream Data] Candidate has plugins_data:', !!candidateStream.plugins_data, candidateStream.plugins_data?.length);
                                    console.log('[Stream Data] Candidate has themes_data:', !!candidateStream.themes_data, candidateStream.themes_data?.length);
                                    console.log('[Stream Data] Candidate has users_data:', !!candidateStream.users_data, candidateStream.users_data?.length);
                                    
                                    // Log the full candidate stream structure to see what we're working with
                                    console.log('[Stream Data] Candidate stream FULL object (first 3000 chars):', JSON.stringify(candidateStream, null, 2).substring(0, 3000));
                                    
                                    // Check if data might be in a 'data' property
                                    if (candidateStream.data && typeof candidateStream.data === 'object') {
                                        console.log('[Stream Data] Candidate has .data property with keys:', Object.keys(candidateStream.data));
                                        if (candidateStream.data.posts_data) {
                                            console.log('[Stream Data] Found posts_data in candidateStream.data!');
                                            candidateStream.posts_data = candidateStream.data.posts_data;
                                        }
                                        if (candidateStream.data.pages_data) {
                                            console.log('[Stream Data] Found pages_data in candidateStream.data!');
                                            candidateStream.pages_data = candidateStream.data.pages_data;
                                        }
                                        if (candidateStream.data.plugins_data) {
                                            console.log('[Stream Data] Found plugins_data in candidateStream.data!');
                                            candidateStream.plugins_data = candidateStream.data.plugins_data;
                                        }
                                        if (candidateStream.data.themes_data) {
                                            console.log('[Stream Data] Found themes_data in candidateStream.data!');
                                            candidateStream.themes_data = candidateStream.data.themes_data;
                                        }
                                        if (candidateStream.data.users_data) {
                                            console.log('[Stream Data] Found users_data in candidateStream.data!');
                                            candidateStream.users_data = candidateStream.data.users_data;
                                        }
                                    }
                                    
                                    foundWordPressData = true;
                                    
                                    // FORCE MERGE ALL WordPress data - don't check if it already exists
                                    if (candidateStream.posts_data && Array.isArray(candidateStream.posts_data)) {
                                        stream.posts_data = candidateStream.posts_data;
                                        console.log('[Stream Data] ✓✓✓ FORCE MERGED posts_data:', candidateStream.posts_data.length, 'posts');
                                    }
                                    if (candidateStream.pages_data && Array.isArray(candidateStream.pages_data)) {
                                        stream.pages_data = candidateStream.pages_data;
                                        console.log('[Stream Data] ✓✓✓ FORCE MERGED pages_data:', candidateStream.pages_data.length, 'pages');
                                    }
                                    if (candidateStream.plugins_data && Array.isArray(candidateStream.plugins_data)) {
                                        stream.plugins_data = candidateStream.plugins_data;
                                        console.log('[Stream Data] ✓✓✓ FORCE MERGED plugins_data:', candidateStream.plugins_data.length, 'plugins');
                                    }
                                    if (candidateStream.themes_data && Array.isArray(candidateStream.themes_data)) {
                                        stream.themes_data = candidateStream.themes_data;
                                        console.log('[Stream Data] ✓✓✓ FORCE MERGED themes_data:', candidateStream.themes_data.length, 'themes');
                                    }
                                    if (candidateStream.users_data && Array.isArray(candidateStream.users_data)) {
                                        stream.users_data = candidateStream.users_data;
                                        console.log('[Stream Data] ✓✓✓ FORCE MERGED users_data:', candidateStream.users_data.length, 'users');
                                    }
                                    if (candidateStream.comments_data && Array.isArray(candidateStream.comments_data)) {
                                        stream.comments_data = candidateStream.comments_data;
                                    }
                                    if (candidateStream.wp_core_data && typeof candidateStream.wp_core_data === 'object') {
                                        stream.wp_core_data = candidateStream.wp_core_data;
                                        console.log('[Stream Data] ✓✓✓ MERGED wp_core_data');
                                    }
                                    if (candidateStream.content_metrics && typeof candidateStream.content_metrics === 'object') {
                                        stream.content_metrics = candidateStream.content_metrics;
                                        console.log('[Stream Data] ✓✓✓ MERGED content_metrics');
                                    }
                                    // Merge all other WordPress-specific fields
                                    if (candidateStream.wp_version) stream.wp_version = candidateStream.wp_version;
                                    if (candidateStream.php_version) stream.php_version = candidateStream.php_version;
                                    if (candidateStream.mysql_version) stream.mysql_version = candidateStream.mysql_version;
                                    if (candidateStream.posts_total !== undefined) stream.posts_total = candidateStream.posts_total;
                                    if (candidateStream.pages_total !== undefined) stream.pages_total = candidateStream.pages_total;
                                    if (candidateStream.users_total !== undefined) stream.users_total = candidateStream.users_total;
                                    if (candidateStream.comments_total !== undefined) stream.comments_total = candidateStream.comments_total;
                                    if (candidateStream.plugins_total !== undefined) stream.plugins_total = candidateStream.plugins_total;
                                    if (candidateStream.plugins_active !== undefined) stream.plugins_active = candidateStream.plugins_active;
                                    if (candidateStream.plugins_needing_update !== undefined) stream.plugins_needing_update = candidateStream.plugins_needing_update;
                                    if (candidateStream.themes_total !== undefined) stream.themes_total = candidateStream.themes_total;
                                    if (candidateStream.themes_needing_update !== undefined) stream.themes_needing_update = candidateStream.themes_needing_update;
                                    
                                    // Break after finding first WordPress stream with data
                                    break;
                                }
                            }
                        }
                    }
                    
                    if (!foundWordPressData) {
                        console.warn('[Stream Data] ⚠⚠⚠ NO WORDPRESS DATA FOUND IN STREAMS OBJECT');
                        console.log('[Stream Data] Available stream keys:', Object.keys(streams).slice(0, 10));
                    }
                }
                
                // Final check: Log what we have after all merging
                console.log('[Stream Data] === FINAL CHECK AFTER MERGING ===');
                console.log('[Stream Data] stream.posts_data:', !!stream.posts_data, stream.posts_data?.length);
                console.log('[Stream Data] stream.pages_data:', !!stream.pages_data, stream.pages_data?.length);
                console.log('[Stream Data] stream.plugins_data:', !!stream.plugins_data, stream.plugins_data?.length);
                console.log('[Stream Data] stream.themes_data:', !!stream.themes_data, stream.themes_data?.length);
                console.log('[Stream Data] stream.users_data:', !!stream.users_data, stream.users_data?.length);
                
                // Also check if WordPress data is nested in connectionsData directly (not in client_streams)
                if (connectionsData && typeof connectionsData === 'object') {
                    // Check for WordPress data at the connectionsData level
                    if (connectionsData.posts_data && Array.isArray(connectionsData.posts_data) && !stream.posts_data) {
                        stream.posts_data = connectionsData.posts_data;
                    }
                    if (connectionsData.pages_data && Array.isArray(connectionsData.pages_data) && !stream.pages_data) {
                        stream.pages_data = connectionsData.pages_data;
                    }
                    if (connectionsData.plugins_data && Array.isArray(connectionsData.plugins_data) && !stream.plugins_data) {
                        stream.plugins_data = connectionsData.plugins_data;
                    }
                    if (connectionsData.themes_data && Array.isArray(connectionsData.themes_data) && !stream.themes_data) {
                        stream.themes_data = connectionsData.themes_data;
                    }
                    if (connectionsData.users_data && Array.isArray(connectionsData.users_data) && !stream.users_data) {
                        stream.users_data = connectionsData.users_data;
                    }
                }
                
                // For competitor analysis, also fetch detailed report from database
                if (streamType === 'competitive-analysis' && uniqueId) {
                    try {
                        const reportResponse = await fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/competitor-report?license=${encodeURIComponent(licenseKey)}&competitor_url=${encodeURIComponent(uniqueId)}`, {
                            method: 'GET',
                            headers: { 'Content-Type': 'application/json' },
                            credentials: 'include'
                        });
                        
                        if (reportResponse.ok) {
                            const reportData = await reportResponse.json();
                            if (reportData && reportData.success && reportData.report) {
                                // Merge report data into stream
                                stream.report_data = reportData.report;
                            }
                        }
                    } catch (reportError) {
                        console.warn('Could not fetch detailed competitor report:', reportError);
                        // Continue with stream data anyway
                    }
                }
                
                // Debug: Log what we have in the stream object
                console.log('[Stream Data] Stream object keys:', Object.keys(stream));
                console.log('[Stream Data] Stream ID:', stream.id);
                console.log('[Stream Data] Has posts_data:', !!stream.posts_data, stream.posts_data?.length);
                console.log('[Stream Data] Has pages_data:', !!stream.pages_data, stream.pages_data?.length);
                console.log('[Stream Data] Has plugins_data:', !!stream.plugins_data, stream.plugins_data?.length);
                console.log('[Stream Data] Has themes_data:', !!stream.themes_data, stream.themes_data?.length);
                console.log('[Stream Data] Has users_data:', !!stream.users_data, stream.users_data?.length);
                console.log('[Stream Data] Original streams object keys:', streams && typeof streams === 'object' ? Object.keys(streams) : 'N/A');
                
                // Check if this is a WordPress stream before fetching additional data
                const isWordPressStream = stream.wp_version || stream.wp_core_data || stream.posts_data || stream.pages_data || 
                                          stream.plugins_data || stream.themes_data || stream.users_data ||
                                          (stream.id && stream.id.includes('wordpress')) ||
                                          streamType === 'wordpress-data';
                
                // For WordPress streams, ALWAYS try to fetch detailed data from /content endpoint first, then /all-connections
                // /content endpoint might have better WordPress data structure
                if (isWordPressStream) {
                    try {
                        // Try /content endpoint first
                        console.log('[Stream Data] Fetching additional WordPress data from /content endpoint...');
                        const contentResponse = await fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/content?license=${encodeURIComponent(licenseKey)}`, {
                            method: 'GET',
                            headers: { 'Content-Type': 'application/json' },
                            credentials: 'include'
                        });
                        
                        if (contentResponse.ok) {
                            const contentResponseData = await contentResponse.json();
                            const contentData = contentResponseData?.ok && contentResponseData?.data ? contentResponseData.data : contentResponseData;
                            const contentStreams = contentData && contentData.client_streams ? contentData.client_streams : (contentData && contentData.streams ? contentData.streams : {});
                            
                            console.log('[Stream Data] /content endpoint response received');
                            console.log('[Stream Data] Content streams keys:', Object.keys(contentStreams).slice(0, 10));
                            
                            // Search for WordPress data in /content response
                            if (contentStreams && typeof contentStreams === 'object' && !Array.isArray(contentStreams)) {
                                for (const key in contentStreams) {
                                    if (contentStreams.hasOwnProperty(key)) {
                                        const candidateStream = contentStreams[key];
                                        if (candidateStream && typeof candidateStream === 'object') {
                                            const hasWordPressData = candidateStream.wp_version || 
                                                                    candidateStream.posts_data || 
                                                                    candidateStream.pages_data || 
                                                                    candidateStream.plugins_data || 
                                                                    candidateStream.themes_data ||
                                                                    candidateStream.users_data ||
                                                                    (candidateStream.id && candidateStream.id.includes('wordpress')) ||
                                                                    (candidateStream.categories && Array.isArray(candidateStream.categories) && candidateStream.categories.includes('cms')) ||
                                                                    (candidateStream.name && candidateStream.name.toLowerCase().includes('wordpress'));
                                            
                                            if (hasWordPressData) {
                                                console.log('[Stream Data] ✓✓✓ FOUND WORDPRESS DATA in /content endpoint streams[' + key + ']');
                                                mergeWordPressData(stream, candidateStream);
                                                break;
                                            }
                                            }
                                        }
                                    }
                                }
                            }
                            
                            // Also check if WordPress data is at the root level of /content response
                            if (contentData && typeof contentData === 'object') {
                                mergeWordPressData(stream, contentData);
                            }

                        // Try /data-streams endpoint which might have the full nested data
                        console.log('[Stream Data] Fetching from /data-streams endpoint for full stream data...');
                        try {
                            const dataStreamsResponse = await fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/data-streams?license=${encodeURIComponent(licenseKey)}`, {
                                method: 'GET',
                                headers: { 'Content-Type': 'application/json' },
                                credentials: 'include'
                            });
                            
                            if (dataStreamsResponse.ok) {
                                const dataStreamsData = await dataStreamsResponse.json();
                                const dataStreams = dataStreamsData?.ok && dataStreamsData?.data ? dataStreamsData.data : dataStreamsData;
                                const dataStreamsStreams = dataStreams && dataStreams.client_streams ? dataStreams.client_streams : (dataStreams && dataStreams.streams ? dataStreams.streams : {});
                                
                                console.log('[Stream Data] /data-streams response received');
                                console.log('[Stream Data] Data streams keys:', Object.keys(dataStreamsStreams).slice(0, 10));
                                
                                // Search for WordPress stream in /data-streams
                                if (dataStreamsStreams && typeof dataStreamsStreams === 'object' && !Array.isArray(dataStreamsStreams)) {
                                    for (const key in dataStreamsStreams) {
                                        if (dataStreamsStreams.hasOwnProperty(key)) {
                                            const candidateStream = dataStreamsStreams[key];
                                            if (candidateStream && typeof candidateStream === 'object') {
                                                const isWordPress = candidateStream.wp_version || 
                                                                    candidateStream.posts_data || 
                                                                    candidateStream.pages_data || 
                                                                    candidateStream.plugins_data || 
                                                                    candidateStream.themes_data ||
                                                                    (candidateStream.id && candidateStream.id.includes('wordpress'));
                                                
                                                if (isWordPress) {
                                                    console.log('[Stream Data] ✓✓✓ FOUND WORDPRESS STREAM in /data-streams[' + key + ']');
                                                    mergeWordPressData(stream, candidateStream);
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } catch (dataStreamsError) {
                            console.warn('[Stream Data] Could not fetch from /data-streams endpoint:', dataStreamsError);
                        }
                        
                        // Also try /all-connections as fallback/merge source
                        console.log('[Stream Data] Fetching additional data from /all-connections endpoint...');
                        const allConnectionsResponse = await fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/all-connections?license=${encodeURIComponent(licenseKey)}`, {
                            method: 'GET',
                            headers: { 'Content-Type': 'application/json' },
                            credentials: 'include'
                        });
                        
                        if (allConnectionsResponse.ok) {
                            const allConnectionsData = await allConnectionsResponse.json();
                            // all-connections returns {ok: true, data: {...}} structure
                            const allConnections = allConnectionsData?.ok && allConnectionsData?.data ? allConnectionsData.data : allConnectionsData;
                            const allConnectionsStreams = allConnections && allConnections.client_streams ? allConnections.client_streams : {};
                            
                            console.log('[Stream Data] /all-connections response received');
                            
                            // Try to find WordPress data in all-connections response
                            if (allConnectionsStreams && typeof allConnectionsStreams === 'object' && !Array.isArray(allConnectionsStreams)) {
                                // Search through all streams in all-connections
                                for (const key in allConnectionsStreams) {
                                    if (allConnectionsStreams.hasOwnProperty(key)) {
                                        const candidateStream = allConnectionsStreams[key];
                                        if (candidateStream && typeof candidateStream === 'object') {
                                            // Check if this is a WordPress stream
                                            const isWordPress = candidateStream.wp_version || candidateStream.posts_data || candidateStream.pages_data || 
                                                                candidateStream.plugins_data || candidateStream.themes_data ||
                                                                (candidateStream.id && candidateStream.id.includes('wordpress')) ||
                                                                (candidateStream.categories && Array.isArray(candidateStream.categories) && candidateStream.categories.includes('cms'));
                                            
                                            if (isWordPress) {
                                                console.log('[Stream Data] Found WordPress stream in all-connections[' + key + ']');
                                                console.log('[Stream Data] All-connections candidate ALL keys:', Object.keys(candidateStream));
                                                
                                                // Check if data is nested in a 'data' property
                                                const streamData = candidateStream.data || candidateStream;
                                                console.log('[Stream Data] Checking streamData.posts_data:', !!streamData.posts_data, streamData.posts_data?.length);
                                                
                                                // Check if this matches our stream or is the WordPress stream we need
                                                if (candidateStream.id === stream.id || 
                                                    !stream.id || 
                                                    stream.id.includes('wordpress') ||
                                                    (candidateStream.id && stream.id && candidateStream.id.includes(stream.id)) ||
                                                    (stream.id && candidateStream.id && stream.id.includes(candidateStream.id))) {
                                                    
                                                    mergeWordPressData(stream, streamData);
                                                    break; // Found and merged, exit loop
                                                }
                                            }
                                        }
                                    }
                                }
                                
                                // Also check if WordPress data is at the all-connections level (not in client_streams)
                                if (allConnections && typeof allConnections === 'object') {
                                    mergeWordPressData(stream, allConnections);
                                    if (allConnections.posts_data && Array.isArray(allConnections.posts_data) && !stream.posts_data) {
                                        stream.posts_data = allConnections.posts_data;
                                        console.log('[Stream Data] ✓ Merged posts_data from all-connections root level');
                                    }
                                    if (allConnections.pages_data && Array.isArray(allConnections.pages_data) && !stream.pages_data) {
                                        stream.pages_data = allConnections.pages_data;
                                        console.log('[Stream Data] ✓ Merged pages_data from all-connections root level');
                                    }
                                    if (allConnections.plugins_data && Array.isArray(allConnections.plugins_data) && !stream.plugins_data) {
                                        stream.plugins_data = allConnections.plugins_data;
                                        console.log('[Stream Data] ✓ Merged plugins_data from all-connections root level');
                                    }
                                    if (allConnections.themes_data && Array.isArray(allConnections.themes_data) && !stream.themes_data) {
                                        stream.themes_data = allConnections.themes_data;
                                        console.log('[Stream Data] ✓ Merged themes_data from all-connections root level');
                                    }
                                    if (allConnections.users_data && Array.isArray(allConnections.users_data) && !stream.users_data) {
                                        stream.users_data = allConnections.users_data;
                                        console.log('[Stream Data] ✓ Merged users_data from all-connections root level');
                                    }

                                    if (allConnections.wordpress_content && typeof allConnections.wordpress_content === 'object') {
                                        const wc = allConnections.wordpress_content;
                                        if (wc.posts && Array.isArray(wc.posts) && !stream.posts_data) {
                                            stream.posts_data = wc.posts;
                                            console.log('[Stream Data] ✓ Merged wordpress_content.posts from all-connections');
                                        }
                                        if (wc.pages && Array.isArray(wc.pages) && !stream.pages_data) {
                                            stream.pages_data = wc.pages;
                                            console.log('[Stream Data] ✓ Merged wordpress_content.pages from all-connections');
                                        }
                                        if (wc.total_posts !== undefined && stream.posts_total === undefined) {
                                            stream.posts_total = wc.total_posts;
                                        }
                                        if (wc.total_pages !== undefined && stream.pages_total === undefined) {
                                            stream.pages_total = wc.total_pages;
                                        }
                                        if (wc.total_comments !== undefined && stream.comments_total === undefined) {
                                            stream.comments_total = wc.total_comments;
                                        }
                                    }

                                    if (allConnections.wordpress_users && Array.isArray(allConnections.wordpress_users) && !stream.users_data) {
                                        stream.users_data = allConnections.wordpress_users;
                                        console.log('[Stream Data] ✓ Merged wordpress_users from all-connections');
                                    }
                                }
                            }
                        }
                    } catch (allConnectionsError) {
                        console.warn('Could not fetch detailed data from all-connections endpoint:', allConnectionsError);
                        // Continue with existing stream data
                    }
                }
                
                // Render the data stream page
                renderStreamDataContent(stream, uniqueId, streamType);
                
            } catch (error) {
                console.error('Error rendering stream data page:', error);
                const pageContent = document.getElementById('vlPageContent');
                if (pageContent) {
                    pageContent.innerHTML = '<div class="error-content"><h1>Error Loading Stream Data</h1><p>' + error.message + '</p></div>';
                }
            }
        }
        
        // Render stream data content (all data from VL Hub)
        function renderStreamDataContent(stream, uniqueId, streamType) {
            let html = '<div class="stream-data-page" style="padding: 40px; color: #fff4e9; max-width: 1200px; margin: 0 auto; min-height: 100vh;">';
            
            // Stream Header
            html += '<h1 style="margin-bottom: 10px;">' + (stream.name || 'Data Stream') + '</h1>';
            if (stream.description) {
                html += '<p style="margin-bottom: 30px; opacity: 0.8;">' + stream.description + '</p>';
            }
            if (stream.url) {
                html += '<p style="margin-bottom: 30px;"><a href="' + stream.url + '" target="_blank" style="color: #fff4e9; text-decoration: underline;">' + stream.url + '</a></p>';
            }
            
            // Check stream type FIRST before checking for WordPress data
            // This prevents SOC2/WCAG streams from being misidentified as WordPress streams
            const isSOC2Stream = streamType === 'soc2-report' || 
                                 (stream.id && stream.id.startsWith('soc2-report')) ||
                                 stream.stream_type === 'soc2-report' ||
                                 stream.report_type === 'soc2-type-ii' ||
                                 (stream.name && stream.name.toLowerCase().includes('soc 2'));
            
            const isWCAGStream = streamType === 'wcag-audit-report' ||
                                (stream.id && stream.id.startsWith('wcag-audit')) ||
                                stream.stream_type === 'wcag-audit-report' ||
                                stream.report_type === 'wcag' ||
                                (stream.name && stream.name.toLowerCase().includes('wcag'));
            
            // Only check for WordPress stream if it's NOT a SOC2 or WCAG stream
            const isWordPressStream = !isSOC2Stream && !isWCAGStream && (
                stream.wp_version || stream.wp_core_data || stream.posts_data || stream.pages_data ||
                                      stream.plugins_data || stream.themes_data || stream.users_data || stream.wordpress_content ||
                                      stream.wordpress_users || (stream.id && stream.id.includes('wordpress')) ||
                streamType === 'wordpress-data'
            );
            
            // Debug: Log stream data structure
            console.log('[Stream Data] Stream type detection:', { 
                isSOC2Stream, 
                isWCAGStream, 
                isWordPressStream, 
                streamType, 
                streamId: stream.id,
                streamName: stream.name 
            });
            
            if (isWordPressStream) {
                const wpContent = stream.wordpress_content || {};
                if (stream.posts_total === undefined && wpContent.total_posts !== undefined) {
                    stream.posts_total = wpContent.total_posts;
                }
                if (stream.pages_total === undefined && wpContent.total_pages !== undefined) {
                    stream.pages_total = wpContent.total_pages;
                }
                if (stream.comments_total === undefined && wpContent.total_comments !== undefined) {
                    stream.comments_total = wpContent.total_comments;
                }

                // WordPress Core Information
                html += '<h2 style="margin-top: 40px; margin-bottom: 20px; border-bottom: 1px solid #5A5753; padding-bottom: 10px;">WordPress Core Information</h2>';
                html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 30px;">';
                if (stream.wp_version) {
                    html += '<div><strong>WordPress Version:</strong> ' + stream.wp_version + '</div>';
                }
                if (stream.php_version) {
                    html += '<div><strong>PHP Version:</strong> ' + stream.php_version + '</div>';
                }
                if (stream.mysql_version) {
                    html += '<div><strong>MySQL Version:</strong> ' + stream.mysql_version + '</div>';
                }
                html += '</div>';
                
                // Content Statistics
                html += '<h2 style="margin-top: 40px; margin-bottom: 20px; border-bottom: 1px solid #5A5753; padding-bottom: 10px;">Content Statistics</h2>';
                html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px;">';
                if (stream.posts_total !== undefined) {
                    html += '<div><strong>Posts:</strong> ' + stream.posts_total + '</div>';
                }
                if (stream.pages_total === undefined && wpContent.total_pages !== undefined) {
                    stream.pages_total = wpContent.total_pages;
                }
                if (stream.comments_total === undefined && wpContent.total_comments !== undefined) {
                    stream.comments_total = wpContent.total_comments;
                }

                const arrayFrom = (...candidates) => {
                    for (const candidate of candidates) {
                        if (Array.isArray(candidate) && candidate.length) {
                            return candidate;
                        }
                    }
                    return [];
                };

                const postsData = arrayFrom(
                    stream.posts_data,
                    stream.posts,
                    stream.data && stream.data.posts_data,
                    stream.data && stream.data.posts,
                    wpContent.posts
                );
                const pagesData = arrayFrom(
                    stream.pages_data,
                    stream.pages,
                    stream.data && stream.data.pages_data,
                    stream.data && stream.data.pages,
                    wpContent.pages
                );
                const usersData = arrayFrom(
                    stream.users_data,
                    stream.users,
                    stream.data && stream.data.users_data,
                    stream.data && stream.data.users,
                    stream.wordpress_users
                );
                const pluginsData = arrayFrom(
                    stream.plugins_data,
                    stream.plugins,
                    stream.data && stream.data.plugins_data,
                    stream.data && stream.data.plugins
                );
                const themesData = arrayFrom(
                    stream.themes_data,
                    stream.themes,
                    stream.data && stream.data.themes_data,
                    stream.data && stream.data.themes
                );

                const contentMetrics = stream.content_metrics || (stream.metrics && stream.metrics.wordpress) || {};
                const coreData = stream.wp_core_data || {};

                const summarizeCore = () => {
                    const bits = [];
                    if (stream.wp_version) bits.push(`WordPress ${stream.wp_version}`);
                    if (stream.php_version) bits.push(`PHP ${stream.php_version}`);
                    if (stream.mysql_version) bits.push(`MySQL ${stream.mysql_version}`);
                    if (coreData.core_update_available) bits.push('core updates pending');
                    const issues = [];
                    if (stream.error_count > 0) issues.push(`${stream.error_count} critical issues reported`);
                    if (stream.warning_count > 0) issues.push(`${stream.warning_count} warnings observed`);
                    const healthLine = issues.length ? issues.join(' and ') : 'no active errors or warnings detected';
                    const stack = bits.length ? bits.join(', ') : 'WordPress core details unavailable';
                    const protection = coreData.is_multisite !== undefined ? (coreData.is_multisite ? 'running as a multisite' : 'single site') : 'single site scope implied';
                    return `${stack} on ${protection}, with ${healthLine}.`;
                };

                const summarizeUpdates = () => {
                    const activePlugins = pluginsData.filter(p => (p.status || '').toLowerCase() === 'active');
                    const needsUpdate = pluginsData.filter(p => p.needs_update || p.update_version);
                    const themeUpdates = themesData.filter(t => t.needs_update || t.update_version);
                    const pluginLine = activePlugins.length
                        ? `${activePlugins.length} active plugin${activePlugins.length === 1 ? '' : 's'} including ${activePlugins.slice(0, 5).map(p => `${p.name || 'Unknown'}${p.version ? ` (${p.version})` : ''}`).join(', ')}`
                        : 'no active plugins reported';
                    const updateLine = needsUpdate.length || themeUpdates.length
                        ? `Updates available for ${needsUpdate.length} plugin${needsUpdate.length === 1 ? '' : 's'} and ${themeUpdates.length} theme${themeUpdates.length === 1 ? '' : 's'}.`
                        : 'No pending plugin or theme updates detected.';
                    const themeLine = themesData.length
                        ? `${themesData.length} installed theme${themesData.length === 1 ? '' : 's'}${themesData.find(t => t.status === 'active') ? ` (active: ${themesData.find(t => t.status === 'active').name || 'unnamed'})` : ''}`
                        : 'No themes listed in stream data.';
                    return `${pluginLine}. ${themeLine}. ${updateLine}`;
                };

                const summarizeContentAudit = () => {
                    const postCount = stream.posts_total ?? postsData.length;
                    const pageCount = stream.pages_total ?? pagesData.length;
                    const commentCount = stream.comments_total ?? 0;
                    const insights = [];
                    insights.push(`Inventory shows ${pageCount || 0} pages and ${postCount || 0} posts${commentCount ? ` with ${commentCount} comments` : ''}.`);
                    if (postCount < 5) {
                        insights.push('Blog depth is minimal; add cornerstone articles and recent updates to build authority.');
                    } else {
                        insights.push('Posts are present—extend them with refreshed data, internal links, and updated CTAs.');
                    }
                    if (pageCount > 0) {
                        insights.push('Review top pages for conversion offers, schema coverage, and multimedia to raise engagement.');
                    }
                    const tagSignals = [];
                    postsData.slice(0, 10).forEach(post => {
                        if (post.tags && post.tags.length) tagSignals.push(...post.tags.slice(0, 3));
                    });
                    if (tagSignals.length) {
                        insights.push(`Surface more content around recurring tags such as ${[...new Set(tagSignals)].slice(0, 5).join(', ')}.`);
                    }
                    return `<p>${insights[0] || 'Content totals are not available yet.'}</p><p>${insights[1] || ''}</p><p>${insights[2] || ''}</p>`;
                };

                const summarizeVulnerabilities = () => {
                    const flaggedPlugins = pluginsData.filter(p => p.needs_update || (p.status && p.status.toLowerCase() === 'inactive'));
                    const firewall = (stream.security && stream.security.firewall) || (coreData.security && coreData.security.firewall);
                    const shields = [];
                    if (firewall) shields.push(`Firewall: ${firewall}`);
                    if (stream.health_score !== undefined) shields.push(`Health score ${stream.health_score}`);
                    const updateNote = flaggedPlugins.length
                        ? `${flaggedPlugins.length} plugin${flaggedPlugins.length === 1 ? '' : 's'} require attention (updates or activation review).`
                        : 'No plugin-level vulnerabilities flagged in stream data.';
                    return `${updateNote} ${shields.join(' | ') || 'Security tooling not reported.'}`;
                };

                const summarizePerformance = () => {
                    const metrics = [];
                    if (contentMetrics.total_comments !== undefined || stream.comments_total !== undefined) {
                        metrics.push(`Comments & activity: ${(stream.comments_total ?? contentMetrics.total_comments) || 0} recorded.`);
                    }
                    if (contentMetrics.visits || contentMetrics.sessions) {
                        metrics.push(`Site visits: ${contentMetrics.visits || contentMetrics.sessions} sessions; bounce ${contentMetrics.bounce_rate ? `${contentMetrics.bounce_rate}%` : 'N/A'}.`);
                    }
                    html += '</div>';
                    
                    // Themes List - check multiple possible locations
                    const themesData = stream.themes_data || stream.themes || (stream.data && stream.data.themes_data) || (stream.data && stream.data.themes) || [];
                    if (Array.isArray(themesData) && themesData.length > 0) {
                        html += '<div style="margin-bottom: 30px;">';
                        html += '<h3 style="margin-bottom: 15px;">Theme Details (' + themesData.length + ')</h3>';
                        html += '<div style="display: grid; gap: 15px;">';
                        themesData.forEach(theme => {
                            html += '<div style="background: #1f1d1a; border: 1px solid #5A575335; border-radius: 6px; padding: 20px;">';
                            html += '<div style="font-weight: bold; font-size: 1.1em; margin-bottom: 12px; color: #fff4e9;">' + (theme.name || 'Unknown Theme') + '</div>';
                            
                            // Display ALL theme fields
                            html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; font-size: 0.85em; opacity: 0.8;">';
                            if (theme.slug) html += '<div><strong>Slug:</strong> ' + theme.slug + '</div>';
                            if (theme.version) html += '<div><strong>Version:</strong> ' + theme.version + '</div>';
                            if (theme.author) html += '<div><strong>Author:</strong> ' + theme.author + '</div>';
                            if (theme.author_uri) html += '<div><strong>Author URI:</strong> <a href="' + theme.author_uri + '" target="_blank" style="color: #fff4e9;">' + theme.author_uri + '</a></div>';
                            if (theme.theme_uri) html += '<div><strong>Theme URI:</strong> <a href="' + theme.theme_uri + '" target="_blank" style="color: #fff4e9;">' + theme.theme_uri + '</a></div>';
                            if (theme.text_domain) html += '<div><strong>Text Domain:</strong> ' + theme.text_domain + '</div>';
                            if (theme.domain_path) html += '<div><strong>Domain Path:</strong> ' + theme.domain_path + '</div>';
                            if (theme.requires_wp) html += '<div><strong>Requires WP:</strong> ' + theme.requires_wp + '</div>';
                            if (theme.tested_wp !== undefined) html += '<div><strong>Tested WP:</strong> ' + (theme.tested_wp ? 'Yes' : 'No') + '</div>';
                            if (theme.requires_php) html += '<div><strong>Requires PHP:</strong> ' + theme.requires_php + '</div>';
                            if (theme.status) html += '<div><strong>Status:</strong> <span style="color: ' + (theme.status === 'active' ? '#4ade80' : '#9A9793') + ';">' + theme.status + '</span></div>';
                            if (theme.needs_update !== undefined) {
                                html += '<div><strong>Needs Update:</strong> <span style="color: ' + (theme.needs_update ? '#ff6b6b' : '#4ade80') + ';">' + (theme.needs_update ? 'Yes' : 'No') + '</span></div>';
                            }
                            if (theme.update_version) html += '<div><strong>Update Version:</strong> <span style="color: #ff6b6b;">' + theme.update_version + '</span></div>';
                            if (theme.template) html += '<div><strong>Template:</strong> ' + theme.template + '</div>';
                            if (theme.parent) html += '<div><strong>Parent:</strong> ' + theme.parent + '</div>';
                            if (theme.last_modified) html += '<div><strong>Last Modified:</strong> ' + theme.last_modified + '</div>';
                            html += '</div>';
                            
                            if (theme.description) {
                                html += '<div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #5A575335; font-size: 0.9em; opacity: 0.8; line-height: 1.5;">' + theme.description + '</div>';
                            }
                            html += '</div>';
                        });
                        html += '</div>';
                        html += '</div>';
                    } else if (stream.themes_total > 0) {
                        html += '<div style="margin-bottom: 30px; opacity: 0.7; font-style: italic;">Theme details not available in stream data.</div>';
                    }
                }
                
                // WordPress Core Data
                if (stream.wp_core_data) {
                    html += '<h2 style="margin-top: 40px; margin-bottom: 20px; border-bottom: 1px solid #5A5753; padding-bottom: 10px;">WordPress Core Configuration</h2>';
                    html += '<div style="background: #1f1d1a; border: 1px solid #5A575335; border-radius: 6px; padding: 20px; margin-bottom: 30px;">';
                    const coreData = stream.wp_core_data;
                    html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">';
                    if (coreData.site_url) html += '<div><strong>Site URL:</strong> <a href="' + coreData.site_url + '" target="_blank" style="color: #fff4e9;">' + coreData.site_url + '</a></div>';
                    if (coreData.home_url) html += '<div><strong>Home URL:</strong> <a href="' + coreData.home_url + '" target="_blank" style="color: #fff4e9;">' + coreData.home_url + '</a></div>';
                    if (coreData.admin_email) html += '<div><strong>Admin Email:</strong> ' + coreData.admin_email + '</div>';
                    if (coreData.timezone) html += '<div><strong>Timezone:</strong> ' + coreData.timezone + '</div>';
                    if (coreData.language) html += '<div><strong>Language:</strong> ' + coreData.language + '</div>';
                    if (coreData.permalink_structure) html += '<div><strong>Permalink Structure:</strong> ' + coreData.permalink_structure + '</div>';
                    if (coreData.memory_limit) html += '<div><strong>Memory Limit:</strong> ' + coreData.memory_limit + '</div>';
                    if (coreData.max_execution_time) html += '<div><strong>Max Execution Time:</strong> ' + coreData.max_execution_time + 's</div>';
                    if (coreData.upload_max_filesize) html += '<div><strong>Upload Max Filesize:</strong> ' + coreData.upload_max_filesize + '</div>';
                    if (coreData.is_multisite !== undefined) html += '<div><strong>Multisite:</strong> ' + (coreData.is_multisite ? 'Yes' : 'No') + '</div>';
                    html += '</div>';
                    html += '</div>';
                }
                
                // Posts Data - check multiple possible locations
                if (Array.isArray(postsData) && postsData.length > 0) {
                    html += '<h2 style="margin-top: 40px; margin-bottom: 20px; border-bottom: 1px solid #5A5753; padding-bottom: 10px;">Posts (' + postsData.length + ')</h2>';
                    html += '<div style="display: grid; gap: 15px; margin-bottom: 30px;">';
                    postsData.forEach(post => {
                        html += '<div style="background: #1f1d1a; border: 1px solid #5A575335; border-radius: 6px; padding: 20px;">';
                        html += '<div style="font-weight: bold; font-size: 1.1em; margin-bottom: 12px;"><a href="' + (post.url || '#') + '" target="_blank" style="color: #fff4e9; text-decoration: underline;">' + (post.title || 'Untitled') + '</a></div>';
                        
                        if (post.excerpt) {
                            html += '<div style="opacity: 0.8; margin-bottom: 12px; font-size: 0.9em; line-height: 1.5; padding-bottom: 12px; border-bottom: 1px solid #5A575335;">' + post.excerpt + '</div>';
                        }
                        
                        // Display ALL post fields
                        html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; font-size: 0.85em; opacity: 0.8;">';
                        if (post.id) html += '<div><strong>ID:</strong> ' + post.id + '</div>';
                        if (post.slug) html += '<div><strong>Slug:</strong> ' + post.slug + '</div>';
                        if (post.date_published) html += '<div><strong>Published:</strong> ' + post.date_published + '</div>';
                        if (post.date_published_gmt) html += '<div><strong>Published (GMT):</strong> ' + post.date_published_gmt + '</div>';
                        if (post.last_updated) html += '<div><strong>Last Updated:</strong> ' + post.last_updated + '</div>';
                        if (post.last_updated_gmt) html += '<div><strong>Last Updated (GMT):</strong> ' + post.last_updated_gmt + '</div>';
                        if (post.word_count) html += '<div><strong>Word Count:</strong> ' + post.word_count + '</div>';
                        if (post.status) html += '<div><strong>Status:</strong> <span style="color: ' + (post.status === 'publish' ? '#4ade80' : '#9A9793') + ';">' + post.status + '</span></div>';
                        if (post.url) html += '<div><strong>URL:</strong> <a href="' + post.url + '" target="_blank" style="color: #fff4e9;">' + post.url + '</a></div>';
                        
                        // Author information (nested object)
                        if (post.author) {
                            if (typeof post.author === 'object') {
                                html += '<div style="grid-column: 1 / -1; margin-top: 8px; padding-top: 8px; border-top: 1px solid #5A575335;"><strong>Author:</strong>';
                                if (post.author.id) html += ' <span>ID: ' + post.author.id + '</span>';
                                if (post.author.name) html += ' <span>Name: ' + post.author.name + '</span>';
                                if (post.author.login) html += ' <span>Login: ' + post.author.login + '</span>';
                                if (post.author.email) html += ' <span>Email: ' + post.author.email + '</span>';
                                html += '</div>';
                            } else {
                                html += '<div><strong>Author:</strong> ' + post.author + '</div>';
                            }
                        }
                        
                        // Categories
                        if (post.categories && Array.isArray(post.categories) && post.categories.length > 0) {
                            html += '<div style="grid-column: 1 / -1;"><strong>Categories:</strong> ' + post.categories.join(', ') + '</div>';
                        }
                        
                        // Tags
                        if (post.tags && Array.isArray(post.tags) && post.tags.length > 0) {
                            html += '<div style="grid-column: 1 / -1;"><strong>Tags:</strong> ' + post.tags.join(', ') + '</div>';
                        }
                        
                        // Engagement metrics (nested object)
                        if (post.engagement && typeof post.engagement === 'object') {
                            html += '<div style="grid-column: 1 / -1; margin-top: 8px; padding-top: 8px; border-top: 1px solid #5A575335;"><strong>Engagement:</strong>';
                            if (post.engagement.comments !== undefined) html += ' <span>Comments: ' + post.engagement.comments + '</span>';
                            if (post.engagement.views !== undefined) html += ' <span>Views: ' + post.engagement.views + '</span>';
                            html += '</div>';
                        }
                        
                        html += '</div>';
                        html += '</div>';
                    });
                    html += '</div>';
                } else if (stream.posts_total > 0) {
                    html += '<h2 style="margin-top: 40px; margin-bottom: 20px; border-bottom: 1px solid #5A5753; padding-bottom: 10px;">Posts</h2>';
                    html += '<div style="margin-bottom: 30px; opacity: 0.7; font-style: italic;">Post details not available in stream data. Total posts: ' + stream.posts_total + '</div>';
                }
                
                // Pages Data - check multiple possible locations
                if (Array.isArray(pagesData) && pagesData.length > 0) {
                    html += '<h2 style="margin-top: 40px; margin-bottom: 20px; border-bottom: 1px solid #5A5753; padding-bottom: 10px;">Pages (' + pagesData.length + ')</h2>';
                    html += '<div style="display: grid; gap: 15px; margin-bottom: 30px;">';
                    pagesData.forEach(page => {
                        html += '<div style="background: #1f1d1a; border: 1px solid #5A575335; border-radius: 6px; padding: 20px;">';
                        html += '<div style="font-weight: bold; font-size: 1.1em; margin-bottom: 12px;"><a href="' + (page.url || '#') + '" target="_blank" style="color: #fff4e9; text-decoration: underline;">' + (page.title || 'Untitled') + '</a></div>';
                        
                        if (page.excerpt) {
                            html += '<div style="opacity: 0.8; margin-bottom: 12px; font-size: 0.9em; line-height: 1.5; padding-bottom: 12px; border-bottom: 1px solid #5A575335;">' + page.excerpt + '</div>';
                        }
                        
                        // Display ALL page fields
                        html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; font-size: 0.85em; opacity: 0.8;">';
                        if (page.id) html += '<div><strong>ID:</strong> ' + page.id + '</div>';
                        if (page.slug) html += '<div><strong>Slug:</strong> ' + page.slug + '</div>';
                        if (page.date_published) html += '<div><strong>Published:</strong> ' + page.date_published + '</div>';
                        if (page.last_updated) html += '<div><strong>Last Updated:</strong> ' + page.last_updated + '</div>';
                        if (page.word_count) html += '<div><strong>Word Count:</strong> ' + page.word_count + '</div>';
                        if (page.status) html += '<div><strong>Status:</strong> <span style="color: ' + (page.status === 'publish' ? '#4ade80' : '#9A9793') + ';">' + page.status + '</span></div>';
                        if (page.url) html += '<div><strong>URL:</strong> <a href="' + page.url + '" target="_blank" style="color: #fff4e9;">' + page.url + '</a></div>';
                        if (page.parent) html += '<div><strong>Parent ID:</strong> ' + page.parent + '</div>';
                        
                        // Author information (nested object)
                        if (page.author) {
                            if (typeof page.author === 'object') {
                                html += '<div style="grid-column: 1 / -1; margin-top: 8px; padding-top: 8px; border-top: 1px solid #5A575335;"><strong>Author:</strong>';
                                if (page.author.id) html += ' <span>ID: ' + page.author.id + '</span>';
                                if (page.author.name) html += ' <span>Name: ' + page.author.name + '</span>';
                                if (page.author.login) html += ' <span>Login: ' + page.author.login + '</span>';
                                html += '</div>';
                            } else {
                                html += '<div><strong>Author:</strong> ' + page.author + '</div>';
                            }
                        }
                        html += '</div>';
                        html += '</div>';
                    });
                    html += '</div>';
                } else if (stream.pages_total > 0) {
                    html += '<h2 style="margin-top: 40px; margin-bottom: 20px; border-bottom: 1px solid #5A5753; padding-bottom: 10px;">Pages</h2>';
                    html += '<div style="margin-bottom: 30px; opacity: 0.7; font-style: italic;">Page details not available in stream data. Total pages: ' + stream.pages_total + '</div>';
                }
                
                // Users Data - check multiple possible locations
                if (Array.isArray(usersData) && usersData.length > 0) {
                    html += '<h2 style="margin-top: 40px; margin-bottom: 20px; border-bottom: 1px solid #5A5753; padding-bottom: 10px;">Users (' + usersData.length + ')</h2>';
                    html += '<div style="display: grid; gap: 15px; margin-bottom: 30px;">';
                    usersData.forEach(user => {
                        html += '<div style="background: #1f1d1a; border: 1px solid #5A575335; border-radius: 6px; padding: 20px;">';
                        html += '<div style="font-weight: bold; font-size: 1.1em; margin-bottom: 12px; color: #fff4e9;">' + (user.display_name || user.name || user.login || 'Unknown User') + '</div>';
                        
                        // Display ALL user fields
                        html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; font-size: 0.85em; opacity: 0.8;">';
                        if (user.id) html += '<div><strong>ID:</strong> ' + user.id + '</div>';
                        if (user.login) html += '<div><strong>Login:</strong> ' + user.login + '</div>';
                        if (user.email) html += '<div><strong>Email:</strong> ' + user.email + '</div>';
                        if (user.display_name) html += '<div><strong>Display Name:</strong> ' + user.display_name + '</div>';
                        if (user.first_name) html += '<div><strong>First Name:</strong> ' + user.first_name + '</div>';
                        if (user.last_name) html += '<div><strong>Last Name:</strong> ' + user.last_name + '</div>';
                        if (user.nickname) html += '<div><strong>Nickname:</strong> ' + user.nickname + '</div>';
                        if (user.roles && Array.isArray(user.roles) && user.roles.length > 0) {
                            html += '<div><strong>Roles:</strong> ' + user.roles.join(', ') + '</div>';
                        }
                        if (user.registered) html += '<div><strong>Registered:</strong> ' + user.registered + '</div>';
                        if (user.description) html += '<div><strong>Description:</strong> ' + user.description + '</div>';
                        if (user.last_login) html += '<div><strong>Last Login:</strong> ' + user.last_login + '</div>';
                        if (user.post_count !== undefined) html += '<div><strong>Post Count:</strong> ' + user.post_count + '</div>';
                        if (user.url) html += '<div><strong>URL:</strong> <a href="' + user.url + '" target="_blank" style="color: #fff4e9;">' + user.url + '</a></div>';
                        html += '</div>';
                        html += '</div>';
                    });
                    html += '</div>';
                } else if (stream.users_total > 0) {
                    html += '<h2 style="margin-top: 40px; margin-bottom: 20px; border-bottom: 1px solid #5A5753; padding-bottom: 10px;">Users</h2>';
                    html += '<div style="margin-bottom: 30px; opacity: 0.7; font-style: italic;">User details not available in stream data. Total users: ' + stream.users_total + '</div>';
                }
                
                // Content Metrics
                if (stream.content_metrics) {
                    html += '<h2 style="margin-top: 40px; margin-bottom: 20px; border-bottom: 1px solid #5A5753; padding-bottom: 10px;">Content Metrics</h2>';
                    html += '<div style="background: #1f1d1a; border: 1px solid #5A575335; border-radius: 6px; padding: 20px; margin-bottom: 30px;">';
                    const metrics = stream.content_metrics;
                    html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">';
                    if (metrics.total_word_count !== undefined) html += '<div><strong>Total Word Count:</strong> ' + metrics.total_word_count.toLocaleString() + '</div>';
                    if (metrics.average_word_count_per_post !== undefined) html += '<div><strong>Average Words Per Post:</strong> ' + metrics.average_word_count_per_post.toLocaleString() + '</div>';
                    html += '</div>';
                    if (metrics.top_keywords && Object.keys(metrics.top_keywords).length > 0) {
                        html += '<h3 style="margin-top: 20px; margin-bottom: 15px;">Top Keywords</h3>';
                        html += '<div style="display: flex; flex-wrap: wrap; gap: 10px;">';
                        const sortedKeywords = Object.entries(metrics.top_keywords).sort((a, b) => b[1] - a[1]).slice(0, 20);
                        sortedKeywords.forEach(([keyword, count]) => {
                            html += '<span style="background: #2E2C2A; padding: 5px 12px; border-radius: 4px; font-size: 0.85em;">' + keyword + ' (' + count + ')</span>';
                        });
                        html += '</div>';
                    }
                    if (contentMetrics.top_pages && Array.isArray(contentMetrics.top_pages) && contentMetrics.top_pages.length) {
                        const topPages = contentMetrics.top_pages.slice(0, 3).map(p => p.title || p.url || p.path).filter(Boolean);
                        if (topPages.length) metrics.push(`Top visited pages/posts: ${topPages.join('; ')}.`);
                    }
                    return metrics.length ? metrics.map(line => `<p>${line}</p>`).join('') : '<p>Analytics signals are not yet available from this stream.</p>';
                };

                const summarizeLuna = () => {
                    const postCount = stream.posts_total ?? postsData.length;
                    const pageCount = stream.pages_total ?? pagesData.length;
                    const pluginHealth = pluginsData.filter(p => p.needs_update).length;
                    return `Luna sees ${pageCount || 0} pages, ${postCount || 0} posts, and ${pluginsData.length || 0} plugins. ${pluginHealth ? `${pluginHealth} plugin${pluginHealth === 1 ? '' : 's'} need updates—` : 'Plugins look up-to-date—'}let me orchestrate fixes or generate briefs based on this audit.`;
                };

                html += '<div class="wp-audit-report" style="display:flex; flex-direction:column; gap:28px;">';
                html += '<section style="background:#111; border:1px solid #5A575335; border-radius:12px; padding:20px;">';
                html += '<h2 style="margin:0 0 10px;">State of WordPress Core</h2>';
                html += '<p style="margin:0; line-height:1.6;">' + summarizeCore() + '</p>';
                html += '</section>';

                html += '<section style="background:#111; border:1px solid #5A575335; border-radius:12px; padding:20px;">';
                html += '<h2 style="margin:0 0 10px;">Updates and Optimizations</h2>';
                html += '<p style="margin:0; line-height:1.6;">' + summarizeUpdates() + '</p>';
                html += '</section>';

                html += '<section style="background:#111; border:1px solid #5A575335; border-radius:12px; padding:20px;">';
                html += '<h2 style="margin:0 0 10px;">Content Audit</h2>';
                html += summarizeContentAudit();
                html += '</section>';

                html += '<section style="background:#111; border:1px solid #5A575335; border-radius:12px; padding:20px;">';
                html += '<h2 style="margin:0 0 10px;">Known Vulnerabilities</h2>';
                html += '<p style="margin:0; line-height:1.6;">' + summarizeVulnerabilities() + '</p>';
                html += '</section>';

                html += '<section style="background:#111; border:1px solid #5A575335; border-radius:12px; padding:20px;">';
                html += '<h2 style="margin:0 0 10px;">Performance &amp; Analytics</h2>';
                html += summarizePerformance();
                html += '</section>';

                html += '<section style="background:#8D8C00; color:#000; border-radius:12px; padding:20px;">';
                html += '<h2 style="margin:0 0 10px;">Luna Summary</h2>';
                html += '<p style="margin:0; line-height:1.6;">' + summarizeLuna() + '</p>';
                html += '</section>';
                html += '</div>';

            }

            // For competitor analysis, fetch and display competitor report data
            // Check if this is a competitor analysis stream (either by ID or by having report_data)
            const isCompetitorAnalysis = (stream.id && (stream.id.includes('competitor') || stream.id.includes('competitive'))) || 
                                         (stream.categories && stream.categories.includes('competitive')) ||
                                         streamType === 'competitive-analysis';
            
            if (isCompetitorAnalysis && stream.report_data) {
                const report = stream.report_data;
                
                // Lighthouse Scores
                if (report.lighthouse) {
                    html += '<h2>Lighthouse Scores</h2>';
                    html += '<div>';
                    html += '<div><strong>Performance:</strong> ' + (report.lighthouse.performance || 'N/A') + '%</div>';
                    html += '<div><strong>Accessibility:</strong> ' + (report.lighthouse.accessibility || 'N/A') + '%</div>';
                    html += '<div><strong>SEO:</strong> ' + (report.lighthouse.seo || 'N/A') + '%</div>';
                    html += '<div><strong>Best Practices:</strong> ' + (report.lighthouse.best_practices || 'N/A') + '%</div>';
                    html += '</div>';
                }
                
                // Site Information
                html += '<h2>Site Information</h2>';
                html += '<div>';
                html += '<div><strong>Public Pages:</strong> ' + (report.public_pages || 'N/A') + '</div>';
                if (report.blog) {
                    html += '<div><strong>Blog Status:</strong> ' + (report.blog.status || 'Unknown') + ' (' + (report.blog.post_count || 0) + ' posts detected)</div>';
                    html += '<div><strong>Blog URL:</strong> <a href="' + (report.blog.source_link || '#') + '" target="_blank">' + (report.blog.source_link || 'N/A') + '</a></div>';
                }
                if (report.meta_info) {
                    if (report.meta_info.title) {
                        html += '<div><strong>Title:</strong> ' + report.meta_info.title + '</div>';
                    }
                    if (report.meta_info.description) {
                        html += '<div><strong>Description:</strong> ' + report.meta_info.description + '</div>';
                    }
                    if (report.meta_info.keywords) {
                        html += '<div><strong>Keywords:</strong> ' + report.meta_info.keywords + '</div>';
                    }
                }
                html += '</div>';
                
                // Top Keywords
                if (report.top_keywords && Array.isArray(report.top_keywords) && report.top_keywords.length > 0) {
                    html += '<h2>Top 10 Keywords</h2>';
                    html += '<div>';
                    report.top_keywords.slice(0, 10).forEach(item => {
                        const keyword = item.keyword || item;
                        const frequency = item.frequency || '';
                        html += '<div>';
                        html += '<strong>' + keyword + '</strong>';
                        if (frequency) {
                            html += ' - Frequency: ' + frequency;
                        }
                        html += '</div>';
                    });
                    html += '</div>';
                }
                
                // Top Keyphrases
                if (report.top_keyphrases && Array.isArray(report.top_keyphrases) && report.top_keyphrases.length > 0) {
                    html += '<h2>Top 10 Keyphrases</h2>';
                    html += '<div>';
                    report.top_keyphrases.slice(0, 10).forEach(item => {
                        const phrase = item.phrase || item;
                        const frequency = item.frequency || '';
                        html += '<div>';
                        html += '<strong>' + phrase + '</strong>';
                        if (frequency) {
                            html += ' - Frequency: ' + frequency;
                        }
                        html += '</div>';
                    });
                    html += '</div>';
                }
            }
            
            // For SOC2 and WCAG streams, fetch and display the formatted view from backend
            if (isSOC2Stream || isWCAGStream) {
                html += '<div id="soc2-wcag-display-container" style="margin-top: 40px; min-height: 400px; background: #fff; border-radius: 6px; padding: 20px;">';
                html += '<div style="text-align: center; padding: 40px; color: #23282d;">Loading report data...</div>';
                html += '</div>';
            }
            
            // Generic stream data (only show if not WordPress, SOC2, or WCAG stream)
            if (!isWordPressStream && !isSOC2Stream && !isWCAGStream) {
                html += '<h2 style="margin-top: 40px; margin-bottom: 20px; border-bottom: 1px solid #5A5753; padding-bottom: 10px;">Stream Details</h2>';
                html += '<div style="background: #1f1d1a; border: 1px solid #5A575335; border-radius: 6px; padding: 20px; margin-bottom: 30px;">';
                html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">';
            html += '<div><strong>Stream ID:</strong> ' + (stream.id || 'N/A') + '</div>';
            html += '<div><strong>Health Score:</strong> ' + (stream.health_score || 'N/A') + '</div>';
            html += '<div><strong>Status:</strong> ' + (stream.status || 'N/A') + '</div>';
            if (stream.last_updated) {
                html += '<div><strong>Last Updated:</strong> ' + stream.last_updated + '</div>';
            }
            if (stream.error_count !== undefined) {
                html += '<div><strong>Error Count:</strong> ' + stream.error_count + '</div>';
            }
            if (stream.warning_count !== undefined) {
                html += '<div><strong>Warning Count:</strong> ' + stream.warning_count + '</div>';
            }
            html += '</div>';
                html += '</div>';
            }
            
            // Display all report_data if available (for non-WordPress, non-SOC2, non-WCAG streams)
            if (!isWordPressStream && !isSOC2Stream && !isWCAGStream && stream.report_data && typeof stream.report_data === 'object') {
                html += '<h2 style="margin-top: 40px; margin-bottom: 20px; border-bottom: 1px solid #5A5753; padding-bottom: 10px;">Report Data</h2>';
                html += '<div style="background: #1f1d1a; border: 1px solid #5A575335; border-radius: 6px; padding: 20px; margin-bottom: 30px;">';
                html += '<pre style="overflow-x: auto; font-size: 0.85em; color: #fff4e9;">' + JSON.stringify(stream.report_data, null, 2) + '</pre>';
                html += '</div>';
            }

            html += '<div id="orchestratePanel" style="margin: 30px 0 10px; padding: 18px; border: 1px solid #5A575335; border-radius: 10px; background: #111; display: flex; flex-direction: column; gap: 12px;">';
            html += '<div style="display:flex; align-items:center; gap:10px; flex-wrap:wrap;">';
            html += '<span style="font-weight:700; color:#fff4e9;">Orchestrate</span>';
            html += '<button id="orchestrateTrigger" style="background:#8D8C00; color:#000; border:none; padding:10px 14px; border-radius:8px; font-weight:700; cursor:pointer;">Open Options</button>';
            html += '</div>';
            html += '<div id="orchestrateModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.6); z-index:1200; align-items:center; justify-content:center;">';
            html += '<div style="background:#0b0b0b; border:1px solid #5A575335; border-radius:10px; padding:20px; width:320px; box-shadow:0 10px 30px rgba(0,0,0,0.35);">';
            html += '<div style="font-weight:700; color:#fff4e9; margin-bottom:14px; display:flex; justify-content:space-between; align-items:center;">';
            html += '<span>Choose an action</span>';
            html += '<button id="orchestrateClose" aria-label="Close" style="background:none; border:none; color:#fff4e9; font-size:18px; cursor:pointer;">×</button>';
            html += '</div>';
            html += '<div style="display:flex; flex-direction:column; gap:10px;">';
            html += '<button data-orchestrate="ticket" style="text-align:left; padding:10px; border-radius:8px; border:1px solid #5A575335; background:#1f1d1a; color:#fff4e9; cursor:pointer;">New Ticket</button>';
            html += '<button data-orchestrate="ai-summary" style="text-align:left; padding:10px; border-radius:8px; border:1px solid #5A575335; background:#1f1d1a; color:#fff4e9; cursor:pointer;">AI Summary</button>';
            html += '<button data-orchestrate="send-to" style="text-align:left; padding:10px; border-radius:8px; border:1px solid #5A575335; background:#1f1d1a; color:#fff4e9; cursor:pointer;">Send to</button>';
            html += '</div>';
            html += '</div>';
            html += '</div>';

            html += '</div>';
            
            // Insert content into page content container (preserving overlay)
            const pageContent = document.getElementById('vlPageContent');
            if (pageContent) {
                // Ensure page content container allows scrolling
                pageContent.style.cssText = 'display: block !important; position: fixed !important; top: 0 !important; left: 0 !important; width: 100% !important; height: 100vh !important; overflow-y: auto !important; overflow-x: hidden !important; z-index: 1000 !important;';
                pageContent.innerHTML = html;
                
                // Initialize heading style selector
                setTimeout(function() {
                    initHeadingStyleSelector();
                }, 100);
                
                // For SOC2 and WCAG streams, fetch and display the formatted view from backend
                if (isSOC2Stream || isWCAGStream) {
                    const licenseKey = (new URLSearchParams(window.location.search).get('license') || '').split('/')[0];
                    const container = document.getElementById('soc2-wcag-display-container');
                    if (container && licenseKey && stream.id) {
                        fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/stream-display-view?license=${encodeURIComponent(licenseKey)}&stream_id=${encodeURIComponent(stream.id)}`, {
                            credentials: 'include'
                        })
                            .then(response => response.json())
                            .then(data => {
                                if (container && data && data.success && data.html) {
                                    container.innerHTML = data.html;
                                } else if (container) {
                                    container.innerHTML = '<div style="padding: 40px; color: #23282d;">Unable to load formatted report view. Please try again later.</div>';
                                }
                            })
                            .catch(error => {
                                console.error('Error fetching display view:', error);
                                if (container) {
                                    container.innerHTML = '<div style="padding: 40px; color: #23282d;">Error loading report view: ' + error.message + '</div>';
                                }
                            });
                    }
                }
                
                try {
                    const licenseParam = (new URLSearchParams(window.location.search).get('license') || 'VL-AWJJ-8J6S-GD6R').split('/')[0];
                    const orchestrateModal = document.getElementById('orchestrateModal');
                    const orchestrateTrigger = document.getElementById('orchestrateTrigger');
                    const orchestrateClose = document.getElementById('orchestrateClose');
                    const orchestrateButtons = orchestrateModal ? orchestrateModal.querySelectorAll('button[data-orchestrate]') : [];

                    const closeModal = () => { if (orchestrateModal) orchestrateModal.style.display = 'none'; };
                    const openModal = () => { if (orchestrateModal) orchestrateModal.style.display = 'flex'; };

                    orchestrateTrigger && orchestrateTrigger.addEventListener('click', openModal);
                    orchestrateClose && orchestrateClose.addEventListener('click', closeModal);
                    if (orchestrateModal) {
                        orchestrateModal.addEventListener('click', (e) => { if (e.target === orchestrateModal) closeModal(); });
                    }

                    orchestrateButtons.forEach(btn => {
                        btn.addEventListener('click', () => {
                            const action = btn.getAttribute('data-orchestrate');
                            if (action === 'ticket') {
                                window.location.href = `https://supercluster.visiblelight.ai/?license=${encodeURIComponent(licenseParam)}/support/tickets/`;
                            } else if (action === 'ai-summary') {
                                try {
                                    localStorage.setItem('lunaComposerFollowupPrompt', JSON.stringify({ prompt: 'Run WordPress Site Audit with Key Details About Technology and Content', license: licenseParam, created: Date.now(), type: 'ai-summary' }));
                                } catch (err) {
                                    console.warn('Could not store AI Summary prompt', err);
                                }
                                window.open(`/luna-compose?license=${encodeURIComponent(licenseParam)}`, '_blank');
                            } else if (action === 'send-to') {
                                window.location.href = '#';
                            }
                            closeModal();
                        });
                    });
                } catch (hookError) {
                    console.warn('Failed to initialize orchestrate actions', hookError);
                }
            } else {
                console.error('Page content container not found');
            }
        }

        // NOTE: renderSharedLunaComposer is defined earlier in the file (before authentication check)
        // Duplicate definition removed
        
        // Render Luna Composer page
        async function renderLunaComposer() {
            try {
                console.log('[Luna Composer] Starting render...');
                
                // Remove yourSuperclusterWidget from Luna Composer page
                const superclusterWidget = document.getElementById('yourSuperclusterWidget');
                if (superclusterWidget) {
                    console.log('[Luna Composer] Removing yourSuperclusterWidget...');
                    superclusterWidget.remove();
                }
                
                // Replace right sidebar with History sidebar for Luna Composer
                const rightSidebar = document.querySelector('.vl-right-sidebar');
                if (rightSidebar) {
                    console.log('[Luna Composer] Replacing right sidebar with History...');
                    // Ensure right sidebar is visible
                    rightSidebar.style.display = 'block';
                    rightSidebar.style.visibility = 'visible';
                    rightSidebar.style.opacity = '1';
                    rightSidebar.style.cssText += 'display: block !important; visibility: visible !important; opacity: 1 !important;';
                    
                    // Replace the Stream Activity widget with History widget
                    let activityWidget = rightSidebar.querySelector('#recentActivityWidget');
                    if (!activityWidget) {
                        // Create widget if it doesn't exist
                        activityWidget = document.createElement('div');
                        activityWidget.className = 'vl-widget vl-widget-activity';
                        activityWidget.id = 'recentActivityWidget';
                        rightSidebar.appendChild(activityWidget);
                        console.log('[Luna Composer] Created new History widget');
                    }
                    
                    // Ensure widget is visible
                    activityWidget.style.display = 'block';
                    activityWidget.style.visibility = 'visible';
                    activityWidget.style.opacity = '1';
                    activityWidget.style.cssText += 'display: block !important; visibility: visible !important; opacity: 1 !important;';
                    
                    // Replace widget content with History (keep prompt-container separate)
                        activityWidget.innerHTML = `
                            <div class="vl-widget-header">
                                <h3>Saved Documents</h3>
                                <button class="vl-widget-toggle" data-widget="recentActivityWidget" aria-label="Hide widget">
                                    <img src="https://visiblelight.ai/wp-content/uploads/2025/11/vl-eye-hide-icon.svg" alt="Hide" class="vl-toggle-icon" />
                                </button>
                            </div>
                            <div class="vl-widget-body vl-widget-body-hidden">
                                <ul id="lunaComposerHistoryList" class="vl-activity-list">
                                <li class="vl-activity-empty">Loading history...</li>
                                </ul>
                            </div>
                        `;
                    
                    // Set styles for #recentActivityWidget on luna-compose screen
                    activityWidget.style.display = 'flex';
                    activityWidget.style.flexDirection = 'column';
                    activityWidget.style.maxHeight = 'calc(50vh - 0px)';
                    
                    console.log('[Luna Composer] History widget replaced successfully');
                    
                    // Load history after widget is set up
                    setTimeout(() => {
                        if (typeof loadLunaComposerHistory === 'function') {
                            console.log('[Luna Composer] Loading history...');
                            loadLunaComposerHistory();
                        } else {
                            console.warn('[Luna Composer] loadLunaComposerHistory function not available');
                        }
                    }, 500);
                } else {
                    console.error('[Luna Composer] Right sidebar not found!');
                }
                
                // Remove controls completely
                const controls = document.querySelector('.vl-controls');
                if (controls) {
                    console.log('[Luna Composer] Removing controls...');
                    controls.remove();
                }
                
                // Remove three.js labels if they exist (only hides on internal pages)
                console.log('[Luna Composer] Hiding labels container...');
                hideSuperclusterLabels();
                
                // Hide only the Three.js canvas, keep container visible
                hideThreeJSCanvas();
                
                const pageContent = document.getElementById('vlPageContent');
                
                // Show page content container - set z-index higher than overlay to display on top
                if (!pageContent) {
                    // Create page content container if it doesn't exist
                    const newPageContent = document.createElement('div');
                    newPageContent.id = 'vlPageContent';
                    newPageContent.className = 'vl-page-content';
                    newPageContent.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000000; z-index: 1000; overflow-y: auto; display: block !important; pointer-events: auto;';
                    document.body.appendChild(newPageContent);
                } else {
                    // Ensure page content is visible and above overlay
                    pageContent.style.display = 'block';
                    pageContent.style.position = 'fixed';
                    pageContent.style.top = '0';
                    pageContent.style.left = '0';
                    pageContent.style.width = '100%';
                    pageContent.style.height = '100%';
                    pageContent.style.zIndex = '1000';
                    pageContent.style.overflowY = 'auto';
                    pageContent.style.pointerEvents = 'auto';
                }
                
                // Extract license key from URL
                const currentParams = new URLSearchParams(window.location.search);
                const currentUrlLicenseParam = currentParams.get('license') || '';
                let extractedLicenseKey = '';
                if (currentUrlLicenseParam) {
                    const licenseMatch = currentUrlLicenseParam.match(/^([^/]+)/);
                    if (licenseMatch) {
                        extractedLicenseKey = licenseMatch[1];
                    } else {
                        extractedLicenseKey = currentUrlLicenseParam;
                    }
                }
                
                // Fetch Essentials from client's WordPress site
                let cannedResponses = [];
                let clientSiteUrl = null;
                
                // First, get client's WordPress site URL from Hub profile
                try {
                    const profileResp = await fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/profile?license=${encodeURIComponent(extractedLicenseKey)}`, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include'
                    });
                    if (profileResp.ok) {
                        const profileData = await profileResp.json();
                        // Get client site URL from profile - check multiple possible locations
                        if (profileData.data?.site_info?.site) {
                            clientSiteUrl = profileData.data.site_info.site;
                        } else if (profileData.site_info?.site) {
                            clientSiteUrl = profileData.site_info.site;
                        } else if (profileData.site?.home_url) {
                            clientSiteUrl = profileData.site.home_url;
                        } else if (profileData.data?.site?.home_url) {
                            clientSiteUrl = profileData.data.site.home_url;
                        }
                    }
                } catch (e) {
                    console.warn('[Luna Composer] Could not fetch profile to get client site URL:', e);
                }
                
                // If we have client site URL, fetch Essentials from there
                if (clientSiteUrl) {
                    try {
                        const essentialsResp = await fetch(`${clientSiteUrl}/wp-json/luna_widget/v1/canned-responses?license=${encodeURIComponent(extractedLicenseKey)}`, {
                        method: 'GET',
                        headers: { 
                            'Content-Type': 'application/json',
                            'X-Luna-License': extractedLicenseKey
                        },
                        credentials: 'include'
                    });
                        if (essentialsResp.ok) {
                            const essentialsData = await essentialsResp.json();
                            console.log('[Luna Composer] Raw response from client site:', essentialsData);
                            // Handle different response formats
                            if (Array.isArray(essentialsData)) {
                                cannedResponses = essentialsData;
                            } else if (essentialsData && Array.isArray(essentialsData.items)) {
                                cannedResponses = essentialsData.items;
                            } else if (essentialsData && Array.isArray(essentialsData.data)) {
                                cannedResponses = essentialsData.data;
                            } else if (essentialsData && typeof essentialsData === 'object') {
                                // Try to find any array property
                                const arrayKeys = Object.keys(essentialsData).filter(key => Array.isArray(essentialsData[key]));
                                if (arrayKeys.length > 0) {
                                    console.log('[Luna Composer] Found array in key:', arrayKeys[0]);
                                    cannedResponses = essentialsData[arrayKeys[0]];
                                } else {
                                    console.warn('[Luna Composer] No array found in response, keys:', Object.keys(essentialsData));
                                    cannedResponses = [];
                                }
                            } else {
                                console.warn('[Luna Composer] Unexpected response format:', typeof essentialsData);
                                cannedResponses = [];
                            }
                            console.log('[Luna Composer] Loaded', cannedResponses.length, 'essential commands from client WordPress site');
                        } else {
                            console.warn('[Luna Composer] Failed to fetch essentials from client site:', essentialsResp.status, essentialsResp.statusText);
                            if (essentialsResp.status === 404) {
                                console.warn('[Luna Composer] REST endpoint not found. This may require flushing WordPress rewrite rules. Trying Hub as fallback...');
                            }
                            // Try fetching from Hub as fallback
                            try {
                                const hubEssentialsResp = await fetch(`https://visiblelight.ai/wp-json/luna_widget/v1/canned-responses?license=${encodeURIComponent(extractedLicenseKey)}`, {
                                    method: 'GET',
                                    headers: { 
                                        'Content-Type': 'application/json',
                                        'X-Luna-License': extractedLicenseKey
                                    },
                                    credentials: 'include'
                                });
                                if (hubEssentialsResp.ok) {
                                    const hubEssentialsData = await hubEssentialsResp.json();
                                    console.log('[Luna Composer] Raw response from Hub (fallback):', hubEssentialsData);
                                    // Handle different response formats
                                    if (Array.isArray(hubEssentialsData)) {
                                        cannedResponses = hubEssentialsData;
                                    } else if (hubEssentialsData && Array.isArray(hubEssentialsData.items)) {
                                        cannedResponses = hubEssentialsData.items;
                                    } else if (hubEssentialsData && Array.isArray(hubEssentialsData.data)) {
                                        cannedResponses = hubEssentialsData.data;
                                    } else if (hubEssentialsData && typeof hubEssentialsData === 'object') {
                                        // Try to find any array property
                                        const arrayKeys = Object.keys(hubEssentialsData).filter(key => Array.isArray(hubEssentialsData[key]));
                                        if (arrayKeys.length > 0) {
                                            console.log('[Luna Composer] Found array in key:', arrayKeys[0]);
                                            cannedResponses = hubEssentialsData[arrayKeys[0]];
                                        } else {
                                            console.warn('[Luna Composer] No array found in Hub response, keys:', Object.keys(hubEssentialsData));
                                            cannedResponses = [];
                                        }
                                    } else {
                                        console.warn('[Luna Composer] Unexpected Hub response format:', typeof hubEssentialsData);
                                        cannedResponses = [];
                                    }
                                    console.log('[Luna Composer] Loaded', cannedResponses.length, 'essential commands from Hub as fallback');
                                } else {
                                    console.warn('[Luna Composer] Hub returned status:', hubEssentialsResp.status);
                                }
                            } catch (hubError) {
                                console.error('[Luna Composer] Could not fetch essentials from Hub:', hubError);
                                if (hubError.message && hubError.message.includes('CORS')) {
                                    console.error('[Luna Composer] CORS error detected on Hub - check server CORS headers');
                                }
                            }
                    }
                } catch (e) {
                        console.error('[Luna Composer] Could not fetch essentials from client WordPress site:', e);
                        if (e.message && e.message.includes('CORS')) {
                            console.error('[Luna Composer] CORS error detected - check server CORS headers');
                        }
                        // Try fetching from Hub as fallback
                        try {
                            const hubEssentialsResp = await fetch(`https://visiblelight.ai/wp-json/luna_widget/v1/canned-responses?license=${encodeURIComponent(extractedLicenseKey)}`, {
                                method: 'GET',
                                headers: { 
                                    'Content-Type': 'application/json',
                                    'X-Luna-License': extractedLicenseKey
                                },
                                credentials: 'include'
                            });
                            if (hubEssentialsResp.ok) {
                                const hubEssentialsData = await hubEssentialsResp.json();
                                console.log('[Luna Composer] Raw response from Hub (fallback 2):', hubEssentialsData);
                                // Handle different response formats
                                if (Array.isArray(hubEssentialsData)) {
                                    cannedResponses = hubEssentialsData;
                                } else if (hubEssentialsData && Array.isArray(hubEssentialsData.items)) {
                                    cannedResponses = hubEssentialsData.items;
                                } else if (hubEssentialsData && Array.isArray(hubEssentialsData.data)) {
                                    cannedResponses = hubEssentialsData.data;
                                } else if (hubEssentialsData && typeof hubEssentialsData === 'object') {
                                    // Try to find any array property
                                    const arrayKeys = Object.keys(hubEssentialsData).filter(key => Array.isArray(hubEssentialsData[key]));
                                    if (arrayKeys.length > 0) {
                                        console.log('[Luna Composer] Found array in key:', arrayKeys[0]);
                                        cannedResponses = hubEssentialsData[arrayKeys[0]];
                                    } else {
                                        console.warn('[Luna Composer] No array found in Hub response, keys:', Object.keys(hubEssentialsData));
                                        cannedResponses = [];
                                    }
                                } else {
                                    console.warn('[Luna Composer] Unexpected Hub response format:', typeof hubEssentialsData);
                                    cannedResponses = [];
                                }
                                console.log('[Luna Composer] Loaded', cannedResponses.length, 'essential commands from Hub as fallback');
                            } else {
                                console.warn('[Luna Composer] Hub returned status:', hubEssentialsResp.status);
                            }
                        } catch (hubError) {
                            console.error('[Luna Composer] Could not fetch essentials from Hub:', hubError);
                            if (hubError.message && hubError.message.includes('CORS')) {
                                console.error('[Luna Composer] CORS error detected on Hub - check server CORS headers');
                            }
                        }
                    }
                } else {
                    console.warn('[Luna Composer] Client site URL not found, trying Hub...');
                    // Try fetching from Hub directly
                    try {
                        const hubEssentialsResp = await fetch(`https://visiblelight.ai/wp-json/luna_widget/v1/canned-responses?license=${encodeURIComponent(extractedLicenseKey)}`, {
                            method: 'GET',
                            headers: { 
                                'Content-Type': 'application/json',
                                'X-Luna-License': extractedLicenseKey
                            },
                            credentials: 'include'
                        });
                        if (hubEssentialsResp.ok) {
                            const hubEssentialsData = await hubEssentialsResp.json();
                            console.log('[Luna Composer] Raw response from Hub (direct):', hubEssentialsData);
                            // Handle different response formats
                            if (Array.isArray(hubEssentialsData)) {
                                cannedResponses = hubEssentialsData;
                            } else if (hubEssentialsData && Array.isArray(hubEssentialsData.items)) {
                                cannedResponses = hubEssentialsData.items;
                            } else if (hubEssentialsData && Array.isArray(hubEssentialsData.data)) {
                                cannedResponses = hubEssentialsData.data;
                            } else if (hubEssentialsData && typeof hubEssentialsData === 'object') {
                                // Try to find any array property
                                const arrayKeys = Object.keys(hubEssentialsData).filter(key => Array.isArray(hubEssentialsData[key]));
                                if (arrayKeys.length > 0) {
                                    console.log('[Luna Composer] Found array in key:', arrayKeys[0]);
                                    cannedResponses = hubEssentialsData[arrayKeys[0]];
                                } else {
                                    console.warn('[Luna Composer] No array found in Hub response, keys:', Object.keys(hubEssentialsData));
                                    cannedResponses = [];
                                }
                            } else {
                                console.warn('[Luna Composer] Unexpected Hub response format:', typeof hubEssentialsData);
                                cannedResponses = [];
                            }
                            console.log('[Luna Composer] Loaded', cannedResponses.length, 'essential commands from Hub');
                        } else {
                            console.warn('[Luna Composer] Failed to fetch essentials from Hub:', hubEssentialsResp.status, hubEssentialsResp.statusText);
                        }
                    } catch (hubError) {
                        console.warn('[Luna Composer] Could not fetch essentials from Hub:', hubError);
                    }
                }
                
                // Build Luna Composer UI
                // Add padding-top to account for overlay header (80px) and some spacing
                // Make the container clickable (pointer-events: auto) so it can receive events
                let html = '<style>@media (min-width: 991px) { .luna-composer-page { max-width: 55% !important; } }</style>';
                html += '<style>.luna-composer-loading-text { background: linear-gradient(to right, #fff4e9 20%, #9A9793 30%, #9A9793 70%, #fff4e9 80%); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; background-size: 200% auto; animation: textShine 7s ease-in-out infinite alternate; } @keyframes textShine { to { background-position: -200%; } } .luna-composer-loading-icon { display: inline-block; width: 20px; height: 20px; margin-right: 12px; vertical-align: middle; animation: lunaComposerSpin 1s linear infinite; color: #fff4e9; opacity: 0.8; } @keyframes lunaComposerSpin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }</style>';
                html += '<div class="luna-composer-page" style="min-height: 100vh; background: transparent; color: #fff4e9; padding: 40px 0; max-width: 1200px; margin: 0 auto; position: relative; z-index: 2; pointer-events: auto;">';
                
                // Extract all unique categories from cannedResponses
                const allCategories = new Set();
                cannedResponses.forEach(item => {
                    if (item.categories && Array.isArray(item.categories)) {
                        item.categories.forEach(cat => {
                            if (cat && cat.name) {
                                allCategories.add(cat.name);
                            }
                        });
                    }
                });
                const categoriesArray = Array.from(allCategories).sort();
                
                // Store original responses for filtering
                window.lunaComposerAllResponses = cannedResponses;
                window.lunaComposerSelectedCategory = null;
                
                // Luna Composer Editor Section (Canned Prompts / Intelligent Suggestions)
                html += '<div class="luna-composer__editor" style="margin-bottom: 0; min-width: 100%;">';
                html += '<h1 class="TypeGradient" style="margin-bottom: 20px; font-size: 1.5rem;margin-top: 0 !important;">Compose with Luna AI</h1>';
                
                // Category Selector and Canned Section will be moved to right sidebar after pageContent is set
                let categorySelectorHTML = '';
                if (categoriesArray.length > 0) {
                    categorySelectorHTML += '<div id="luna-composer-category-selector" style="margin-bottom: 16px;">';
                    categorySelectorHTML += '<label style="display: block; color: #9A9793; font-size: 0.875rem;">Filter by:</label>';
                    categorySelectorHTML += '<select id="luna-composer-category-dropdown" onchange="window.lunaComposerFilterByCategory(this.value)" style="width: 100%; background: #2E2C2A50; border: 1px solid #5A575335; color: #fff4e9; padding: 5px 8px; border-radius: 6px; cursor: pointer; font-weight: 400; font-size: 0.8rem; appearance: none; -webkit-appearance: none; -moz-appearance: none; background-image: url(https://visiblelight.ai/wp-content/uploads/2025/08/downarrow.svg); background-repeat: no-repeat; background-position: right 12px center; padding-right: 32px;text-align: right;max-width: fit-content;max-width: 100px;background-size: 9px;">';
                    categorySelectorHTML += '<option value="">Category</option>';
                    categoriesArray.forEach(categoryName => {
                        const escapedCategory = categoryName.replace(/'/g, "\\'").replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                        categorySelectorHTML += '<option value="' + escapedCategory + '">' + categoryName + '</option>';
                    });
                    categorySelectorHTML += '</select>';
                    categorySelectorHTML += '</div>';
                } else {
                    categorySelectorHTML += '';
                }
                
                let cannedSectionHTML = '<div id="luna-composer-canned-section" style="display: block;">';
                
                if (cannedResponses.length > 0) {
                    cannedSectionHTML += '<div class="canned-prompts-wrapper" style="position: relative; width: 100%;">';
                    cannedSectionHTML += '<div class="canned-prompts-list" style="display: flex; flex-direction: column; gap: 16px; overflow-y: auto; overflow-x: hidden; max-height: calc(50vh - 200px); -webkit-overflow-scrolling: touch; scrollbar-width: thin;">';
                    cannedResponses.forEach(item => {
                        const escapedPrompt = (item.prompt || '').replace(/'/g, "\\'").replace(/"/g, '&quot;');
                        const escapedContent = (item.content || '').replace(/'/g, "\\'").replace(/"/g, '&quot;').replace(/\n/g, '\\n');
                        const escapedTitle = (item.title || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                        const escapedExcerpt = (item.excerpt || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                        
                        // Get categories for this item
                        const itemCategories = (item.categories || []).map(cat => cat.name).filter(Boolean);
                        const categoryDataAttr = itemCategories.map(cat => cat.replace(/'/g, "\\'").replace(/"/g, '&quot;')).join(',');
                        const categoryDisplay = itemCategories.length > 0 ? itemCategories.join(', ') : '';
                        
                        cannedSectionHTML += '<div class="canned-prompt-item" data-prompt-id="' + item.id + '" data-categories="' + categoryDataAttr + '" style="width: 100%;flex-shrink: 0;">';
                        if (categoryDisplay) {
                            cannedSectionHTML += '<div style="color: #9A9793; margin: 0; font-size: 0.65rem; text-transform: uppercase; letter-spacing: 0.5px; font-weight: 500; line-height: 0;margin-bottom: 10px;">' + categoryDisplay + '</div>';
                        }
                        cannedSectionHTML += '<div class="canned-prompt-header" style="display: flex; align-items: center; justify-content: space-between; cursor: pointer; margin-bottom: 0;" onclick="window.toggleCannedPrompt(this, \'' + item.id + '\', \'' + escapedPrompt.replace(/'/g, "\\'") + '\')">';
                        // Use excerpt if available, otherwise use title (full text)
                        const tooltipText = escapedExcerpt || escapedTitle;
                        const tooltipEscaped = tooltipText.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                        cannedSectionHTML += '<h3 class="canned-prompt-title" data-tooltip="' + tooltipEscaped + '" style="color: #fff4e9; margin: 0; font-size: 1rem; font-weight: 400; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; position: relative;">' + escapedTitle + '</h3>';
                        cannedSectionHTML += '<img src="https://visiblelight.ai/wp-content/uploads/2025/08/downarrow.svg" class="canned-prompt-arrow" alt="Toggle" style="width: 9px; height: 6px; margin-left: 10px; flex-shrink: 0; transition: transform 0.3s ease;" />';
                        cannedSectionHTML += '</div>';
                        cannedSectionHTML += '<div class="canned-prompt-content" style="display: none; color: #9A9793; margin: 0; font-size: 0.8rem; line-height: 1.4; overflow: hidden; transition: max-height 0.3s ease, opacity 0.3s ease; opacity: 0; max-height: 0;">';
                        cannedSectionHTML += '<p style="margin: 0; padding-top: 8px;">' + escapedExcerpt + '</p>';
                        cannedSectionHTML += '<div><button onclick="event.stopPropagation(); window.lunaComposerUsePrompt(\'' + item.id + '\', \'' + escapedPrompt.replace(/'/g, "\\'") + '\', \'\')" style="background: #fff4e9; color: #000; border: none; padding: 3px 7px; border-radius: 4px; cursor: pointer; font-size: 0.8rem; font-weight: 500;">Use Prompt</button></div>';
                        cannedSectionHTML += '</div>';
                        cannedSectionHTML += '</div>';
                    });
                        cannedSectionHTML += '</div>';
                    cannedSectionHTML += '</div>';
                } else {
                    cannedSectionHTML += '<p style="color: #9A9793; margin: 16px 0;">No essential commands found. Create a command in WP Admin > Luna Widget > Canned Responses.</p>';
                }
                cannedSectionHTML += '</div>'; // Close luna-composer-canned-section
                
                // Toolbar (sticky) with blur container
                html += '<div class="luna-composer-toolbar-container" style="position: sticky; top: 2rem; margin-bottom: 80px; z-index: 10; backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);">';
                html += '<div class="luna-composer-toolbar" style="position: sticky; display: flex; top:0; justify-content: space-between; align-items: center; padding: 12px 12px 12px 12px">';
                html += '<div style="display: flex; align-items: center; gap: 8px;">';
                html += '<span style="color: #fff4e9; font-weight: 400; font-size: 1rem;">Actions</span>';
                html += '<button id="luna-composer-find-replace" style="background: #2E2C2A50; border: 1px solid #5A575335; color: #fff4e9; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 0.875rem; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center;" onclick="window.lunaComposerShowFindReplace()" title="Find and Replace"><img src="https://visiblelight.ai/wp-content/uploads/2025/11/shuffle-regular-full.svg" alt="Find and Replace" style="width: 16px; height: 16px; filter: brightness(0) invert(1);" /></button>';
                html += '<div class="luna-composer-share" style="position: relative; display: inline-block;">';
                html += '<button id="luna-composer-share-btn" style="background: #2E2C2A50; border: 1px solid #5A575335; color: #fff4e9; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 0.875rem; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center;" onclick="window.lunaComposerShowShareModal()" title="Share"><img src="https://visiblelight.ai/wp-content/uploads/2025/11/share-regular-full.svg" alt="Share" style="width: 16px; height: 16px; filter: brightness(0) invert(1);" /></button>';
                html += '</div>';
                html += '<div class="luna-composer-export" style="position: relative; display: inline-block;">';
                html += '<button id="luna-composer-export-btn" style="background: #2E2C2A50; border: 1px solid #5A575335; color: #fff4e9; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 0.77rem; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center;" onmouseover="this.style.background=\'#3A3836\';" onmouseout="this.style.background=\'#2E2C2A\';" onclick="window.lunaComposerToggleExportMenu()" title="Export to"><img src="https://visiblelight.ai/wp-content/uploads/2025/11/arrow-down-to-line-solid-full.svg" alt="Export to" style="width: 16px; height: 16px; filter: brightness(0) invert(1);" /></button>';
                html += '<div id="luna-composer-export-menu" style="display: none; position: fixed; background: rgba(0,0,0,0.85) !important; backdrop-filter: blur(12px) !important; -webkit-backdrop-filter: blur(12px) !important; border: 1px solid #2E2C2A; border-radius: 6px; padding: 8px 0; min-width: 180px; z-index: 10000 !important; box-shadow: 0 4px 12px rgba(0,0,0,0.4);">';
                html += '<button onclick="window.lunaComposerExportTo(\'google-docs\')" style="display: block; width: 100%; text-align: left; background: none; border: none; color: #fff4e9; padding: 10px 16px; cursor: pointer; font-size: 0.875rem; transition: background 0.2s ease;" onmouseover="this.style.background=\'#2E2C2A\';" onmouseout="this.style.background=\'transparent\';">Google Docs</button>';
                html += '<button onclick="window.lunaComposerExportTo(\'pdf\')" style="display: block; width: 100%; text-align: left; background: none; border: none; color: #fff4e9; padding: 10px 16px; cursor: pointer; font-size: 0.875rem; transition: background 0.2s ease;" onmouseover="this.style.background=\'#2E2C2A\';" onmouseout="this.style.background=\'transparent\';">PDF</button>';
                html += '<button onclick="window.lunaComposerExportTo(\'mp3\')" style="display: block; width: 100%; text-align: left; background: none; border: none; color: #fff4e9; padding: 10px 16px; cursor: pointer; font-size: 0.875rem; transition: background 0.2s ease;" onmouseover="this.style.background=\'#2E2C2A\';" onmouseout="this.style.background=\'transparent\';">Audio file (mp3)</button>';
                html += '</div>';
                html += '</div>';
                html += '<div id="luna-composer-reimagine-wrapper" style="position: relative; display: flex;">';
                html += '<button id="luna-composer-reimagine-btn" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #9A9793; padding: 8px 16px; border-radius: 6px; cursor: not-allowed; font-size: 0.875rem; transition: all 0.2s ease; display: flex; pointer-events: none; align-items: center; justify-content: center; gap: 8px;" onclick="window.lunaComposerToggleReimagineMenu(event)" title="Reimagine" disabled>';
                html += '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8 2L10 6L14 6L11 9L12 13L8 10L4 13L5 9L2 6L6 6L8 2Z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>';
                html += '<span>Reimagine</span>';
                html += '<svg width="14" height="14" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" style="margin-left: 4px;"><path d="M4 6L8 10L12 6" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>';
                html += '</button>';
                html += '<div id="luna-composer-reimagine-menu" style="display: none; position: absolute; right: 0; top: calc(100% + 8px); background: rgba(0,0,0,0.92); border: 1px solid #2E2C2A; border-radius: 6px; min-width: 220px; z-index: 10000; box-shadow: 0 4px 12px rgba(0,0,0,0.4); padding: 8px 0;">';
                html += '<button type="button" onclick="window.lunaComposerSelectReimagineMode(\'highlight\')" style="display: block; width: 100%; text-align: left; background: none; border: none; color: #fff4e9; padding: 10px 16px; cursor: pointer; font-size: 0.875rem; transition: background 0.2s ease;" onmouseover="this.style.background=\'#2E2C2A\';" onmouseout="this.style.background=\'transparent\';">Highlight</button>';
                html += '<button type="button" onclick="window.lunaComposerSelectReimagineMode(\'branding\')" style="display: block; width: 100%; text-align: left; background: none; border: none; color: #fff4e9; padding: 10px 16px; cursor: pointer; font-size: 0.875rem; transition: background 0.2s ease;" onmouseover="this.style.background=\'#2E2C2A\';" onmouseout="this.style.background=\'transparent\';">Branding</button>';
                html += '<button type="button" onclick="window.lunaComposerSelectReimagineMode(\'linguistics\')" style="display: block; width: 100%; text-align: left; background: none; border: none; color: #fff4e9; padding: 10px 16px; cursor: pointer; font-size: 0.875rem; transition: background 0.2s ease;" onmouseover="this.style.background=\'#2E2C2A\';" onmouseout="this.style.background=\'transparent\';">Linguistics</button>';
                html += '</div>';
                html += '</div>';
                html += '<button id="luna-composer-readback-btn" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 0.77rem; transition: all 0.2s ease;" onclick="window.lunaComposerToggleReadback()"><img src="https://visiblelight.ai/wp-content/uploads/2025/11/ear-triangle-exclamation-light-full.svg" alt="Read Aloud Icon" Read Aloud</button>';
                html += '<button id="luna-composer-delete-btn" style="background: #d63638; border: 1px solid #1f1d1a; color: #fff4e9; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 0.77rem; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center;" onclick="window.lunaComposerShowDeleteModal()" title="Move to trash"><img src="https://visiblelight.ai/wp-content/uploads/2025/11/trash-can-regular-full.svg" alt="Move to trash" style="width: 16px; height: 16px; filter: brightness(0) invert(1);" /></button>';
                html += '<div id="luna-composer-auto-save-status" style="display: flex; align-items: center; gap: 8px; padding-right: 0;">';
                html += '<img src="https://visiblelight.ai/wp-content/uploads/2025/11/cloud-check-regular-full.svg" alt="Auto-save" style="width: 18px; height: 18px;" />';
                html += '<span id="luna-composer-save-message" style="color: #fff4e9; font-size: 0.6rem; opacity: 0; transition: opacity 0.3s ease;"></span>';
                html += '</div>';
                html += '</div>';
                html += '</div>';
                
                // Text Editor (sticky) with blur container
                html += '<div class="luna-composer-editor-container" style="position: relative;">';
                html += '<div class="luna-composer-editor-toolbar-container" style="position: sticky; top: calc(0rem + 58px); z-index: 9; backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); background: rgba(0,0,0, 0.7); border-bottom: 1px solid #1f1d1a;">';
                html += '<div id="luna-composer-editor-toolbar" style="display: flex; gap: 8px; padding: 12px 0; flex-wrap: wrap; align-items: center;">';
                html += '<button onclick="document.execCommand(\'bold\')" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 0.875rem; backdrop-filter: blur(8px);" title="Bold">B</button>';
                html += '<button onclick="document.execCommand(\'italic\')" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-style: italic; font-size: 0.875rem; backdrop-filter: blur(8px);" title="Italic">I</button>';
                html += '<button onclick="document.execCommand(\'underline\')" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; text-decoration: underline; font-size: 0.875rem; backdrop-filter: blur(8px);" title="Underline">U</button>';
                html += '<button onclick="document.execCommand(\'strikeThrough\')" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; text-decoration: line-through; font-size: 0.875rem; backdrop-filter: blur(8px);" title="Strikethrough">S</button>';
                html += '<div class="headingStyleSelect" style="position: relative; display: inline-block;">';
                html += '<button id="headingStyleSelectBtn" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.875rem; backdrop-filter: blur(8px);" title="Heading Style">H</button>';
                html += '<div id="headingStyleDropdown" style="display: none; position: absolute; top: 100%; left: 0; margin-top: 4px; background: rgba(0,0,0,0.9); border: 1px solid #1f1d1a; border-radius: 4px; padding: 4px 0; min-width: 150px; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.5);">';
                html += '<div class="heading-style-option" data-style="h1" style="padding: 8px 12px; cursor: pointer; color: #fff4e9; font-size: 1.5rem; font-weight: 700; border-bottom: 1px solid #1f1d1a;" onmouseover="this.style.background=\'#2E2C2A\';" onmouseout="this.style.background=\'transparent\';">Heading 1</div>';
                html += '<div class="heading-style-option" data-style="h2" style="padding: 8px 12px; cursor: pointer; color: #fff4e9; font-size: 1.25rem; font-weight: 700; border-bottom: 1px solid #1f1d1a;" onmouseover="this.style.background=\'#2E2C2A\';" onmouseout="this.style.background=\'transparent\';">Heading 2</div>';
                html += '<div class="heading-style-option" data-style="h3" style="padding: 8px 12px; cursor: pointer; color: #fff4e9; font-size: 1.1rem; font-weight: 700; border-bottom: 1px solid #1f1d1a;" onmouseover="this.style.background=\'#2E2C2A\';" onmouseout="this.style.background=\'transparent\';">Heading 3</div>';
                html += '<div class="heading-style-option" data-style="h4" style="padding: 8px 12px; cursor: pointer; color: #fff4e9; font-size: 1rem; font-weight: 700; border-bottom: 1px solid #1f1d1a;" onmouseover="this.style.background=\'#2E2C2A\';" onmouseout="this.style.background=\'transparent\';">Heading 4</div>';
                html += '<div class="heading-style-option" data-style="h5" style="padding: 8px 12px; cursor: pointer; color: #fff4e9; font-size: 0.9rem; font-weight: 700; border-bottom: 1px solid #1f1d1a;" onmouseover="this.style.background=\'#2E2C2A\';" onmouseout="this.style.background=\'transparent\';">Heading 5</div>';
                html += '<div class="heading-style-option" data-style="h6" style="padding: 8px 12px; cursor: pointer; color: #fff4e9; font-size: 0.85rem; font-weight: 700; border-bottom: 1px solid #1f1d1a;" onmouseover="this.style.background=\'#2E2C2A\';" onmouseout="this.style.background=\'transparent\';">Heading 6</div>';
                html += '<div class="heading-style-option" data-style="normal" style="padding: 8px 12px; cursor: pointer; color: #fff4e9; font-size: 0.875rem; font-weight: 400;" onmouseover="this.style.background=\'#2E2C2A\';" onmouseout="this.style.background=\'transparent\';">Normal text</div>';
                html += '</div>';
                html += '</div>';
                html += '<div style="margin: 0 4px; height:20px;"></div>';
                html += '<button onclick="document.execCommand(\'insertUnorderedList\')" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.875rem; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(8px);" title="Bullet List"><img src="https://visiblelight.ai/wp-content/uploads/2025/11/list-regular-full.svg" alt="Bullet List" style="width: 16px; height: 16px; filter: brightness(0) invert(1);" /></button>';
                html += '<button onclick="document.execCommand(\'insertOrderedList\')" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.875rem; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(8px);" title="Numbered List"><img src="https://visiblelight.ai/wp-content/uploads/2025/11/list-ol-solid-full-1.svg" alt="Numbered List" style="width: 16px; height: 16px; filter: brightness(0) invert(1);" /></button>';
                html += '<button onclick="document.execCommand(\'indent\')" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.875rem; backdrop-filter: blur(8px);" title="Indent">→</button>';
                html += '<button onclick="document.execCommand(\'outdent\')" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.875rem; backdrop-filter: blur(8px);" title="Outdent">←</button>';
                html += '<div style="margin: 0 4px; height:20px;"></div>';
                html += '<button onclick="document.execCommand(\'undo\')" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.875rem; backdrop-filter: blur(8px);" title="Undo">↶</button>';
                html += '<button onclick="document.execCommand(\'redo\')" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.875rem; backdrop-filter: blur(8px);" title="Redo">↷</button>';
                html += '<div style="flex: 1;"></div>'; // Spacer to push buttons to the right
                html += '<div style="margin: 0 4px; height:20px;"></div>'; // Separator
                html += '<button id="luna-composer-editor-heart-btn" onclick="window.lunaComposerToggleHeart()" style="display: none; background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.875rem; align-items: center; justify-content: center; backdrop-filter: blur(8px);" title="Like this document"><img id="luna-composer-heart-icon" src="https://visiblelight.ai/wp-content/uploads/2025/11/heart-regular-full-1.svg" alt="Like" style="width: 16px; height: 16px; filter: brightness(0) invert(1);" /></button>';
                html += '</div>';
                html += '</div>';
                // Check if there's a document ID in the URL
                const urlParams = new URLSearchParams(window.location.search);
                const urlLicense = urlParams.get('license') || '';
                let documentId = null;
                if (urlLicense.includes('/luna/compose/')) {
                    const match = urlLicense.match(/\/luna\/compose\/([^\/]+)/);
                    if (match && match[1]) {
                        documentId = match[1];
                    }
                }
                
                html += '<div id="luna-composer-editor-wrapper" style="position: relative;">';
                html += '<div id="luna-composer-editor" contenteditable="true" style="position: sticky; top: calc(2rem + 60px + 48px); min-height: 400px; padding: 12px 0; color: #fff4e9; font-size: 1rem; line-height: 1.6; outline: none; word-wrap: break-word; z-index: 8;" data-license-key="' + extractedLicenseKey + '" data-document-id="' + (documentId || '') + '"></div>';
                html += '</div>';
                html += '</div>';
                
                html += '</div>';
                
                // Prompt Input Form (fixed to bottom)
                html += '<form class="group composer w-full" id="luna-composer-prompt-form" style="position: fixed; bottom: 20px; left: 0; right: 0; height: 75px; z-index: 10000; display: flex; align-items: center; justify-content: center; padding: 0 20px; background: rgba(0,0,0,0.95); backdrop-filter: blur(8px); border-top: 1px solid #1f1d1a; border-radius:77px; pointer-events: auto !important;">';
                html += '<div style="display: flex; align-items: center; gap: 12px; width: 100%; max-width: 1200px;">';
                html += '<button type="button" id="luna-composer-save-prompt-btn" class="luna-composer-save-prompt-btn" style="display: none !important; background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 0.77rem; transition: all 0.2s ease; align-items: center; justify-content: center;" onclick="window.lunaComposerSavePrompt(event)" title="Save Prompt"><img src="https://visiblelight.ai/wp-content/uploads/2025/11/heart-regular-full-1.svg" alt="Save" style="width: 16px; height: 16px; filter: brightness(0) invert(1);" /></button>';
                html += '<div contenteditable="true" translate="no" class="ProseMirror" id="prompt-textarea" data-virtualkeyboard="true" style="flex: 1; min-height: 40px; max-height: 60px; padding: 10px 16px; background: #000; font-size: 0.875rem; line-height: 1.5; outline: none; overflow-y: auto; word-wrap: break-word;"><p data-placeholder="Write a custom prompt or choose from <i>Saved Prompts</i>..." class="placeholder" style="color: #fff4e7; margin: 0; opacity:.7;">Write a custom prompt or choose from <i>Saved Prompts</i>...<br class="ProseMirror-trailingBreak"></p></div>';
                html += '<button type="button" id="luna-composer-dictate-btn" style="background: #2E2C2A50; border: 1px solid #1f1d1a; color: #fff4e9; padding: 8px; border-radius: 50px; cursor: pointer; font-size: 0.77rem; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center;" onclick="window.lunaComposerToggleDictate()" title="Dictate"><img src="https://visiblelight.ai/wp-content/uploads/2025/11/microphone-regular-full-1.svg" alt="Dictate" style="width: 16px; height: 16px; filter: brightness(0) invert(1);" /></button>';
                html += '</div>';
                html += '</form>';
                
                // Delete Confirmation Modal
                html += '<div id="luna-composer-delete-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10001; align-items: center; justify-content: center;">';
                html += '<div style="background: #232120; border: 1px solid #2E2C2A; border-radius: 8px; padding: 24px; max-width: 500px; width: 90%;">';
                html += '<h3 style="color: #fff4e9; margin: 0 0 16px 0; font-size: 1.25rem; font-weight: 600;">Are you sure you want to permanently delete this document?</h3>';
                html += '<p style="color: #9A9793; margin: 0 0 20px 0; font-size: 0.875rem; line-height: 1.6;">Deleting this document can not be undone. <a href="#" id="luna-composer-delete-download-link" style="color: #1f1d1a; text-decoration: underline; cursor: pointer;" onclick="window.lunaComposerDownloadBackup(); return false;">Download a backup now</a> before continuing.</p>';
                html += '<div style="display: flex; gap: 12px; justify-content: flex-end;">';
                html += '<button id="luna-composer-delete-cancel" onclick="window.lunaComposerCloseDeleteModal()" style="background: #2E2C2A; border: 1px solid #5A5753; color: #fff4e9; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 0.875rem;">Cancel</button>';
                html += '<button id="luna-composer-delete-confirm" onclick="window.lunaComposerDeleteDocument()" disabled style="background: #d63638; border: 1px solid #5A5753; color: #fff4e9; padding: 10px 20px; border-radius: 6px; cursor: not-allowed; font-size: 0.875rem; font-weight: 600; opacity: 0.5;">Delete Permanently</button>';
                html += '</div>';
                html += '</div>';
                html += '</div>';
                
                // Share Modal
                html += '<div id="luna-composer-share-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10001; align-items: center; justify-content: center;">';
                html += '<div style="background: #23212010; backdrop-filter: blur(8px); border: 1px solid #2E2C2A; border-radius: 8px; padding: 24px; max-width: 600px; width: 90%;">';
                html += '<h3 style="color: #fff4e9; margin: 0 0 20px 0; font-size: 1.25rem; font-weight: 600;">Share Document</h3>';
                
                // Main action selector (Copy Link / New Post)
                html += '<div style="margin-bottom: 20px;">';
                html += '<div style="display: flex; gap: 8px; margin-bottom: 20px;">';
                html += '<button id="luna-composer-share-action-copy" class="luna-composer-share-action-btn active" data-action="copy" onclick="window.lunaComposerSelectShareAction(\'copy\')" style="flex: 1; padding: 12px 20px; background: #2E2C2A; border: 1px solid #5A5753; color: #fff4e9; border-radius: 6px; cursor: pointer; font-size: 0.875rem; font-weight: 600; transition: all 0.2s ease;">Copy Link</button>';
                html += '<button id="luna-composer-share-action-post" class="luna-composer-share-action-btn" data-action="post" onclick="window.lunaComposerSelectShareAction(\'post\')" style="flex: 1; padding: 12px 20px; background: #2E2C2A50; border: 1px solid #5A575335; color: #9A9793; border-radius: 6px; cursor: pointer; font-size: 0.875rem; font-weight: 600; transition: all 0.2s ease;">New Post</button>';
                html += '</div>';
                
                // Copy Link section (default visible)
                html += '<div id="luna-composer-share-copy-section" style="display: block;">';
                html += '<div style="margin-bottom: 16px; padding: 12px; background: #00000050; border: 1px solid #2E2C2A; border-radius: 6px;">';
                html += '<span style="color: #9A9793; font-size: 0.875rem;">Anyone with a link can view and download</span>';
                html += '</div>';
                html += '<div style="margin-bottom: 20px;">';
                html += '<label style="display: block; color: #fff4e9; margin-bottom: 8px; font-size: 0.875rem; font-weight: 600;">Share Link:</label>';
                html += '<div style="display: flex; gap: 8px;">';
                html += '<input type="text" id="luna-composer-share-link-input" readonly style="flex: 1; padding: 10px; background: #000; border: 1px solid #2E2C2A; border-radius: 4px; color: #fff4e9; font-size: 0.875rem; box-sizing: border-box;" />';
                html += '<button id="luna-composer-share-copy-btn" onclick="window.lunaComposerCopyShareLink()" style="background: #fff4e9; border: 1px solid #5A5753; color: #000; padding: 10px 20px; border-radius: 4px; cursor: pointer; font-size: 0.875rem; font-weight: 600; white-space: nowrap;">Copy Link</button>';
                html += '</div>';
                html += '</div>';
                html += '</div>';
                
                // New Post section (hidden by default)
                html += '<div id="luna-composer-share-post-section" style="display: none;">';
                html += '<div style="margin-bottom: 20px;">';
                html += '<label style="display: block; color: #fff4e9; margin-bottom: 12px; font-size: 0.875rem; font-weight: 600;">Publish to:</label>';
                html += '<div style="display: flex; flex-direction: column; gap: 10px;">';
                html += '<button id="luna-composer-post-wp" onclick="window.lunaComposerCreatePost(\'wp\')" style="width: 100%; padding: 12px 20px; background: #000000; border: 1px solid #1f1d1a; color: #fff4e9; border-radius: 6px; cursor: pointer; font-size: 0.875rem; font-weight: 600; text-align: left; transition: all 0.2s ease;" onmouseover="this.style.borderColor=\'#1f1d1a\';" onmouseout="this.style.borderColor=\'#1f1d1a\';"><strong>WordPress Post (Draft)</strong><br>Creates a copy of the doc as a WordPress Post draft.</button>';
                html += '<button id="luna-composer-post-medium" onclick="window.lunaComposerCreatePost(\'medium\')" style="width: 100%; padding: 12px 20px; background: #000000; border: 1px solid #1f1d1a; color: #fff4e9; border-radius: 6px; cursor: pointer; font-size: 0.875rem; font-weight: 600; text-align: left; transition: all 0.2s ease;" onmouseover="this.style.borderColor=\'#1f1d1a\';" onmouseout="this.style.borderColor=\'#5A5753\';">Medium.com</button>';
                html += '<button id="luna-composer-post-linkedin" onclick="window.lunaComposerCreatePost(\'linkedin\')" style="width: 100%; padding: 12px 20px; background: #000000; border: 1px solid #1f1d1a; color: #fff4e9; border-radius: 6px; cursor: pointer; font-size: 0.875rem; font-weight: 600; text-align: left; transition: all 0.2s ease;" onmouseover="this.style.borderColor=\'#1f1d1a\';" onmouseout="this.style.borderColor=\'#5A5753\';">LinkedIn</button>';
                html += '</div>';
                html += '</div>';
                html += '</div>';
                
                html += '<div style="display: flex; gap: 12px; justify-content: flex-end;">';
                html += '<button onclick="window.lunaComposerCloseShareModal()" style="background: #fff4e9; border: 1px solid #fff4e9; color: #000000; font-weight:700;padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 0.875rem;">Close</button>';
                html += '</div>';
                html += '</div>';
                html += '</div>';
                
                // Add CSS for widget body hidden state
                if (!document.getElementById('vl-widget-body-hidden-style')) {
                    const style = document.createElement('style');
                    style.id = 'vl-widget-body-hidden-style';
                    style.textContent = `
                        .vl-widget-body-hidden {
                            display: none !important;
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                // Add CSS for active state
                html += '<style>';
                html += '.luna-composer-share-action-btn.active { background: linear-gradient(270deg, #974C00 0%, #8D8C00 100%) !important;color: #000 !important;border: none !important; }';
                html += '.luna-composer-share-action-btn:not(.active) { background: #2E2C2A50 !important; color: #9A9793 !important; border-color: #5A575335 !important; }';
                html += '</style>';
                
                // Find and Replace Modal
                html += '<div id="luna-composer-find-replace-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10000; align-items: center; justify-content: center;">';
                html += '<div style="background: #000000; border: 1px solid #2E2C2A; border-radius: 8px; padding: 24px; max-width: 500px; width: 90%;">';
                html += '<h3 style="color: #fff4e9; margin: 0 0 20px 0; font-size: 1.25rem;">Find and Replace</h3>';
                html += '<div style="margin-bottom: 16px;">';
                html += '<label style="display: block; color: #fff4e9; margin-bottom: 8px; font-size: 0.875rem;">Find:</label>';
                html += '<input type="text" id="luna-composer-find-text" style="width: 100%; padding: 10px; background: #000; border: 1px solid #2E2C2A; border-radius: 4px; color: #fff4e9; font-size: 0.875rem; box-sizing: border-box;" />';
                html += '</div>';
                html += '<div style="margin-bottom: 20px;">';
                html += '<label style="display: block; color: #fff4e9; margin-bottom: 8px; font-size: 0.875rem;">Replace with:</label>';
                html += '<input type="text" id="luna-composer-replace-text" style="width: 100%; padding: 10px; background: #000; border: 1px solid #2E2C2A; border-radius: 4px; color: #fff4e9; font-size: 0.875rem; box-sizing: border-box;" />';
                html += '</div>';
                html += '<div style="display: flex; gap: 12px; justify-content: flex-end;">';
                html += '<button onclick="window.lunaComposerCloseFindReplace()" style="background: #2E2C2A; border: 1px solid #5A5753; color: #fff4e9; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 0.875rem;">Cancel</button>';
                html += '<button onclick="window.lunaComposerExecuteFindReplace()" style="background: #fff4e9; border: 1px solid #5A5753; color: #000; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 0.875rem; font-weight: 400;">Replace All</button>';
                html += '</div>';
                html += '</div>';
                html += '</div>';
                
                const pageContentEl = document.getElementById('vlPageContent');
                if (pageContentEl) {
                    console.log('[Luna Composer] Setting innerHTML, length:', html.length);
                    pageContentEl.innerHTML = html;
                    
                    // Create separate prompt-container widget above History widget
                    const rightSidebar = document.querySelector('.vl-right-sidebar');
                    if (rightSidebar) {
                        // Create a new widget for prompts (category selector and canned section)
                        if (categorySelectorHTML || cannedSectionHTML) {
                            // Check if prompt widget already exists
                            let promptWidget = rightSidebar.querySelector('#lunaComposerPromptWidget');
                            
                            if (!promptWidget) {
                                // Create new widget
                                promptWidget = document.createElement('div');
                                promptWidget.className = 'vl-widget vl-widget-activity';
                                promptWidget.id = 'lunaComposerPromptWidget';
                                promptWidget.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
                                
                                promptWidget.innerHTML = `
                                    <div class="vl-widget-header">
                                        <h3>Saved Prompts</h3>
                                    </div>
                                    <div class="vl-widget-body prompt-container">
                                    </div>
                                `;
                                
                                // Insert before History widget
                                const historyWidget = rightSidebar.querySelector('#recentActivityWidget');
                                if (historyWidget) {
                                    rightSidebar.insertBefore(promptWidget, historyWidget);
                                } else {
                                    rightSidebar.appendChild(promptWidget);
                                }
                            }
                            
                            // Add category selector and canned section to prompt-container
                            const promptContainer = promptWidget.querySelector('.prompt-container');
                            if (promptContainer) {
                                promptContainer.innerHTML = categorySelectorHTML + cannedSectionHTML;
                            }
                        }
                        
                        console.log('[Luna Composer] Created separate prompt widget above History widget');
                    }
                    
                    let highlightTooltip = document.getElementById('luna-composer-highlight-tooltip');
                    if (!highlightTooltip) {
                        highlightTooltip = document.createElement('div');
                        highlightTooltip.id = 'luna-composer-highlight-tooltip';
                        highlightTooltip.style.cssText = 'display: none; position: fixed; top: 0; left: 0; transform: translate(-50%, -100%); background: rgba(0,0,0,0.92); border: 1px solid #2E2C2A; border-radius: 6px; padding: 8px 12px; z-index: 20000; align-items: center; gap: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.35);';

                        const tooltipText = document.createElement('span');
                        tooltipText.textContent = 'Reimagine selection?';
                        tooltipText.style.cssText = 'color: #fff4e9; font-size: 0.75rem;';

                        const actionButton = document.createElement('button');
                        actionButton.id = 'luna-composer-highlight-action';
                        actionButton.textContent = 'Reimagine';
                        actionButton.style.cssText = 'background: #2E2C2A; border: none; color: #fff4e9; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.75rem; transition: background 0.2s ease;';
                        actionButton.addEventListener('mouseenter', () => {
                            actionButton.style.background = '#3A3836';
                        });
                        actionButton.addEventListener('mouseleave', () => {
                            actionButton.style.background = '#2E2C2A';
                        });

                        highlightTooltip.appendChild(tooltipText);
                        highlightTooltip.appendChild(actionButton);

                        pageContentEl.appendChild(highlightTooltip);
                    }
                    pageContentEl.style.display = 'block';
                    pageContentEl.style.visibility = 'visible';
                    pageContentEl.style.opacity = '1';
                    
                    // Ensure it's visible
                    console.log('[Luna Composer] Page content display:', pageContentEl.style.display);
                    console.log('[Luna Composer] Page content innerHTML length:', pageContentEl.innerHTML.length);
                    
                    // Initialize auto-save and history
                    setTimeout(() => {
                        initializeLunaComposerAutoSave();
                        loadLunaComposerHistory();
                        initializeCannedPromptsScroll();
                        // Initialize reimagine button state (always available now)
                        initializeLunaComposerIntelligentMode();
                        // Initialize heart icon state for current document
                        window.lunaComposerUpdateHeartState();
                    }, 100);
                } else {
                    console.error('[Luna Composer] Page content element not found!');
                }
                
            } catch (error) {
                console.error('[Luna Composer] Error rendering:', error);
                const pageContentEl = document.getElementById('vlPageContent');
                if (pageContentEl) {
                    pageContentEl.innerHTML = '<div style="padding: 40px; color: #fff4e9; text-align: center;"><h1>Error</h1><p>Failed to load Luna Composer: ' + error.message + '</p></div>';
                }
            }
        }

        // Fetch data on load - AFTER authentication is verified
        async function initializeDashboard() {
            try {
                console.log('Initializing dashboard with license key:', licenseKey);
                
                // Check if we're on the connections page - redirect to connections.html
                const urlParams = new URLSearchParams(window.location.search);
                const licenseParam = urlParams.get('license') || '';
                if (licenseParam.includes('/connections/') || licenseParam.includes('/connections')) {
                    const licenseMatch = licenseParam.match(/^([^/]+)/);
                    if (licenseMatch) {
                        const extractedLicense = licenseMatch[1];
                        // Redirect to connections.html with license key
                        window.location.href = `connections.html?license=${encodeURIComponent(extractedLicense)}`;
                        return; // Exit early, don't continue with dashboard initialization
                    }
                }
                
                // Check if we're on the Omniscient App Observatory page
                if (isOmniscientPage) {
                    
                    // Ensure page content container is visible BEFORE rendering
                    const pageContent = document.getElementById('vlPageContent');
                    if (pageContent) {
                        pageContent.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important; position: relative !important; z-index: 10 !important;';
                    }
                    
                    await renderOmniscientAppObservatory();

                    try {
                        const observatoryConstellation = await fetchConstellationData();
                        if (observatoryConstellation) {
                            console.log('[Omniscient] Loaded constellation data for sidebar widgets:', observatoryConstellation);
                            constellationData = observatoryConstellation;
                        }
                    } catch (constellationError) {
                        console.error('[Omniscient] Failed to load constellation data for sidebar widgets:', constellationError);
                    }

                    try {
                        await updateSuperclusterSummary();
                    } catch (summaryError) {
                        console.error('[Omniscient] Unable to update Supercluster summary:', summaryError);
                    }

                    // Load recent activity in background (non-blocking)
                    loadRecentActivity().catch(activityError => {
                        console.error('[Omniscient] Unable to load recent activity:', activityError);
                    });
                    
                    // Additional safeguard after rendering
                    setTimeout(() => {
                        const overlay = document.querySelector('.vl-supercluster-overlay');
                        const header = document.querySelector('.vl-header');
                        const mainMenu = document.querySelector('.vl-main-menu');
                        const rightSidebar = document.querySelector('.vl-right-sidebar');
                        const pageContentEl = document.getElementById('vlPageContent');
                        const rootContainerEl = document.getElementById('vlSuperclusterRoot');
                        
                        
                        if (overlay) {
                            overlay.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
                        }
                        if (header) {
                            header.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
                        }
                        if (mainMenu) {
                            mainMenu.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
                        }
                        if (rightSidebar) {
                            rightSidebar.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
                        }
                        if (pageContentEl) {
                            pageContentEl.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important; position: relative !important; z-index: 10 !important;';
                        }
                    }, 100);
                    
                    // Continue checking periodically
                    setTimeout(() => {
                        const pageContentEl = document.getElementById('vlPageContent');
                        const rootContainerEl = document.getElementById('vlSuperclusterRoot');
                        if (pageContentEl && (pageContentEl.style.display === 'none' || window.getComputedStyle(pageContentEl).display === 'none')) {
                            console.warn('[Omniscient] Page content was hidden, restoring');
                            pageContentEl.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important; position: relative !important; z-index: 10 !important;';
                        }
                    }, 500);
                    
                    return;
                }
                
                // Check if we're on a shared Luna Composer page
                if (isSharedComposePage && sharedDocumentId) {
                    await renderSharedLunaComposer(sharedDocumentId);
                    return;
                }
                
                // Check if we're on the Luna Composer page
                if (isLunaComposePage) {
                    // Hide Luna widget overlay if it exists (from the widget JS) - but keep the container visible
                    const lunaOverlay = document.querySelector('.luna-overlay');
                    if (lunaOverlay) {
                        lunaOverlay.style.display = 'none';
                    }
                    // Ensure the Luna widget container is visible and functional
                    const lunaContainer = document.getElementById('vlLunaChatContainer');
                    if (lunaContainer) {
                        lunaContainer.style.display = 'block';
                        lunaContainer.style.visibility = 'visible';
                        lunaContainer.style.opacity = '1';
                    }
                    await renderLunaComposer();
                    
                    // Initialize prompt form functionality
                    setTimeout(() => {
                        initializePromptForm();
                    }, 500);
                    
                    // Load Luna Widget after composer is rendered
                    setTimeout(() => {
                        if (typeof checkAndLoadLunaWidget === 'function') {
                            checkAndLoadLunaWidget();
                        }
                    }, 500);
                    return;
                }
                
                // Show Supercluster root and hide page content (default state)
                // Only do this if NOT on Omniscient page
                if (!isOmniscientPage) {
                const rootContainer = document.getElementById('vlSuperclusterRoot');
                const pageContent = document.getElementById('vlPageContent');
                if (rootContainer) {
                    rootContainer.style.display = 'block';
                    // Ensure canvas is visible on main dashboard
                    const canvasElements = rootContainer.querySelectorAll('canvas');
                    canvasElements.forEach(canvas => {
                        const isThreeJSCanvas = canvas.getAttribute('data-engine') === 'three.js r180' || 
                                               canvas.getAttribute('data-engine')?.includes('three.js') ||
                                               (!canvas.getAttribute('data-engine') && canvasElements.length === 1);
                        if (isThreeJSCanvas) {
                            // Force canvas to be visible on main dashboard
                            canvas.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important; pointer-events: auto !important; z-index: auto !important;';
                        }
                    });
                    // Ensure labels are visible on main dashboard
                    hideSuperclusterLabels(); // This will ensure labels are visible on main dashboard
                }
                if (pageContent) {
                    pageContent.style.display = 'none';
                    }
                }
                
                // Check for category page URL
                if (checkUrlForCategoryPage()) {
                    // Category page is being rendered, exit early
                    return;
                }
                
                // Check for stream data page URL - if found, render that instead of dashboard
                if (checkUrlForStreamDataPage()) {
                    // Stream data page is being rendered, exit early
                    return;
                }
                
                // On main dashboard (not a category or stream page), ensure canvas and labels are visible
                // This is a safeguard to ensure the Three.js canvas and labels display on the main Supercluster page
                setTimeout(() => {
                    const rootContainer = document.getElementById('vlSuperclusterRoot');
                    if (rootContainer) {
                        const canvasElements = rootContainer.querySelectorAll('canvas');
                        canvasElements.forEach(canvas => {
                            const isThreeJSCanvas = canvas.getAttribute('data-engine') === 'three.js r180' || 
                                                   canvas.getAttribute('data-engine')?.includes('three.js') ||
                                                   (!canvas.getAttribute('data-engine') && canvasElements.length === 1);
                            if (isThreeJSCanvas) {
                                const computedDisplay = window.getComputedStyle(canvas).display;
                                if (computedDisplay === 'none') {
                                    console.log('[Supercluster] Canvas was hidden, restoring visibility on main dashboard');
                                    canvas.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important; pointer-events: auto !important; z-index: auto !important;';
                                }
                            }
                        });
                        // Ensure labels are visible on main dashboard
                        hideSuperclusterLabels(); // This will ensure labels are visible on main dashboard
                    }
                }, 1000); // Wait 1 second to ensure Three.js has initialized
                
                // Update license key display immediately
                updateLicenseKeyDisplay();
                
                // Fetch constellation data for this client's license
                const data = await fetchConstellationData();
            console.log('Constellation data loaded:', data);
            constellationData = data;
            updateVerificationPanel(data, dataFetchError);
                
            // ALWAYS attempt to update with real data
            if (data && data.clients && data.clients.length > 0) {
                    // Use the client data that matches the license (should be first/only one after filtering)
                    const clientData = data.clients[0];
                    console.log('Updating galaxy with client data:', clientData);
                    // Only update galaxy data if it's initialized (three.js scene is ready)
                    if (typeof galaxyData !== 'undefined' && galaxyData && Array.isArray(galaxyData)) {
                    updateGalaxyDataWithRealData(clientData);
                    } else {
                        console.warn('[Supercluster] galaxyData not yet initialized, will update when scene is ready');
                    }
                } else {
                    // No data available - show error message
                    const errorMsg = 'error: no data able to populate your Supercluster';
                    console.error(errorMsg);
                    const debugEl = document.getElementById('debugInfo');
                    if (debugEl) {
                        debugEl.innerHTML = `<span style="color: #f85149;">${errorMsg}</span>`;
                    }
                    updateDebugInfo(errorMsg);
                }
                    
                // Load supercluster summary and recent activity (always call these, even if no client data)
                    await updateSuperclusterSummary();
                    // Load recent activity in background (non-blocking)
                    loadRecentActivity().catch(err => {
                        console.warn('[Dashboard] Activity load error (non-critical):', err);
                    });
                
            // Refresh client name with new data
            await refreshClientName();
                
                // Update license key display again after data is loaded
                updateLicenseKeyDisplay();
                
            } catch (error) {
                console.error('Failed to initialize dashboard:', error);
                dataFetchError = error.message;
            // Still try to refresh client name in case we have cached data
            await refreshClientName();
                // Still try to load widgets even if there's an error
                try {
                    await updateSuperclusterSummary();
                } catch (widgetError) {
                    console.error('Failed to load supercluster summary:', widgetError);
                }
                // Load recent activity in background (non-blocking)
                loadRecentActivity().catch(err => {
                    console.warn('[Dashboard] Activity load error (non-critical):', err);
                });
                updateLicenseKeyDisplay();
            }
        }
        
        // Initialize dashboard after authentication (skip for shared documents)
        if (!isSharedComposePage) {
        initializeDashboard().then(() => {
            // Initialize VL Overlay after dashboard is ready
            initializeVLOverlay();
        }).catch(err => {
            console.error('Dashboard initialization failed:', err);
            // Still try to initialize overlay even if dashboard fails
            initializeVLOverlay();
        });
        }

        // REMOVED: Periodic data refresh to prevent interference with Luna Composer
        // Data will only refresh on manual page reload or user-initiated actions

        const rootContainer = document.getElementById("vlSuperclusterRoot") || document.body;
        const htmlElement = document.documentElement;
        const bodyElement = document.body;
        const scrollLockClass = "vl-supercluster-scroll-lock";



        function createSoftParticleTexture(size = 256) {
            const canvas = document.createElement("canvas");
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext("2d");
            const half = size / 2;
            const gradient = context.createRadialGradient(half, half, 0, half, half, half);
            gradient.addColorStop(0, "rgba(255, 255, 255, 1)");
            gradient.addColorStop(0.35, "rgba(255, 255, 255, 0.75)");
            gradient.addColorStop(1, "rgba(255, 255, 255, 0)");
            context.fillStyle = gradient;
            context.fillRect(0, 0, size, size);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            texture.colorSpace = THREE.SRGBColorSpace;
            return texture;
        }

        function createNebulaTexture(size = 512) {
            const canvas = document.createElement("canvas");
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext("2d");
            context.clearRect(0, 0, size, size);
            const center = size / 2;
            
            // Your brand colors
            const brandColors = ['#920101', '#1f1d1a', '#974C00'];
            const selectedColor = brandColors[Math.floor(Math.random() * brandColors.length)];
            
            // Convert hex to RGB for opacity variations
            const hex = selectedColor.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);

            const baseGradient = context.createRadialGradient(center, center, size * 0.1, center, center, center);
            baseGradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.75)`);
            baseGradient.addColorStop(0.35, `rgba(${r}, ${g}, ${b}, 0.55)`);
            baseGradient.addColorStop(0.6, `rgba(${r}, ${g}, ${b}, 0.32)`);
            baseGradient.addColorStop(1, "rgba(0, 0, 0, 0)");
            context.fillStyle = baseGradient;
            context.fillRect(0, 0, size, size);

            const shardCount = 8 + Math.floor(Math.random() * 6);
            for (let i = 0; i < shardCount; i++) {
                const shardX = center + (Math.random() - 0.5) * size * 0.55;
                const shardY = center + (Math.random() - 0.5) * size * 0.35;
                const shardRadius = size * (0.08 + Math.random() * 0.14);
                const shardGradient = context.createRadialGradient(
                    shardX,
                    shardY,
                    shardRadius * 0.2,
                    shardX,
                    shardY,
                    shardRadius
                );
                shardGradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.65)`);
                shardGradient.addColorStop(0.55, `rgba(${r}, ${g}, ${b}, 0.35)`);
                shardGradient.addColorStop(1, "rgba(0, 0, 0, 0)");
                context.fillStyle = shardGradient;
                context.beginPath();
                context.arc(shardX, shardY, shardRadius, 0, Math.PI * 2);
                context.fill();
            }

            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            texture.colorSpace = THREE.SRGBColorSpace;
            return texture;
        }

        // Create dust-like galaxy cloud texture
        function createGalaxyCloudTexture(size = 512, baseColor, uniqueColor) {
            const canvas = document.createElement("canvas");
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext("2d");
            context.clearRect(0, 0, size, size);
            const center = size / 2;
            
            // Convert colors to RGB
            const baseR = Math.floor(baseColor.r * 255);
            const baseG = Math.floor(baseColor.g * 255);
            const baseB = Math.floor(baseColor.b * 255);
            
            const uniqueR = Math.floor(uniqueColor.r * 255);
            const uniqueG = Math.floor(uniqueColor.g * 255);
            const uniqueB = Math.floor(uniqueColor.b * 255);
            
            // Create multiple overlapping dust clouds
            const cloudCount = 12 + Math.floor(Math.random() * 8);
            for (let i = 0; i < cloudCount; i++) {
                const cloudX = center + (Math.random() - 0.5) * size * 0.7;
                const cloudY = center + (Math.random() - 0.5) * size * 0.7;
                const cloudRadius = size * (0.15 + Math.random() * 0.25);
                
                // Mix base and unique colors for each cloud
                const mixFactor = Math.random();
                const r = Math.floor(baseR * (1 - mixFactor) + uniqueR * mixFactor);
                const g = Math.floor(baseG * (1 - mixFactor) + uniqueG * mixFactor);
                const b = Math.floor(baseB * (1 - mixFactor) + uniqueB * mixFactor);
                
                // Create dust-like gradient with noise
                const cloudGradient = context.createRadialGradient(
                    cloudX,
                    cloudY,
                    cloudRadius * 0.1,
                    cloudX,
                    cloudY,
                    cloudRadius
                );
                cloudGradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${0.15 + Math.random() * 0.1})`);
                cloudGradient.addColorStop(0.3, `rgba(${r}, ${g}, ${b}, ${0.08 + Math.random() * 0.08})`);
                cloudGradient.addColorStop(0.6, `rgba(${r}, ${g}, ${b}, ${0.04 + Math.random() * 0.04})`);
                cloudGradient.addColorStop(1, "rgba(0, 0, 0, 0)");
                
                context.fillStyle = cloudGradient;
                context.beginPath();
                context.arc(cloudX, cloudY, cloudRadius, 0, Math.PI * 2);
                context.fill();
                
                // Add finer dust particles
                const dustCount = 20 + Math.floor(Math.random() * 15);
                for (let j = 0; j < dustCount; j++) {
                    const dustX = cloudX + (Math.random() - 0.5) * cloudRadius * 1.5;
                    const dustY = cloudY + (Math.random() - 0.5) * cloudRadius * 1.5;
                    const dustRadius = cloudRadius * (0.05 + Math.random() * 0.15);
                    const dustAlpha = 0.02 + Math.random() * 0.06;
                    
                    const dustGradient = context.createRadialGradient(
                        dustX,
                        dustY,
                        0,
                        dustX,
                        dustY,
                        dustRadius
                    );
                    dustGradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${dustAlpha})`);
                    dustGradient.addColorStop(1, "rgba(0, 0, 0, 0)");
                    
                    context.fillStyle = dustGradient;
                    context.beginPath();
                    context.arc(dustX, dustY, dustRadius, 0, Math.PI * 2);
                    context.fill();
                }
            }
            
            // Add subtle noise for dust texture
            const imageData = context.getImageData(0, 0, size, size);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                if (data[i + 3] > 0) {
                    const noise = (Math.random() - 0.5) * 0.1;
                    data[i] = Math.max(0, Math.min(255, data[i] + noise * 255));
                    data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise * 255));
                    data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise * 255));
                }
            }
            context.putImageData(imageData, 0, 0);
            
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            texture.colorSpace = THREE.SRGBColorSpace;
            return texture;
        }

        // Create finer dust particle texture
        function createDustParticleTexture(size = 128) {
            const canvas = document.createElement("canvas");
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext("2d");
            const half = size / 2;
            const gradient = context.createRadialGradient(half, half, 0, half, half, half);
            gradient.addColorStop(0, "rgba(255, 255, 255, 0.8)");
            gradient.addColorStop(0.4, "rgba(255, 255, 255, 0.4)");
            gradient.addColorStop(1, "rgba(255, 255, 255, 0)");
            context.fillStyle = gradient;
            context.fillRect(0, 0, size, size);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            texture.colorSpace = THREE.SRGBColorSpace;
            return texture;
        }

        const baseParticleTexture = createSoftParticleTexture();
        const dustParticleTexture = createDustParticleTexture();

            // Only initialize three.js scene if NOT on Omniscient App Observatory page or Luna Composer page
            let scene, renderer, camera, controls, superclusterGroup;
            
            if (!isOmniscientPage && !isLunaComposePage) {
            scene = new THREE.Scene();
        scene.background = new THREE.Color(0x02040a);
        scene.fog = new THREE.FogExp2(0x040714, 0.00035);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.12;
            rootContainer.insertBefore(renderer.domElement, rootContainer.firstChild || null);

            camera = new THREE.PerspectiveCamera(52, window.innerWidth / window.innerHeight, 0.1, 1500);
        camera.position.set(0, 120, 800); // Start at maximum zoom-out distance

            controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 120;
        controls.maxDistance = 800;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.18;
        controls.enablePan = false;
        
        // Set the target to center on the supercluster (0, 0, 0)
        controls.target.set(0, 0, 0);
        controls.update();

            superclusterGroup = new THREE.Group();
        superclusterGroup.name = 'superclusterGroup';
        scene.add(superclusterGroup);

        const atmosphereShell = new THREE.Mesh(
            new THREE.SphereGeometry(1400, 64, 64),
            new THREE.MeshBasicMaterial({
                color: 0x060b18,
                transparent: true,
                opacity: 0.42,
                side: THREE.BackSide,
                depthWrite: false,
                blending: THREE.AdditiveBlending,
            })
        );
        scene.add(atmosphereShell);

        const nebulaGroup = new THREE.Group();
        superclusterGroup.add(nebulaGroup);
        const nebulaClouds = [];

        function seedNebulaClouds() {
            nebulaGroup.clear();
            nebulaClouds.length = 0;
            const cloudCount = 7 + Math.floor(Math.random() * 3);
            for (let i = 0; i < cloudCount; i++) {
                const nebulaTexture = createNebulaTexture();
                const geometry = new THREE.PlaneGeometry(420 + Math.random() * 260, 280 + Math.random() * 180, 1, 1);
                const material = new THREE.MeshBasicMaterial({
                    map: nebulaTexture,
                    transparent: true,
                    opacity: 0.24 + Math.random() * 0.18,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    depthTest: false,
                    side: THREE.DoubleSide,
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set((Math.random() - 0.5) * 420, (Math.random() - 0.5) * 260, (Math.random() - 0.5) * 420);
                mesh.rotation.set(
                    Math.PI / 2 + (Math.random() - 0.5) * 0.6,
                    (Math.random() - 0.5) * 0.9,
                    (Math.random() - 0.5) * 0.6
                );
                mesh.userData = {
                    baseOpacity: material.opacity,
                    basePosition: mesh.position.clone(),
                    drift: new THREE.Vector3((Math.random() - 0.5) * 26, (Math.random() - 0.5) * 18, (Math.random() - 0.5) * 26),
                    rotationSpeed: 0.00008 + Math.random() * 0.00018,
                    phaseOffset: Math.random() * Math.PI * 2,
                };
                nebulaGroup.add(mesh);
                nebulaClouds.push(mesh);
            }
        }

        seedNebulaClouds();

        // Declare galaxyData globally so it's accessible to updateGalaxyDataWithRealData
        if (typeof galaxyData === 'undefined') {
            var galaxyData = [];
        }
        
        galaxyData = [
            {
                name: "Website Infrastructure & Performance",
                datasetSlugs: ["infrastructure", "themes", "operations"],
                fallbackDescription:
                    "Optimize delivery, resiliency, and user experience with infrastructure telemetry spanning uptime, performance, and observability signals.",
                description: "",
                position: new THREE.Vector3(-220, 60, -140),
                color: "#6fb1ff",
                connections: ["Content Management & Structure", "Analytics & Engagement"],
            },
            {
                name: "Content Management & Structure",
                datasetSlugs: ["content", "structure"],
                fallbackDescription:
                    "Govern editorial pipelines, asset taxonomies, and omnichannel orchestration to keep experiences coherent across platforms.",
                description: "",
                position: new THREE.Vector3(-80, 20, 60),
                color: "#ff9cf0",
                connections: ["Website Infrastructure & Performance", "Search Engine Intelligence", "Marketing & Campaign Data"],
            },
            {
                name: "Search Engine Intelligence",
                datasetSlugs: ["ai", "search", "integrations"],
                fallbackDescription:
                    "Harvest crawl signals, SERP movement, and algorithmic shifts to ensure content is discoverable and performant.",
                description: "",
                position: new THREE.Vector3(40, 140, -60),
                color: "#83f3ff",
                connections: ["Content Management & Structure", "Analytics & Engagement", "Competitive & Market Data"],
            },
            {
                name: "Analytics & Engagement",
                datasetSlugs: ["sessions", "analytics", "engagement"],
                fallbackDescription:
                    "Synthesize behavioral analytics, funnel friction, and feedback loops to illuminate experience optimization opportunities.",
                description: "",
                position: new THREE.Vector3(160, 40, 120),
                color: "#ffe699",
                connections: ["Website Infrastructure & Performance", "Search Engine Intelligence", "Marketing & Campaign Data", "User & Identity Layer"],
            },
            {
                name: "Marketing & Campaign Data",
                datasetSlugs: ["integrations", "marketing", "campaigns"],
                fallbackDescription:
                    "Unify campaign performance, attribution modeling, and creative intelligence to amplify revenue-driving initiatives.",
                description: "",
                position: new THREE.Vector3(260, -20, -80),
                color: "#d9a6ff",
                connections: ["Content Management & Structure", "Analytics & Engagement", "E-Commerce & Conversion Data"],
            },
            {
                name: "E-Commerce & Conversion Data",
                datasetSlugs: ["plugins", "commerce", "ecommerce"],
                fallbackDescription:
                    "Map product analytics, merchandising flows, and conversion health to reveal revenue acceleration pathways.",
                description: "",
                position: new THREE.Vector3(-40, -120, -40),
                color: "#ff6b6b",
                connections: ["Marketing & Campaign Data", "User & Identity Layer", "Security & Compliance Data"],
            },
            {
                name: "Security & Compliance Data",
                datasetSlugs: ["security", "compliance"],
                fallbackDescription:
                    "Monitor threat detection, governance policies, and regulatory controls to keep the data supply chain secure.",
                description: "",
                position: new THREE.Vector3(-200, -40, 150),
                color: "#9dffb0",
                connections: ["CloudOps & Infrastructure Metrics", "E-Commerce & Conversion Data"],
            },
            {
                name: "CloudOps & Infrastructure Metrics",
                datasetSlugs: ["themes", "infrastructure", "cloudops"],
                fallbackDescription:
                    "Observe deployment velocity, cost efficiency, and platform reliability to ensure modern operations excellence.",
                description: "",
                position: new THREE.Vector3(100, -180, 60),
                color: "#ffc7a5",
                connections: ["Security & Compliance Data", "Website Infrastructure & Performance"],
            },
            {
                name: "User & Identity Layer",
                datasetSlugs: ["identity", "users"],
                fallbackDescription:
                    "Understand identity graphs, access journeys, and consent preferences to personalize experiences responsibly.",
                description: "",
                position: new THREE.Vector3(-280, 160, 60),
                color: "#7f9bff",
                connections: ["Analytics & Engagement", "E-Commerce & Conversion Data", "Competitive & Market Data"],
            },
            {
                name: "Competitive & Market Data",
                datasetSlugs: ["users", "market", "competitive"],
                fallbackDescription:
                    "Track competitive shifts, market momentum, and whitespace detection to guide strategic positioning.",
                description: "",
                position: new THREE.Vector3(60, -40, 220),
                color: "#9bffe7",
                connections: ["Search Engine Intelligence", "User & Identity Layer"],
            },
        ];

        galaxyData.forEach((entry) => {
            entry.slug = entry.datasetSlugs[0];
            entry.description = entry.fallbackDescription;
            entry.metrics = null;
        });

        const galaxyGroups = new Map();

        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        const tempWorldPosition = new THREE.Vector3();
        const projectedPosition = new THREE.Vector3();
        const cameraDirection = new THREE.Vector3();
        const panRight = new THREE.Vector3();
        const zoomOffset = new THREE.Vector3();

        // Only create labels container if NOT on Luna Composer page
        let labelsContainer = null;
        if (!isLunaComposePage) {
            labelsContainer = document.createElement("div");
        labelsContainer.className = "vl-supercluster-labels";
            rootContainer.appendChild(labelsContainer);
        }

        // Label creation removed - galaxies are now interactive based on stream data
        // function createLabel(name) { ... }

        // Map VL Hub categories to galaxy names
        const categoryToGalaxyMap = {
            'content': 'Content Management & Structure',
            'cms': 'Content Management & Structure',
            'infrastructure': 'Website Infrastructure & Performance',
            'web-infra': 'Website Infrastructure & Performance',
            'search': 'Search Engine Intelligence',
            'search-intel': 'Search Engine Intelligence',
            'ai': 'Search Engine Intelligence',
            'analytics': 'Analytics & Engagement',
            'reporting': 'Analytics & Engagement',
            'sessions': 'Analytics & Engagement',
            'engagement': 'Analytics & Engagement',
            'marketing': 'Marketing & Campaign Data',
            'marketing-ads': 'Marketing & Campaign Data',
            'campaigns': 'Marketing & Campaign Data',
            'ecommerce': 'E-Commerce & Conversion Data',
            'commerce': 'E-Commerce & Conversion Data',
            'security': 'Security & Compliance Data',
            'security-compliance': 'Security & Compliance Data',
            'compliance': 'Security & Compliance Data',
            'cloudops': 'CloudOps & Infrastructure Metrics',
            'identity': 'User & Identity Layer',
            'user-identity': 'User & Identity Layer',
            'users': 'User & Identity Layer',
            'competitive': 'Competitive & Market Data',
            'market': 'Competitive & Market Data'
        };
        
        // Function to create a planet (connection) in a galaxy
        function createPlanet(galaxyGroup, connectionId, connectionName, position, color, index, totalConnections) {
            const planetGroup = new THREE.Group();
            
            // Calculate position in a circular orbit around galaxy center
            const angle = (index / totalConnections) * Math.PI * 2;
            const orbitRadius = 45 + Math.random() * 25; // Distance from galaxy center
            const x = Math.cos(angle) * orbitRadius;
            const z = Math.sin(angle) * orbitRadius;
            const y = (Math.random() - 0.5) * 15; // Slight vertical variation
            
            planetGroup.position.set(x, y, z);
            
            // Planet sphere (connection)
            const planetSize = 3.5 + Math.random() * 1.5;
            const planetGeometry = new THREE.SphereGeometry(planetSize, 32, 32);
            const planetMaterial = new THREE.MeshPhongMaterial({
                color: color,
                emissive: color.clone().multiplyScalar(0.6),
                shininess: 100,
                specular: 0xffffff,
            });
            planetMaterial.emissiveIntensity = 1.2;
            const planet = new THREE.Mesh(planetGeometry, planetMaterial);
            planetGroup.add(planet);
            
            // Planet glow
            const glowGeometry = new THREE.SphereGeometry(planetSize * 1.8, 32, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.3,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide,
                depthWrite: false,
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            planetGroup.add(glow);
            
            planetGroup.userData = {
                type: 'planet',
                connectionId: connectionId,
                connectionName: connectionName,
                planet: planet,
                glow: glow,
                moons: [], // Array to store moon objects
                moonGroups: new Map(), // Map of stream ID to moon group
            };
            
            galaxyGroup.add(planetGroup);
            return planetGroup;
        }
        
        // Function to create a moon (stream) orbiting a planet
        function createMoon(planetGroup, streamId, streamName, index, totalStreams) {
            const moonGroup = new THREE.Group();
            
            // Calculate orbit around planet
            const angle = (index / totalStreams) * Math.PI * 2;
            const orbitRadius = 8 + Math.random() * 4;
            const x = Math.cos(angle) * orbitRadius;
            const z = Math.sin(angle) * orbitRadius;
            const y = (Math.random() - 0.5) * 3;
            
            moonGroup.position.set(x, y, z);
            
            // Moon sphere (stream) - smaller than planet
            const moonSize = 1.2 + Math.random() * 0.8;
            const moonGeometry = new THREE.SphereGeometry(moonSize, 16, 16);
            const moonColor = planetGroup.children[0].material.color.clone().lerp(new THREE.Color(0xffffff), 0.4);
            const moonMaterial = new THREE.MeshPhongMaterial({
                color: moonColor,
                emissive: moonColor.clone().multiplyScalar(0.5),
                shininess: 80,
            });
            moonMaterial.emissiveIntensity = 1.0;
            const moon = new THREE.Mesh(moonGeometry, moonMaterial);
            moonGroup.add(moon);
            
            // Moon glow
            const moonGlowGeometry = new THREE.SphereGeometry(moonSize * 1.5, 16, 16);
            const moonGlowMaterial = new THREE.MeshBasicMaterial({
                color: moonColor,
                transparent: true,
                opacity: 0.25,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide,
                depthWrite: false,
            });
            const moonGlow = new THREE.Mesh(moonGlowGeometry, moonGlowMaterial);
            moonGroup.add(moonGlow);
            
            moonGroup.userData = {
                type: 'moon',
                streamId: streamId,
                streamName: streamName,
                moon: moon,
                glow: moonGlow,
                orbitSpeed: 0.01 + Math.random() * 0.01,
                orbitAngle: angle,
                orbitRadius: orbitRadius,
            };
            
            planetGroup.add(moonGroup);
            planetGroup.userData.moons.push(moonGroup);
            planetGroup.userData.moonGroups.set(streamId, moonGroup);
            return moonGroup;
        }

        function createGalaxy({ name, position, color }) {
            const group = new THREE.Group();
            group.position.copy(position);

            const baseColor = new THREE.Color(color);
            const highlightColor = baseColor.clone().lerp(new THREE.Color(0xffffff), 0.35);
            const coreColor = baseColor.clone().lerp(new THREE.Color(0xffffcc), 0.4);

            // Central core/bulge - brighter and more defined
            const coreGeometry = new THREE.SphereGeometry(8.5, 64, 64);
            const coreMaterial = new THREE.MeshPhongMaterial({
                color: coreColor,
                emissive: baseColor.clone().multiplyScalar(0.75),
                shininess: 180,
                specular: 0xffffff,
            });
            coreMaterial.emissiveIntensity = 1.4;
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            group.add(core);

            // Extended halo around core - more subtle glow
            const haloGeometry = new THREE.SphereGeometry(32, 64, 64);
            const haloMaterial = new THREE.MeshBasicMaterial({
                color: highlightColor,
                transparent: true,
                opacity: 0.18,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide,
                depthWrite: false,
            });
            const halo = new THREE.Mesh(haloGeometry, haloMaterial);
            group.add(halo);

            // Additional subtle glow layers
            const halo2Geometry = new THREE.SphereGeometry(40, 64, 64);
            const halo2Material = new THREE.MeshBasicMaterial({
                color: highlightColor,
                transparent: true,
                opacity: 0.12,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide,
                depthWrite: false,
            });
            const halo2 = new THREE.Mesh(halo2Geometry, halo2Material);
            group.add(halo2);
            
            const halo3Geometry = new THREE.SphereGeometry(50, 64, 64);
            const halo3Material = new THREE.MeshBasicMaterial({
                color: baseColor,
                transparent: true,
                opacity: 0.08,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide,
                depthWrite: false,
            });
            const halo3 = new THREE.Mesh(halo3Geometry, halo3Material);
            group.add(halo3);

            // Replace oval discs with prominent galaxy clouds - unique colors per galaxy
            const uniqueColorHue = Math.random() * 0.3 + 0.5; // Vary hue slightly
            const uniqueColor = new THREE.Color().setHSL(uniqueColorHue, 0.4 + Math.random() * 0.3, 0.5 + Math.random() * 0.3);
            const cloudTexture1 = createGalaxyCloudTexture(512, baseColor, uniqueColor);
            
            // Main galactic cloud - more prominent and dust-like
            const cloudGeometry1 = new THREE.PlaneGeometry(90, 90, 1, 1);
            const cloudMaterial1 = new THREE.MeshBasicMaterial({
                map: cloudTexture1,
                transparent: true,
                opacity: 0.35,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide,
                depthWrite: false,
            });
            const cloud1 = new THREE.Mesh(cloudGeometry1, cloudMaterial1);
            cloud1.rotation.x = Math.PI / 2;
            cloud1.rotation.z = Math.random() * Math.PI;
            cloud1.rotation.y = Math.random() * Math.PI * 0.3;
            group.add(cloud1);
            
            // Secondary cloud layer for depth
            const cloudTexture2 = createGalaxyCloudTexture(512, baseColor, uniqueColor);
            const cloudGeometry2 = new THREE.PlaneGeometry(110, 110, 1, 1);
            const cloudMaterial2 = new THREE.MeshBasicMaterial({
                map: cloudTexture2,
                transparent: true,
                opacity: 0.22,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide,
                depthWrite: false,
            });
            const cloud2 = new THREE.Mesh(cloudGeometry2, cloudMaterial2);
            cloud2.rotation.x = Math.PI / 2.1;
            cloud2.rotation.z = Math.random() * Math.PI;
            cloud2.rotation.y = Math.random() * Math.PI * 0.3;
            group.add(cloud2);
            
            // Outer cloud ring
            const cloudTexture3 = createGalaxyCloudTexture(512, baseColor, uniqueColor);
            const cloudGeometry3 = new THREE.PlaneGeometry(130, 130, 1, 1);
            const cloudMaterial3 = new THREE.MeshBasicMaterial({
                map: cloudTexture3,
                transparent: true,
                opacity: 0.18,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide,
                depthWrite: false,
            });
            const outerCloud = new THREE.Mesh(cloudGeometry3, cloudMaterial3);
            outerCloud.rotation.x = Math.PI / 2.15 + (Math.random() - 0.5) * 0.2;
            outerCloud.rotation.z = Math.random() * Math.PI;
            group.add(outerCloud);

            // Create realistic spiral arms - more defined and galaxy-like
            const armCount = 2 + Math.floor(Math.random() * 2); // 2-3 arms like real galaxies
            const pointsPerArm = 200;
            const swirlPositions = new Float32Array(armCount * pointsPerArm * 3);
            const swirlColors = new Float32Array(armCount * pointsPerArm * 3);
            let pointer = 0;
            let colorPointer = 0;
            
            for (let arm = 0; arm < armCount; arm++) {
                const armOffset = (Math.PI * 2 * arm) / armCount;
                const armTightness = 0.12 + Math.random() * 0.08; // Spiral tightness
                
                for (let i = 0; i < pointsPerArm; i++) {
                    const t = i / pointsPerArm;
                    // Logarithmic spiral for more realistic appearance
                    const angle = t * Math.PI * 4.2 + armOffset + Math.log(1 + t * 9) * armTightness;
                    const radius = 12 + t * 110 + Math.sin(t * Math.PI * 3) * 8; // More variation
                    const jitter = (1 - t) * 4; // Less jitter for cleaner arms
                    
                    const x = Math.cos(angle) * radius + (Math.random() - 0.5) * jitter;
                    const y = (Math.random() - 0.5) * (4 + t * 18); // Flatter disc
                    const z = Math.sin(angle) * radius + (Math.random() - 0.5) * jitter;
                    
                    swirlPositions[pointer++] = x;
                    swirlPositions[pointer++] = y;
                    swirlPositions[pointer++] = z;
                    
                    // Color gradient along arms (brighter near core)
                    const brightness = 0.6 + (1 - t) * 0.4;
                    const armColor = highlightColor.clone().multiplyScalar(brightness);
                    swirlColors[colorPointer++] = armColor.r;
                    swirlColors[colorPointer++] = armColor.g;
                    swirlColors[colorPointer++] = armColor.b;
                }
            }
            
            const swirlGeometry = new THREE.BufferGeometry();
            swirlGeometry.setAttribute("position", new THREE.BufferAttribute(swirlPositions, 3));
            swirlGeometry.setAttribute("color", new THREE.BufferAttribute(swirlColors, 3));
            
            const swirlMaterial = new THREE.PointsMaterial({
                map: baseParticleTexture,
                color: highlightColor,
                vertexColors: true,
                size: 12 + Math.random() * 4,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.65,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                depthTest: false,
                alphaTest: 0.01,
            });
            
            const swirl = new THREE.Points(swirlGeometry, swirlMaterial);
            swirl.rotation.x = Math.PI / 2.35 + (Math.random() - 0.5) * 0.12;
            swirl.userData = {
                spinSpeed: 0.00018 + Math.random() * 0.00012,
                baseOpacity: swirlMaterial.opacity,
                wobbleStrength: 0.06 + Math.random() * 0.04,
            };
            group.add(swirl);

            // More stars with varying sizes
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 1400; // Increased from 720
            const positions = new Float32Array(starCount * 3);
            const starSizes = new Float32Array(starCount);
            const starColors = new Float32Array(starCount * 3);
            
            for (let i = 0; i < starCount; i++) {
                const radius = 20 + Math.random() * 130;
                const theta = Math.random() * Math.PI * 2;
                const cosPhi = Math.random() * 2 - 1;
                const phi = Math.acos(cosPhi);
                const wobble = Math.pow(Math.random(), 2.4);
                positions[i * 3] = Math.sin(phi) * Math.cos(theta) * radius;
                positions[i * 3 + 1] = Math.sin(phi) * Math.sin(theta) * radius * (0.35 + Math.random() * 0.9);
                positions[i * 3 + 2] = Math.cos(phi) * radius;
                if (Math.random() > 0.6) {
                    positions[i * 3 + 1] *= 0.45 + wobble * 0.55;
                }
                
                // Varying star sizes
                starSizes[i] = 3 + Math.random() * 8 + Math.pow(Math.random(), 3) * 5;
                
                // Varying star colors (slightly tinted)
                const starBrightness = 0.7 + Math.random() * 0.3;
                const starColor = highlightColor.clone().lerp(new THREE.Color(0xffffff), 0.3 + Math.random() * 0.2);
                starColor.multiplyScalar(starBrightness);
                starColors[i * 3] = starColor.r;
                starColors[i * 3 + 1] = starColor.g;
                starColors[i * 3 + 2] = starColor.b;
            }

            starGeometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
            starGeometry.setAttribute("size", new THREE.BufferAttribute(starSizes, 1));
            starGeometry.setAttribute("color", new THREE.BufferAttribute(starColors, 3));

            const starMaterial = new THREE.PointsMaterial({
                map: baseParticleTexture,
                color: highlightColor.clone().lerp(new THREE.Color(0xffffff), 0.25),
                vertexColors: true,
                size: 6.5,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.65,
                depthWrite: false,
                depthTest: false,
                blending: THREE.AdditiveBlending,
            });
            const stars = new THREE.Points(starGeometry, starMaterial);
            stars.userData = { type: "galaxy", name, baseCount: starCount };
            group.add(stars);
            
            // Add finer dust-like particles
            const dustGeometry = new THREE.BufferGeometry();
            const dustCount = 800;
            const dustPositions = new Float32Array(dustCount * 3);
            const dustSizes = new Float32Array(dustCount);
            const dustColors = new Float32Array(dustCount * 3);
            
            for (let i = 0; i < dustCount; i++) {
                const radius = 15 + Math.random() * 100;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                dustPositions[i * 3] = Math.sin(phi) * Math.cos(theta) * radius;
                dustPositions[i * 3 + 1] = Math.sin(phi) * Math.sin(theta) * radius * (0.3 + Math.random() * 0.7);
                dustPositions[i * 3 + 2] = Math.cos(phi) * radius;
                
                // Smaller dust particles
                dustSizes[i] = 1.5 + Math.random() * 3;
                
                // Dust particles with unique color tint
                const dustColor = baseColor.clone().lerp(uniqueColor, 0.3 + Math.random() * 0.4);
                dustColor.multiplyScalar(0.4 + Math.random() * 0.3);
                dustColors[i * 3] = dustColor.r;
                dustColors[i * 3 + 1] = dustColor.g;
                dustColors[i * 3 + 2] = dustColor.b;
            }
            
            dustGeometry.setAttribute("position", new THREE.BufferAttribute(dustPositions, 3));
            dustGeometry.setAttribute("size", new THREE.BufferAttribute(dustSizes, 1));
            dustGeometry.setAttribute("color", new THREE.BufferAttribute(dustColors, 3));
            
            const dustMaterial = new THREE.PointsMaterial({
                map: dustParticleTexture,
                vertexColors: true,
                size: 2.5,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.35,
                depthWrite: false,
                depthTest: false,
                blending: THREE.AdditiveBlending,
            });
            const dust = new THREE.Points(dustGeometry, dustMaterial);
            dust.userData = { spinSpeed: 0.00008 + Math.random() * 0.00006 };
            group.add(dust);

            const sparkGeometry = new THREE.BufferGeometry();
            const sparkCount = 160;
            const sparkPositions = new Float32Array(sparkCount * 3);
            for (let i = 0; i < sparkCount; i++) {
                const radius = 16 + Math.random() * 42;
                const angle = Math.random() * Math.PI * 2;
                const height = (Math.random() - 0.5) * 14;
                sparkPositions[i * 3] = Math.cos(angle) * radius;
                sparkPositions[i * 3 + 1] = height;
                sparkPositions[i * 3 + 2] = Math.sin(angle) * radius;
            }
            sparkGeometry.setAttribute("position", new THREE.BufferAttribute(sparkPositions, 3));
            const sparkMaterial = new THREE.PointsMaterial({
                map: baseParticleTexture,
                color: highlightColor.clone().lerp(new THREE.Color(0xffffff), 0.5),
                size: 10,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.42,
                depthWrite: false,
                depthTest: false,
                blending: THREE.AdditiveBlending,
            });
            const sparkLayer = new THREE.Points(sparkGeometry, sparkMaterial);
            sparkLayer.rotation.x = Math.PI / 2;
            sparkLayer.userData = { spinSpeed: 0.00035 + Math.random() * 0.0002 };
            group.add(sparkLayer);

            // More realistic lighting - softer point light
            const pointLight = new THREE.PointLight(highlightColor, 2.2, 600, 2.2);
            pointLight.position.set(0, 0, 0);
            group.add(pointLight);
            
            // Additional subtle rim light
            const rimLight = new THREE.PointLight(baseColor, 0.8, 400, 1.8);
            rimLight.position.set(0, 0, 0);
            group.add(rimLight);

            // Labels removed - galaxies are now interactive based on stream data
            // const label = createLabel(name);

            galaxyGroups.set(name, {
                name,
                group,
                core,
                halo,
                halo2,
                halo3,
                stars,
                dust,
                swirl,
                sparkLayer,
                cloud1,
                cloud2,
                outerCloud,
                orbit: outerCloud, // Use outerCloud instead of orbit
                label: null, // Labels removed
                pointLight,
                rimLight,
                baseColor: baseColor.clone(),
                color: highlightColor.clone(),
                uniqueColor: uniqueColor.clone(),
                dataset: null,
                baseStarSize: starMaterial.size,
                planets: [], // Array to store planet objects (connections)
                planetGroups: new Map(), // Map of connection ID to planet group
            });
            superclusterGroup.add(group);
        }

        galaxyData.forEach(createGalaxy);
        
        // Function to fetch connections and streams by category from VL Hub
        async function fetchConnectionsAndStreams(licenseKey) {
            try {
                const response = await fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/all-connections?license=${encodeURIComponent(licenseKey)}&_t=${Date.now()}`, {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include'
                });
                
                if (!response.ok) {
                    console.error('[Supercluster] Failed to fetch connections:', response.status);
                    return null;
                }
                
                const responseData = await response.json();
                const connectionsData = responseData?.ok && responseData?.data ? responseData.data : responseData;
                
                console.log('[Supercluster] Connections data structure:', connectionsData);
                
                // Organize connections and streams by category
                const categoryData = {};
                
                // First, identify actual connections from the all-connections endpoint
                // These are top-level keys like 'ga4', 'gsc', 'wordpress_content', etc.
                const actualConnections = [];
                const connectionKeys = Object.keys(connectionsData || {});
                
                // Map connection types to categories
                connectionKeys.forEach(connKey => {
                    const connData = connectionsData[connKey];
                    if (!connData || typeof connData !== 'object') return;
                    
                    // Check if this is an active connection
                    const isActive = connData.connected === true || 
                                   connData.property_id || 
                                   connData.metrics ||
                                   (connData.total && connData.total > 0) ||
                                   (Array.isArray(connData) && connData.length > 0) ||
                                   (typeof connData === 'object' && Object.keys(connData).length > 0);
                    
                    if (isActive) {
                        // Determine category based on connection type
                        let category = null;
                        if (connKey.includes('wordpress') || connKey.includes('content') || connKey.includes('cms')) {
                            category = 'Content Management & Structure';
                        } else if (connKey.includes('ga4') || connKey.includes('analytics') || connKey.includes('sessions')) {
                            category = 'Analytics & Engagement';
                        } else if (connKey.includes('gsc') || connKey.includes('search') || connKey.includes('ai')) {
                            category = 'Search Engine Intelligence';
                        } else if (connKey.includes('security') || connKey.includes('ssl') || connKey.includes('cloudflare')) {
                            category = 'Security & Compliance Data';
                        } else if (connKey.includes('cloudops') || connKey.includes('aws') || connKey.includes('liquidweb') || connKey.includes('infrastructure')) {
                            category = 'CloudOps & Infrastructure Metrics';
                        } else if (connKey.includes('marketing') || connKey.includes('campaign')) {
                            category = 'Marketing & Campaign Data';
                        } else if (connKey.includes('ecommerce') || connKey.includes('commerce') || connKey.includes('woocommerce')) {
                            category = 'E-Commerce & Conversion Data';
                        } else if (connKey.includes('identity') || connKey.includes('users') || connKey.includes('user')) {
                            category = 'User & Identity Layer';
                        } else if (connKey.includes('competitive') || connKey.includes('competitor') || connKey.includes('market')) {
                            category = 'Competitive & Market Data';
                        } else if (connKey.includes('infrastructure') || connKey.includes('themes') || connKey.includes('performance')) {
                            category = 'Website Infrastructure & Performance';
                        }
                        
                        if (category) {
                            actualConnections.push({
                                id: connKey,
                                name: connKey.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
                                category: category,
                                data: connData
                            });
                        }
                    }
                });
                
                console.log('[Supercluster] Found actual connections:', actualConnections);
                
                // Extract streams from client_streams
                const clientStreams = connectionsData?.client_streams || {};
                const streamArray = extractActiveStreams(clientStreams);
                console.log('[Supercluster] Total streams extracted:', streamArray.length);
                
                // Process each galaxy and find matching connections/streams
                galaxyData.forEach(galaxy => {
                    const categoryKey = galaxy.name;
                    categoryData[categoryKey] = {
                        connections: [],
                        streams: []
                    };
                    
                    // Find connections that match this galaxy
                    const matchingConnections = actualConnections.filter(conn => conn.category === galaxy.name);
                    
                    // For each matching connection, find its streams
                    matchingConnections.forEach(conn => {
                        const connectionStreams = streamArray.filter(stream => {
                            // Check if stream ID or name suggests it belongs to this connection
                            const streamId = (stream.id || '').toLowerCase();
                            const streamName = (stream.name || '').toLowerCase();
                            const connId = conn.id.toLowerCase();
                            const matchesConnection = streamId.includes(connId) || 
                                                     streamName.includes(connId) ||
                                                     streamId.includes(conn.name.toLowerCase()) ||
                                                     streamName.includes(conn.name.toLowerCase());
                            
                            // If stream matches connection, check category match (but be lenient)
                            if (matchesConnection) {
                                // If stream has categories, check if they match galaxy
                                if (stream.categories && Array.isArray(stream.categories)) {
                                    const matchesGalaxy = stream.categories.some(cat => 
                                        galaxy.datasetSlugs.some(slug => 
                                            cat.toLowerCase().includes(slug.toLowerCase()) ||
                                            categoryToGalaxyMap[cat.toLowerCase()] === galaxy.name
                                        )
                                    );
                                    // If categories match, include it
                                    if (matchesGalaxy) return true;
                                }
                                // If no categories or categories don't match, still include if connection matches
                                // This ensures streams from VL Hub Profile are displayed even if categories aren't set
                                return true;
                            }
                            
                            return false;
                        });
                        
                        categoryData[categoryKey].connections.push({
                            id: conn.id,
                            name: conn.name,
                            streams: connectionStreams.map(stream => ({
                                id: stream.id || stream.stream_id || `stream_${Date.now()}_${Math.random()}`,
                                name: stream.name || stream.stream_name || 'Unnamed Stream',
                                stream: stream
                            }))
                        });
                    });
                    
                    // Also add any unmatched streams that belong to this galaxy
                    const unmatchedStreams = streamArray.filter(stream => {
                        // Check if this stream is already assigned to a connection
                        const alreadyAssigned = categoryData[categoryKey].connections.some(conn => 
                            conn.streams.some(s => s.id === stream.id)
                        );
                        
                        if (alreadyAssigned) return false;
                        
                        // If stream has categories, check if they match galaxy
                        if (stream.categories && Array.isArray(stream.categories)) {
                        const matchesGalaxy = stream.categories.some(cat => 
                            galaxy.datasetSlugs.some(slug => 
                                cat.toLowerCase().includes(slug.toLowerCase()) ||
                                categoryToGalaxyMap[cat.toLowerCase()] === galaxy.name
                            )
                        );
                            return matchesGalaxy;
                        }
                        
                        // If no categories, try to match by stream ID/name patterns
                        // This ensures streams from VL Hub Profile are displayed even without categories
                        const streamId = (stream.id || '').toLowerCase();
                        const streamName = (stream.name || '').toLowerCase();
                        const matchesByPattern = galaxy.datasetSlugs.some(slug => 
                            streamId.includes(slug.toLowerCase()) || 
                            streamName.includes(slug.toLowerCase())
                        );
                        
                        return matchesByPattern;
                    });
                    
                    // Group unmatched streams by a common identifier (e.g., stream type)
                    if (unmatchedStreams.length > 0) {
                        const unmatchedMap = new Map();
                        unmatchedStreams.forEach(stream => {
                            const streamType = stream.id?.split('_')[0] || stream.id?.split('-')[0] || 'other';
                            if (!unmatchedMap.has(streamType)) {
                                unmatchedMap.set(streamType, {
                                    id: streamType,
                                    name: streamType.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
                                    streams: []
                                });
                            }
                            unmatchedMap.get(streamType).streams.push({
                                id: stream.id || stream.stream_id || `stream_${Date.now()}_${Math.random()}`,
                                name: stream.name || stream.stream_name || 'Unnamed Stream',
                                stream: stream
                            });
                        });
                        categoryData[categoryKey].connections.push(...Array.from(unmatchedMap.values()));
                    }
                    
                    // Store all streams for this category (be lenient to ensure all streams are included)
                    categoryData[categoryKey].streams = streamArray.filter(s => {
                        // If stream has categories, check if they match galaxy
                        if (s.categories && Array.isArray(s.categories)) {
                            const matches = s.categories.some(cat => 
                            galaxy.datasetSlugs.some(slug => 
                                cat.toLowerCase().includes(slug.toLowerCase()) ||
                                categoryToGalaxyMap[cat.toLowerCase()] === galaxy.name
                            )
                            );
                            if (matches) return true;
                        }
                        
                        // If no categories or categories don't match, try pattern matching
                        // This ensures streams from VL Hub Profile are displayed even without categories
                        const streamId = (s.id || '').toLowerCase();
                        const streamName = (s.name || '').toLowerCase();
                        return galaxy.datasetSlugs.some(slug => 
                            streamId.includes(slug.toLowerCase()) || 
                            streamName.includes(slug.toLowerCase())
                        );
                    });
                    
                    console.log(`[Supercluster] ${galaxy.name}: ${categoryData[categoryKey].connections.length} connections, ${categoryData[categoryKey].streams.length} streams`);
                });
                
                return categoryData;
            } catch (error) {
                console.error('[Supercluster] Error fetching connections and streams:', error);
                return null;
            }
        }
        
        // Function to update galaxies with real connection/stream data
        async function updateGalaxiesWithRealData(licenseKey) {
            console.log('[Supercluster] updateGalaxiesWithRealData called with license:', licenseKey);
            const categoryData = await fetchConnectionsAndStreams(licenseKey);
            if (!categoryData) {
                console.error('[Supercluster] No category data returned from fetchConnectionsAndStreams');
                // Show error message to user
                const errorMsg = 'error: no data able to populate your Supercluster';
                console.error(errorMsg);
                // Try to display error in UI if possible
                const debugEl = document.getElementById('debugInfo');
                if (debugEl) {
                    debugEl.innerHTML = `<span style="color: #f85149;">${errorMsg}</span>`;
                }
                // Still continue to allow UI to render even without data
                return;
            }
            
            console.log('[Supercluster] Category data:', categoryData);
            
            galaxyData.forEach(galaxy => {
                const galaxyEntry = galaxyGroups.get(galaxy.name);
                if (!galaxyEntry) {
                    console.warn(`[Supercluster] No galaxy entry found for: ${galaxy.name}`);
                    return;
                }
                
                const data = categoryData[galaxy.name];
                if (!data || !data.connections || data.connections.length === 0) {
                    console.log(`[Supercluster] No connections for ${galaxy.name}:`, data);
                    return;
                }
                
                console.log(`[Supercluster] Updating ${galaxy.name} with ${data.connections.length} connections`);
                
                const galaxyGroup = galaxyEntry.group;
                const baseColor = galaxyEntry.baseColor;
                
                // Remove existing planets
                if (galaxyEntry.planets && galaxyEntry.planets.length > 0) {
                    galaxyEntry.planets.forEach(planetGroup => {
                        // Remove all moons first
                        if (planetGroup.userData.moons) {
                            planetGroup.userData.moons.forEach(moon => {
                                moon.traverse(child => {
                                    if (child.geometry) child.geometry.dispose();
                                    if (child.material) {
                                        if (Array.isArray(child.material)) {
                                            child.material.forEach(mat => mat.dispose());
                                        } else {
                                            child.material.dispose();
                                        }
                                    }
                                });
                                planetGroup.remove(moon);
                            });
                        }
                        // Remove planet
                        planetGroup.traverse(child => {
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(mat => mat.dispose());
                                } else {
                                    child.material.dispose();
                                }
                            }
                        });
                        galaxyGroup.remove(planetGroup);
                    });
                    galaxyEntry.planets = [];
                    galaxyEntry.planetGroups.clear();
                }
                
                // Create planets for each connection
                console.log(`[Supercluster] Creating ${data.connections.length} planets for ${galaxy.name}`);
                data.connections.forEach((connection, index) => {
                    console.log(`[Supercluster] Creating planet ${index + 1}/${data.connections.length}: ${connection.name} (${connection.streams.length} streams)`);
                    const planetGroup = createPlanet(
                        galaxyGroup,
                        connection.id,
                        connection.name,
                        null, // position calculated in createPlanet
                        baseColor,
                        index,
                        data.connections.length
                    );
                    
                    galaxyEntry.planets.push(planetGroup);
                    galaxyEntry.planetGroups.set(connection.id, planetGroup);
                    
                    // Create moons for each stream in this connection
                    console.log(`[Supercluster] Creating ${connection.streams.length} moons for planet ${connection.name}`);
                    connection.streams.forEach((stream, streamIndex) => {
                        createMoon(
                            planetGroup,
                            stream.id,
                            stream.name,
                            streamIndex,
                            connection.streams.length
                        );
                    });
                });
                
                console.log(`[Supercluster] ✓ Updated ${galaxy.name}: ${data.connections.length} connections, ${data.streams.length} total streams`);
                
                console.log(`[Supercluster] Updated ${galaxy.name}: ${data.connections.length} connections, ${data.streams.length} total streams`);
            });
        }
        
        // REMOVED: Real-time polling for connections/streams updates to prevent interference with Luna Composer
        // Galaxy data will only update on initial load
        let galaxyUpdateInterval = null;
        function startGalaxyUpdates(licenseKey) {
            // Initial update only - no polling
            updateGalaxiesWithRealData(licenseKey);
            
            // REMOVED: setInterval polling that was causing interference
        }
        
        function stopGalaxyUpdates() {
            if (galaxyUpdateInterval) {
                clearInterval(galaxyUpdateInterval);
                galaxyUpdateInterval = null;
            }
        }
        
        // After galaxyData is initialized, ALWAYS update it with real data
        // If no real data is available, show error message
        // Note: Real-time galaxy updates (planets/moons) are started in fetchConstellationData() 
        // after constellation data is loaded, to ensure proper initialization order

        const ambientLight = new THREE.AmbientLight(0x5f6f9f, 0.48);
        scene.add(ambientLight);

        const rimLight = new THREE.DirectionalLight(0x9fd6ff, 0.75);
        rimLight.position.set(120, 260, 180);
        scene.add(rimLight);

        const warmLight = new THREE.DirectionalLight(0xffbf80, 0.58);
        warmLight.position.set(-220, -160, -180);
        scene.add(warmLight);

        const coolFillLight = new THREE.DirectionalLight(0x3b58ff, 0.32);
        coolFillLight.position.set(-140, 120, 260);
        scene.add(coolFillLight);

        // More dense background stars but very subtle
        const starFieldGeometry = new THREE.BufferGeometry();
        const starFieldCount = 6800; // Increased from 4200
        const starFieldPositions = new Float32Array(starFieldCount * 3);
        const starFieldColors = new Float32Array(starFieldCount * 3);
        const starFieldSizes = new Float32Array(starFieldCount);

        const color = new THREE.Color();
        for (let i = 0; i < starFieldCount; i++) {
            const radius = 920 * Math.cbrt(Math.random());
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);
            starFieldPositions[i * 3] = Math.sin(phi) * Math.cos(theta) * radius;
            starFieldPositions[i * 3 + 1] = Math.sin(phi) * Math.sin(theta) * radius;
            starFieldPositions[i * 3 + 2] = Math.cos(phi) * radius;

            // Subtle colors with varying brightness
            const hue = 0.55 + Math.random() * 0.12;
            const brightness = 0.4 + Math.random() * 0.3; // More subtle
            color.setHSL(hue, 0.5, brightness);
            starFieldColors[i * 3] = color.r;
            starFieldColors[i * 3 + 1] = color.g;
            starFieldColors[i * 3 + 2] = color.b;
            
            // Varying sizes
            starFieldSizes[i] = 1.5 + Math.random() * 3;
        }

        starFieldGeometry.setAttribute("position", new THREE.BufferAttribute(starFieldPositions, 3));
        starFieldGeometry.setAttribute("color", new THREE.BufferAttribute(starFieldColors, 3));
        starFieldGeometry.setAttribute("size", new THREE.BufferAttribute(starFieldSizes, 1));

        const starFieldMaterial = new THREE.PointsMaterial({
            map: baseParticleTexture,
            size: 2.8,
            vertexColors: true,
            sizeAttenuation: true,
            transparent: true,
            opacity: 0.35, // More subtle - reduced from 0.62
            depthWrite: false,
            depthTest: false,
            blending: THREE.AdditiveBlending,
        });

        const starField = new THREE.Points(starFieldGeometry, starFieldMaterial);
        scene.add(starField);

        // Far background stars - more dense but very subtle
        const farStarFieldGeometry = new THREE.BufferGeometry();
        const farStarFieldCount = 7200; // Increased from 5200
        const farStarFieldPositions = new Float32Array(farStarFieldCount * 3);
        const farStarFieldColors = new Float32Array(farStarFieldCount * 3);
        const farStarFieldSizes = new Float32Array(farStarFieldCount);
        
        for (let i = 0; i < farStarFieldCount; i++) {
            const radius = 1500 * Math.cbrt(Math.random());
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            farStarFieldPositions[i * 3] = Math.sin(phi) * Math.cos(theta) * radius;
            farStarFieldPositions[i * 3 + 1] = Math.sin(phi) * Math.sin(theta) * radius;
            farStarFieldPositions[i * 3 + 2] = Math.cos(phi) * radius;

            // More subtle colors
            const hue = 0.54 + Math.random() * 0.1;
            const brightness = 0.3 + Math.random() * 0.2; // More subtle
            color.setHSL(hue, 0.4, brightness);
            farStarFieldColors[i * 3] = color.r;
            farStarFieldColors[i * 3 + 1] = color.g;
            farStarFieldColors[i * 3 + 2] = color.b;
            
            // Varying sizes
            farStarFieldSizes[i] = 2 + Math.random() * 4;
        }
        farStarFieldGeometry.setAttribute("position", new THREE.BufferAttribute(farStarFieldPositions, 3));
        farStarFieldGeometry.setAttribute("color", new THREE.BufferAttribute(farStarFieldColors, 3));
        farStarFieldGeometry.setAttribute("size", new THREE.BufferAttribute(farStarFieldSizes, 1));

        const farStarFieldMaterial = new THREE.PointsMaterial({
            map: baseParticleTexture,
            size: 4.5,
            vertexColors: true,
            sizeAttenuation: true,
            transparent: true,
            opacity: 0.22, // More subtle - reduced from 0.38
            depthWrite: false,
            depthTest: false,
            blending: THREE.AdditiveBlending,
        });

        const farStarField = new THREE.Points(farStarFieldGeometry, farStarFieldMaterial);
        scene.add(farStarField);

        const connectionBaseColor = new THREE.Color(0x6bc8ff);
        const connectionLines = new THREE.Group();
        superclusterGroup.add(connectionLines);
        
        // Make connectionLines globally accessible
        window.connectionLines = connectionLines;
        const connectionFlowEntries = [];

        const connectionKey = (a, b) => [a, b].sort().join("::");
        const createdConnections = new Set();

        function drawConnections() {
            connectionLines.children.slice().forEach((child) => {
                if (child.geometry) {
                    child.geometry.dispose();
                }
                if (child.material) {
                    child.material.dispose();
                }
            });
            connectionLines.clear();
            connectionFlowEntries.length = 0;
            createdConnections.clear();
            for (const data of galaxyData) {
                const source = galaxyGroups.get(data.name);
                data.connections.forEach((targetName) => {
                    const key = connectionKey(data.name, targetName);
                    if (createdConnections.has(key)) return;

                    const target = galaxyGroups.get(targetName);
                    if (!target) return;

                    const points = [];
                    points.push(source.group.position.clone());
                    const control = source.group.position.clone()
                        .add(target.group.position)
                        .multiplyScalar(0.5)
                        .add(new THREE.Vector3(
                            (Math.random() - 0.5) * 120,
                            (Math.random() - 0.5) * 120,
                            (Math.random() - 0.5) * 120,
                        ));
                    points.push(control);
                    points.push(target.group.position.clone());

                    const curve = new THREE.CatmullRomCurve3(points);
                    // Thinner, more ethereal connection lines
                    const geometry = new THREE.TubeGeometry(curve, 128, 1.2, 16, false);

                    const sourceColor = source?.core?.material?.color?.clone?.() || connectionBaseColor.clone();
                    const targetColor = galaxyGroups.get(targetName)?.core?.material?.color?.clone?.() || connectionBaseColor.clone();
                    const blendedColor = sourceColor.lerp(targetColor, 0.5);

                    const baseOpacity = 0.28 + Math.random() * 0.08;
                    const flowMaterial = new THREE.ShaderMaterial({
                        uniforms: {
                            uColor: { value: blendedColor.clone() },
                            uOpacity: { value: baseOpacity },
                            uTime: { value: Math.random() },
                            uHighlight: { value: 0 },
                            uGlowIntensity: { value: 1.2 },
                        },
                        vertexShader: `
                            varying vec2 vUv;
                            varying vec3 vPosition;
                            varying vec3 vNormal;
                            void main() {
                                vUv = uv;
                                vPosition = position;
                                vNormal = normal;
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }
                        `,
                        fragmentShader: `
                            uniform vec3 uColor;
                            uniform float uOpacity;
                            uniform float uHighlight;
                            uniform float uTime;
                            uniform float uGlowIntensity;
                            varying vec2 vUv;
                            varying vec3 vPosition;
                            varying vec3 vNormal;

                            void main() {
                                // Ethereal flow effect
                                float flow = fract(vUv.x * 1.5 - uTime * 0.8);
                                float head = smoothstep(0.0, 0.3, flow) * smoothstep(1.0, 0.7, flow);
                                
                                // Smooth tapering at ends
                                float taper = smoothstep(0.0, 0.15, vUv.x) * smoothstep(1.0, 0.85, vUv.x);
                                
                                // Pulsing glow effect
                                float pulse = sin(uTime * 2.0 + vUv.x * 3.14159) * 0.5 + 0.5;
                                pulse = smoothstep(0.3, 0.7, pulse);
                                
                                // Radial glow from center of tube
                                float radialGlow = 1.0 - abs(vUv.y - 0.5) * 2.0;
                                radialGlow = pow(radialGlow, 1.5);
                                
                                // Highlight effect
                                float highlight = uHighlight;
                                
                                // Base color with taper
                                vec3 baseColor = mix(uColor * (0.4 + 0.6 * taper), vec3(1.0), highlight * 0.4);
                                
                                // Ethereal glow - more wispy and fluid
                                vec3 glowColor = uColor * (0.5 + 0.5 * pulse) * (0.6 + 0.4 * taper) * radialGlow * uGlowIntensity;
                                
                                // Add flowing particles effect
                                float particles = smoothstep(0.0, 0.2, flow) * smoothstep(1.0, 0.8, flow);
                                glowColor += uColor * particles * 0.6;
                                
                                // Combine colors
                                vec3 color = baseColor + glowColor * (1.0 + highlight * 0.8);
                                
                                // Alpha with smooth fade
                                float alpha = uOpacity * (0.4 + 0.6 * taper) * (0.7 + 0.3 * radialGlow) * (1.0 + highlight * 0.6 + head * 0.4);
                                
                                gl_FragColor = vec4(color, alpha);
                            }
                        `,
                        transparent: true,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false,
                        side: THREE.DoubleSide,
                    });

                    const mesh = new THREE.Mesh(geometry, flowMaterial);
                    mesh.userData = {
                        start: data.name,
                        end: targetName,
                        baseColor: blendedColor.clone(),
                        baseOpacity,
                        targetOpacity: baseOpacity,
                        flowSpeed: 0.1 + Math.random() * 0.18,
                    };
                    connectionLines.add(mesh);
                    connectionFlowEntries.push(mesh);

                    createdConnections.add(key);
                });
            }
        }

        drawConnections();

        const infoCard = document.getElementById("infoCard");
        const infoMetricsList = document.getElementById("infoMetrics");
        const defaultSubtitle = "Select a Stream Category";
        const defaultIntroText =
            "Explore the connective tissue of Visible Light AI's intelligence streams. Click any galaxy to learn how each stream powers the constellation of insights.";

        function appendMetric(list, title, detail) {
            if (!list) return;
            const item = document.createElement("li");
            const heading = document.createElement("strong");
            heading.textContent = title;
            const value = document.createElement("span");
            value.textContent = detail;
            item.append(heading, value);
            list.appendChild(item);
        }

        function updateInfoCard(data) {
            if (!infoCard) {
                return;
            }

            if (!data) {
                infoCard.querySelector("h1").textContent = "Visible Light AI Supercluster";
                infoCard.querySelector("h2").textContent = defaultSubtitle;
                infoCard.querySelector("p").textContent = defaultIntroText;
                if (infoMetricsList) {
                    infoMetricsList.innerHTML = "";
                    if (constellationData) {
                        appendMetric(infoMetricsList, "Status", `Connected to VL Hub - ${constellationData.total_clients} clients`);
                        appendMetric(infoMetricsList, "License", licenseKey ? `${licenseKey.substring(0, 8)}...` : "No license key");
                    } else if (dataFetchError) {
                        appendMetric(infoMetricsList, "Status", `Connection failed: ${dataFetchError}`);
                        appendMetric(infoMetricsList, "Retry", "Refreshing in 30 seconds...");
                    } else {
                        appendMetric(infoMetricsList, "Status", "Connecting to VL Hub...");
                    }
                }
                infoCard.classList.remove("visible");
                requestAnimationFrame(() => infoCard.classList.add("visible"));
                return;
            }

            infoCard.querySelector("h1").textContent = data.name;
            const subtitleParts = ["Stream Category"];
            if (data.metrics?.categoryName) {
                subtitleParts.unshift(data.metrics.categoryName);
            }
            if (data.metrics?.clientName) {
                subtitleParts.push(data.metrics.clientName);
            }
            infoCard.querySelector("h2").textContent = subtitleParts.join(" • ");
            infoCard.querySelector("p").textContent = data.description;

            if (infoMetricsList) {
                infoMetricsList.innerHTML = "";
                if (data.metrics) {
                    appendMetric(
                        infoMetricsList,
                        "Signals",
                        data.metrics.nodesCount != null ? `${data.metrics.nodesCount} active` : "Awaiting telemetry"
                    );
                    const topNodes = Array.isArray(data.metrics.topNodes) ? data.metrics.topNodes : [];
                    topNodes.slice(0, 4).forEach((node) => {
                        appendMetric(infoMetricsList, node.label, node.detail);
                    });
                    if (!topNodes.length) {
                        appendMetric(infoMetricsList, "Insight", "Awaiting telemetry from VL Hub.");
                    }
                } else {
                    appendMetric(infoMetricsList, "Insight", "Awaiting telemetry from VL Hub.");
                }
            }

            infoCard.classList.add("visible");
        }

        let hoveredGalaxy = null;
        let activeGalaxy = null;

        function setGalaxyGlow(name, intensity) {
            const entry = galaxyGroups.get(name);
            if (!entry) return;
            entry.core.material.emissiveIntensity = 1.4 + intensity * 0.8;
            
            // Animate multiple halo layers
            entry.halo.material.opacity = 0.18 + intensity * 0.25;
            if (entry.halo2) {
                entry.halo2.material.opacity = 0.12 + intensity * 0.18;
            }
            if (entry.halo3) {
                entry.halo3.material.opacity = 0.08 + intensity * 0.12;
            }
            
            if (entry.stars && entry.stars.material) {
                const baseSize = entry.baseStarSize ?? entry.stars.material.size ?? 6.5;
                entry.stars.material.size = baseSize + intensity * 4.5;
            }
            
            if (entry.swirl?.material) {
                const baseOpacity = entry.swirl.userData?.baseOpacity ?? entry.swirl.material.opacity ?? 0.5;
                entry.swirl.material.opacity = baseOpacity + intensity * 0.3;
                entry.swirl.material.needsUpdate = true;
            }
            if (entry.sparkLayer?.material) {
                entry.sparkLayer.material.opacity = 0.32 + intensity * 0.4;
                entry.sparkLayer.material.needsUpdate = true;
            }
            if (entry.dust?.material) {
                entry.dust.material.opacity = 0.35 + intensity * 0.25;
                entry.dust.material.needsUpdate = true;
            }
            
            // Animate galaxy clouds
            if (entry.cloud1?.material) {
                entry.cloud1.material.opacity = 0.35 + intensity * 0.25;
                entry.cloud1.material.needsUpdate = true;
            }
            if (entry.cloud2?.material) {
                entry.cloud2.material.opacity = 0.22 + intensity * 0.18;
                entry.cloud2.material.needsUpdate = true;
            }
            if (entry.outerCloud?.material) {
                entry.outerCloud.material.opacity = 0.18 + intensity * 0.15;
                entry.outerCloud.material.needsUpdate = true;
            }
            
            if (entry.pointLight) {
                entry.pointLight.intensity = 2.2 + intensity * 1.8;
                entry.pointLight.distance = 600 + intensity * 100;
            }
            if (entry.rimLight) {
                entry.rimLight.intensity = 0.8 + intensity * 0.6;
                entry.rimLight.distance = 400 + intensity * 80;
            }
        }

        function onPointerMove(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            if (!rect.width || !rect.height) {
                return;
            }
            pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            pointer.y = -(((event.clientY - rect.top) / rect.height) * 2 - 1);
        }

        // Store category data globally for galaxy clicks
        let currentCategoryData = null;
        
        // Function to display galaxy connections and streams in activity list
        async function displayGalaxyDataInActivityList(galaxyName) {
            const listEl = document.getElementById('recentActivityList');
            if (!listEl) return;
            
            // Show loading state
            listEl.innerHTML = '<li class="vl-activity-empty">Loading galaxy data...</li>';
            
            // Get license key from URL
            const urlParams = new URLSearchParams(window.location.search);
            let licenseKey = urlParams.get('license') || '';
            if (licenseKey) {
                const licenseMatch = licenseKey.match(/^([^/]+)/);
                if (licenseMatch) licenseKey = licenseMatch[1];
            }
            
            if (!licenseKey) {
                listEl.innerHTML = '<li class="vl-activity-empty">No license key found.</li>';
                return;
            }
            
            try {
                // Fetch connections and streams for this galaxy
                const categoryData = await fetchConnectionsAndStreams(licenseKey);
                if (!categoryData) {
                    listEl.innerHTML = '<li class="vl-activity-empty">No data available for this galaxy.</li>';
                    return;
                }
                
                // Store for future use
                currentCategoryData = categoryData;
                
                // Get data for this specific galaxy
                const galaxyCategoryData = categoryData[galaxyName];
                if (!galaxyCategoryData) {
                    listEl.innerHTML = '<li class="vl-activity-empty">No data found for ' + galaxyName + '.</li>';
                    return;
                }
                
                // Clear and populate activity list
                listEl.innerHTML = '';
                
                // Show Galaxy/Category Name
                const galaxyNameLi = document.createElement('li');
                galaxyNameLi.className = 'vl-activity-item';
                galaxyNameLi.style.fontSize = '16px';
                galaxyNameLi.style.color = '#fff4e9';
                galaxyNameLi.style.marginBottom = '8px';
                galaxyNameLi.textContent = galaxyName;
                listEl.appendChild(galaxyNameLi);
                
                // Show Total Connections with tooltip
                const totalConnections = galaxyCategoryData.connections ? galaxyCategoryData.connections.length : 0;
                const connectionsLi = document.createElement('li');
                connectionsLi.className = 'vl-activity-item';
                connectionsLi.style.color = '#fff4e9';
                connectionsLi.style.marginBottom = '12px';
                connectionsLi.style.cursor = totalConnections > 0 ? 'help' : 'default';
                connectionsLi.textContent = `Total Connections: ${totalConnections}`;
                
                // Add tooltip with connection names if connections exist
                if (totalConnections > 0 && galaxyCategoryData.connections) {
                    const connectionNames = galaxyCategoryData.connections.map(conn => {
                        return conn.name || conn.connection_name || conn.id || conn.connection_id || 'Unnamed Connection';
                    }).join(', ');
                    connectionsLi.setAttribute('title', connectionNames);
                }
                
                listEl.appendChild(connectionsLi);
                
                // Show separator
                const separatorLi = document.createElement('li');
                separatorLi.style.height = '1px';
                separatorLi.style.background = '#5A5753';
                separatorLi.style.margin = '8px 0';
                listEl.appendChild(separatorLi);
                
                // Show "List All Data Streams" header
                const streamsHeaderLi = document.createElement('li');
                streamsHeaderLi.className = 'vl-activity-item';
                streamsHeaderLi.style.color = '#fff4e9';
                streamsHeaderLi.style.marginTop = '8px';
                streamsHeaderLi.style.marginBottom = '8px';
                const totalStreams = galaxyCategoryData.streams ? galaxyCategoryData.streams.length : 0;
                streamsHeaderLi.textContent = `All Data Streams (${totalStreams}):`;
                listEl.appendChild(streamsHeaderLi);
                
                // List all data streams
                if (galaxyCategoryData.streams && galaxyCategoryData.streams.length > 0) {
                    galaxyCategoryData.streams.forEach((stream, index) => {
                        const streamLi = document.createElement('li');
                        streamLi.className = 'vl-activity-item';
                        streamLi.style.marginBottom = '4px';
                        
                        const streamName = stream.name || stream.stream_name || stream.id || 'Unnamed Stream';
                        streamLi.textContent = `${index + 1}. ${streamName}`;
                        
                        // Add click handler to navigate to stream if ID exists
                        if (stream.id || stream.stream_id) {
                            streamLi.style.cursor = 'pointer';
                            streamLi.addEventListener('click', (e) => {
                                e.preventDefault();
                                const streamUrl = buildStreamDataUrl(licenseKey, stream);
                                window.location.href = streamUrl;
                            });
                            streamLi.addEventListener('mouseenter', () => {
                                streamLi.style.textDecoration = 'underline';
                            });
                            streamLi.addEventListener('mouseleave', () => {
                                streamLi.style.textDecoration = 'none';
                            });
                        }
                        
                        listEl.appendChild(streamLi);
                    });
                } else {
                    const noStreamsLi = document.createElement('li');
                    noStreamsLi.className = 'vl-activity-item';
                    noStreamsLi.style.color = '#9A9793';
                    noStreamsLi.style.fontStyle = 'italic';
                    noStreamsLi.textContent = 'No data streams found for this galaxy.';
                    listEl.appendChild(noStreamsLi);
                }
                
            } catch (error) {
                console.error('[Supercluster] Error displaying galaxy data:', error);
                listEl.innerHTML = '<li class="vl-activity-empty">Error loading galaxy data.</li>';
            }
        }

        function onClick() {
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(
                Array.from(galaxyGroups.values()).map((entry) => entry.core),
                false
            );

            if (intersects.length > 0) {
                const name = galaxyData.find((g) => galaxyGroups.get(g.name).core === intersects[0].object)?.name;
                if (name) {
                    if (activeGalaxy && activeGalaxy !== name) {
                        setGalaxyGlow(activeGalaxy, 0);
                    }
                    activeGalaxy = name;
                    setGalaxyGlow(name, 1);
                    updateInfoCard(galaxyData.find((g) => g.name === name));
                    highlightConnections(name);
                    // Display connections and streams in activity list
                    displayGalaxyDataInActivityList(name);
                }
            } else if (activeGalaxy) {
                setGalaxyGlow(activeGalaxy, 0);
                activeGalaxy = null;
                updateInfoCard(null);
                highlightConnections(null);
                // Restore normal activity list when clicking away
                loadRecentActivity();
            }
        }

        function highlightConnections(name) {
            connectionLines.children.forEach((child) => {
                const material = child.material;
                if (material?.uniforms) {
                    material.uniforms.uColor.value.copy(child.userData.baseColor ?? connectionBaseColor);
                    material.uniforms.uHighlight.value = 0;
                    child.userData.targetOpacity = child.userData.baseOpacity ?? material.uniforms.uOpacity.value;
                }
            });

            galaxyData.forEach((data) => {
                const entry = galaxyGroups.get(data.name);
                if (!entry) return;
                // Label removed - no longer needed
                // if (entry.label) entry.label.classList.remove("active");
                if (data.name !== activeGalaxy && data.name !== hoveredGalaxy) {
                    setGalaxyGlow(data.name, 0);
                }
            });

            if (!name) {
                return;
            }

            const sourceData = galaxyData.find((g) => g.name === name);
            if (!sourceData) return;

            const related = new Set([name, ...sourceData.connections]);
            connectionLines.children.forEach((child) => {
                const { start, end } = child.userData;
                if (related.has(start) && related.has(end)) {
                    const highlightEntry = galaxyGroups.get(name);
                    if (highlightEntry && child.material?.uniforms) {
                        child.material.uniforms.uColor.value.copy(highlightEntry.core.material.color);
                        child.material.uniforms.uHighlight.value = 1;
                        const baseOpacity = child.userData.baseOpacity ?? 0.34;
                        child.userData.targetOpacity = Math.min(1, baseOpacity + 0.55);
                    }
                }
            });

            related.forEach((labelName) => {
                const entry = galaxyGroups.get(labelName);
                if (!entry) return;
                // Label removed - no longer needed
                // if (entry.label) entry.label.classList.add("active");
                if (labelName !== name && labelName !== hoveredGalaxy) {
                    setGalaxyGlow(labelName, 0.35);
                }
            });
        }

        window.addEventListener("pointermove", onPointerMove);
        window.addEventListener("click", onClick);

        const clusterMovePercent = 0.05;
        const zoomStepPercent = 0.1;
        let customAnimationActive = false;
        let customAnimationPaused = false;
        let customAnimationPhase = 0;

        const leftControl = document.getElementById("controlLeft");
        const rightControl = document.getElementById("controlRight");
        const zoomInControl = document.getElementById("controlZoomIn");
        const zoomOutControl = document.getElementById("controlZoomOut");
        const animateControl = document.getElementById("controlAnimate");

        function panCluster(direction) {
            camera.getWorldDirection(cameraDirection);
            panRight.crossVectors(cameraDirection, camera.up);
            if (panRight.lengthSq() === 0) {
                return;
            }

            const distance = camera.position.distanceTo(controls.target);
            const delta = distance * clusterMovePercent * direction;
            panRight.normalize().multiplyScalar(delta);

            camera.position.add(panRight);
            controls.target.add(panRight);
            controls.update();
            updateLabels();
        }

        function zoomCluster(amount) {
            zoomOffset.subVectors(camera.position, controls.target);
            const currentDistance = zoomOffset.length();
            if (currentDistance === 0) {
                zoomOffset.set(0, 0, 1);
            }

            const targetDistance = THREE.MathUtils.clamp(
                zoomOffset.length() * (1 + amount),
                controls.minDistance,
                controls.maxDistance
            );

            zoomOffset.setLength(targetDistance);
            camera.position.copy(controls.target).add(zoomOffset);
            controls.update();
            updateLabels();
        }

        leftControl?.addEventListener("click", () => {
            panCluster(-1);
        });

        rightControl?.addEventListener("click", () => {
            panCluster(1);
        });

        zoomInControl?.addEventListener("click", () => {
            zoomCluster(-zoomStepPercent);
        });

        zoomOutControl?.addEventListener("click", () => {
            zoomCluster(zoomStepPercent);
        });

        function toggleCustomAnimation() {
            customAnimationActive = !customAnimationActive;
            if (!customAnimationActive) {
                customAnimationPhase = 0;
                customAnimationPaused = false;
                animateControl?.classList.remove("paused");
            }
            if (animateControl) {
                animateControl.classList.toggle("active", customAnimationActive);
                animateControl.setAttribute("aria-pressed", String(customAnimationActive));
                const label = animateControl.querySelector(".label");
                if (label) {
                    label.textContent = customAnimationActive ? "Animating" : "Animate";
                }
            }
        }

        animateControl?.addEventListener("click", () => {
            toggleCustomAnimation();
        });

        animateControl?.addEventListener("mouseenter", () => {
            if (!customAnimationActive) return;
            customAnimationPaused = true;
            animateControl.classList.add("paused");
        });

        animateControl?.addEventListener("mouseleave", () => {
            if (!customAnimationActive) return;
            customAnimationPaused = false;
            animateControl.classList.remove("paused");
        });

        function updateLabels() {
            // Labels removed - function kept for compatibility but does nothing
            // const rect = renderer.domElement.getBoundingClientRect();
            // const width = rect.width;
            // const height = rect.height;
            // if (!width || !height) {
            //     return;
            // }
            // galaxyData.forEach((data) => {
            //     const entry = galaxyGroups.get(data.name);
            //     if (!entry || !entry.label) return;
            //     entry.group.getWorldPosition(tempWorldPosition);
            //     projectedPosition.copy(tempWorldPosition).project(camera);
            //     const x = (projectedPosition.x * 0.5 + 0.5) * width;
            //     const y = (-projectedPosition.y * 0.5 + 0.5) * height;
            //     const isVisible = projectedPosition.z > -1 && projectedPosition.z < 1;
            //     entry.label.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
            //     entry.label.style.opacity = isVisible
            //         ? entry.label.classList.contains("active")
            //             ? 1
            //             : 0.7
            //         : 0;
            // });
        }

        let previousTime = 0;

        function animate(time) {
                if (!isOmniscientPage && !isLunaComposePage && renderer && scene && camera && controls) {
            requestAnimationFrame(animate);
            controls.update();

            const deltaMs = time - (previousTime || time);
            previousTime = time;
            const deltaSeconds = deltaMs > 0 ? deltaMs * 0.001 : 0;

            const t = time * 0.00012;

            if (customAnimationActive) {
                if (!customAnimationPaused) {
                    customAnimationPhase += 0.0045;
                }
                const swingX = Math.sin(customAnimationPhase * 0.55) * 0.18;
                const swingZ = Math.cos(customAnimationPhase * 0.45) * 0.14;
                const lift = Math.sin(customAnimationPhase) * 18;
                superclusterGroup.rotation.x = swingX;
                superclusterGroup.rotation.z = swingZ;
                superclusterGroup.position.y = lift;
            }

            const idleTilt = Math.sin(time * 0.00018) * 0.06;
            const idleLift = Math.sin(time * 0.00012) * 8;
            if (!customAnimationActive) {
                superclusterGroup.rotation.x = THREE.MathUtils.lerp(superclusterGroup.rotation.x, idleTilt, 0.04);
                superclusterGroup.rotation.z = THREE.MathUtils.lerp(superclusterGroup.rotation.z, idleTilt * 0.45, 0.04);
                superclusterGroup.position.y = THREE.MathUtils.lerp(superclusterGroup.position.y, idleLift, 0.06);
            }

            superclusterGroup.rotation.y += 0.00006 + (customAnimationActive && !customAnimationPaused ? 0.00005 : 0.00002);
            atmosphereShell.rotation.y += 0.00001;

            starField.rotation.y += 0.00005;
            starField.rotation.x = Math.sin(time * 0.00006) * 0.05;
            farStarField.rotation.y += 0.000015;
            farStarField.rotation.x = Math.sin(time * 0.00003) * 0.03;

            nebulaClouds.forEach((cloud, idx) => {
                const data = cloud.userData || {};
                const phase = time * 0.00008 + (data.phaseOffset || 0) + idx * 0.1;
                const basePosition = data.basePosition || cloud.position;
                const drift = data.drift || { x: 0, y: 0, z: 0 };
                const driftX = drift.x || 0;
                const driftY = drift.y || 0;
                const driftZ = drift.z || 0;
                cloud.position.x = basePosition.x + Math.sin(phase) * driftX;
                cloud.position.y = basePosition.y + Math.cos(phase * 0.8) * driftY;
                cloud.position.z = basePosition.z + Math.sin(phase * 1.2) * driftZ;
                cloud.rotation.z += data.rotationSpeed || 0.00008;
                const osc = Math.sin(phase * 1.6);
                const flicker = 0.55 + 0.45 * osc * osc;
                if (cloud.material) {
                    cloud.material.opacity = (data.baseOpacity || cloud.material.opacity) * flicker;
                }
            });

            galaxyData.forEach((data, idx) => {
                const entry = galaxyGroups.get(data.name);
                if (!entry) return;
                // entry.stars is now an array of Star objects (connections), not a Three.js Points object
                // The original stars (particle system) is still stored separately
                if (entry.stars && !Array.isArray(entry.stars)) {
                    // This is the original particle stars system
                entry.stars.rotation.y += 0.00028 + idx * 0.00002;
                entry.stars.rotation.x += 0.00012;
                if (customAnimationActive && !customAnimationPaused) {
                    entry.stars.rotation.z += 0.00025;
                    }
                }
                if (entry.swirl && entry.swirl.rotation) {
                    const swirlData = entry.swirl.userData || {};
                    entry.swirl.rotation.z += (swirlData.spinSpeed || 0.00024) + (customAnimationActive && !customAnimationPaused ? 0.00022 : 0);
                    entry.swirl.rotation.x += Math.sin(time * 0.00022 + idx) * (swirlData.wobbleStrength || 0.08) * 0.0025;
                }
                if (entry.sparkLayer) {
                    const spinSpeed = entry.sparkLayer.userData?.spinSpeed || 0.00032;
                    entry.sparkLayer.rotation.z += spinSpeed;
                }
                // Animate galaxy clouds
                if (entry.cloud1) {
                    entry.cloud1.rotation.z += 0.00008;
                    entry.cloud1.rotation.x = Math.PI / 2 + Math.sin(time * 0.00022 + idx) * 0.06;
                }
                if (entry.cloud2) {
                    entry.cloud2.rotation.z -= 0.00006;
                    entry.cloud2.rotation.x = Math.PI / 2.1 + Math.sin(time * 0.00018 + idx) * 0.08;
                }
                if (entry.outerCloud) {
                    entry.outerCloud.rotation.z -= 0.00008;
                    entry.outerCloud.rotation.x = Math.PI / 2.15 + Math.sin(time * 0.00018 + idx) * 0.12;
                }
                
                // Animate dust particles
                if (entry.dust) {
                    const dustSpeed = entry.dust.userData?.spinSpeed || 0.00008;
                    entry.dust.rotation.z += dustSpeed;
                    entry.dust.rotation.y += dustSpeed * 0.5;
                }
                // Animate planets and moons
                if (entry.planets && entry.planets.length > 0) {
                    entry.planets.forEach(planetGroup => {
                        // Rotate planet slowly
                        planetGroup.rotation.y += 0.0005;
                        
                        // Animate moons orbiting planets
                        if (planetGroup.userData.moons && planetGroup.userData.moons.length > 0) {
                            planetGroup.userData.moons.forEach(moonGroup => {
                                const moonData = moonGroup.userData;
                                moonData.orbitAngle += moonData.orbitSpeed;
                                
                                // Update moon position in orbit
                                const x = Math.cos(moonData.orbitAngle) * moonData.orbitRadius;
                                const z = Math.sin(moonData.orbitAngle) * moonData.orbitRadius;
                                moonGroup.position.x = x;
                                moonGroup.position.z = z;
                                
                                // Rotate moon
                                moonGroup.rotation.y += 0.01;
                            });
                        }
                    });
                }
                
                const pulseScale = customAnimationActive
                    ? 1 + Math.sin(customAnimationPhase * 1.4 + idx) * 0.08
                    : 1;
                entry.core.scale.setScalar(pulseScale);
                const haloPulse = customAnimationActive
                    ? Math.sin(customAnimationPhase + idx) * 0.08
                    : 0;
                entry.halo.scale.setScalar(1.22 + Math.sin(t + idx) * 0.02 + haloPulse);
                if (entry.halo2) {
                    entry.halo2.scale.setScalar(1.15 + Math.sin(t + idx * 0.8) * 0.015 + haloPulse * 0.8);
                }
                if (entry.halo3) {
                    entry.halo3.scale.setScalar(1.12 + Math.sin(t + idx * 0.6) * 0.01 + haloPulse * 0.6);
                }
            });

            connectionFlowEntries.forEach((mesh) => {
                const material = mesh.material;
                if (!material?.uniforms) {
                    return;
                }
                const speed = mesh.userData?.flowSpeed || 0.12;
                material.uniforms.uTime.value = (material.uniforms.uTime.value + deltaSeconds * speed) % 1;
                const targetOpacity = mesh.userData?.targetOpacity ?? mesh.userData?.baseOpacity ?? material.uniforms.uOpacity.value;
                material.uniforms.uOpacity.value = THREE.MathUtils.lerp(
                    material.uniforms.uOpacity.value,
                    targetOpacity,
                    0.08
                );
            });

            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(
                Array.from(galaxyGroups.values()).map((entry) => entry.core),
                false
            );

            if (intersects.length > 0) {
                const name = galaxyData.find((g) => galaxyGroups.get(g.name).core === intersects[0].object)?.name;
                if (name && name !== hoveredGalaxy) {
                    if (hoveredGalaxy && hoveredGalaxy !== activeGalaxy) {
                        setGalaxyGlow(hoveredGalaxy, 0);
                    }
                    hoveredGalaxy = name;
                    if (name !== activeGalaxy) {
                        setGalaxyGlow(name, 0.6);
                    }
                }
            } else if (hoveredGalaxy && hoveredGalaxy !== activeGalaxy) {
                const previous = hoveredGalaxy;
                setGalaxyGlow(previous, 0);
                hoveredGalaxy = null;
                if (activeGalaxy) {
                    highlightConnections(activeGalaxy);
                }
            }

            updateLabels();
            renderer.render(scene, camera);
                }
        }

        // Initialize the application
        updateInfoCard(null);
        
        // Add debugging for Three.js initialization
        console.log('Starting Supercluster initialization...');
        console.log('Root container:', rootContainer);
        console.log('License key from URL:', licenseKey);

            if (!isOmniscientPage && !isLunaComposePage) {
        animate(0);
            }

        window.addEventListener("resize", () => {
                if (!isOmniscientPage && !isLunaComposePage && camera && renderer) {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
                    if (typeof updateLabels === 'function') {
            updateLabels();
                    }
                }
        });
        }

        setTimeout(() => {
            const infoCard = document.getElementById('infoCard');
            if (infoCard) {
                infoCard.classList.add("visible");
            }
        }, 600);

        // ============================================================
        // Luna Chat Widget Integration
        // ============================================================

        // Show a Luna launcher skeleton immediately with a loading spinner
        (function initLunaLauncherSkeleton() {
            try {
                const container = document.getElementById('vlLunaChatContainer');
                if (!container) return;
                // Don't overwrite if widget or launcher already rendered
                if (container.querySelector('.luna-launcher')) return;

                // Inject minimal styles for loading spinner once
                if (!document.getElementById('luna-launcher-loading-styles')) {
                    const style = document.createElement('style');
                    style.id = 'luna-launcher-loading-styles';
                    style.textContent = `
.luna-launcher.luna-launcher--loading {
  position: fixed;
  bottom: 25px;
  right: 25px;
  z-index: 2147483645;
  background: #000000;
  border: 1px solid #1f1d1a;
  border-radius: 999px;
  padding: 6px 14px;
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: default;
  opacity: 0.9;
}
.luna-launcher.luna-launcher--loading .ava {
  width: 28px;
  height: 28px;
  border-radius: 999px;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 1px solid #2e2c2a;
}
.luna-launcher.luna-launcher--loading .ava .spinner {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  border: 2px solid rgba(255,244,233,0.2);
  border-top-color: #fff4e9;
  animation: luna-spinner 0.9s linear infinite;
}
.luna-launcher.luna-launcher--loading .label {
  color: #000;
  font-size: 0.85rem;
  font-weight: 500;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Inter", sans-serif;
}
@keyframes luna-spinner {
  to { transform: rotate(360deg); }
}
`;
                    document.head.appendChild(style);
                }

                container.innerHTML = '<button class="luna-launcher luna-launcher--loading" type="button" aria-label="Luna is loading"><span class="ava"><span class="spinner"></span></span><span class="label">Luna is loading…</span></span></button>';
            } catch (e) {
                console.error('[Luna Widget] Error initializing launcher skeleton:', e);
            }
        })();

        async function checkAndLoadLunaWidget() {
            console.log('[Luna Widget] Starting widget load check...');
            const container = document.getElementById('vlLunaChatContainer');
            if (!container) {
                console.error('[Luna Widget] Container not found: vlLunaChatContainer');
                return;
            }
            console.log('[Luna Widget] Container found:', container);

            try {
                // Get license key from URL or page
                let licenseKey = new URLSearchParams(window.location.search).get('license') || 
                                  document.getElementById('licenseKeyDisplay')?.textContent?.trim();
                
                // Extract just the license key (before first /) if URL contains path segments
                if (licenseKey) {
                    const licenseMatch = licenseKey.match(/^([^/]+)/);
                    if (licenseMatch) {
                        licenseKey = licenseMatch[1];
                    }
                }
                
                console.log('[Luna Widget] License key:', licenseKey);
                
                if (!licenseKey) {
                    console.warn('[Luna Widget] No license key found, skipping widget load');
                    return;
                }

                // Validate license key by checking all-connections endpoint
                console.log('[Luna Widget] Validating license key...');
                const validationUrl = `https://visiblelight.ai/wp-json/vl-hub/v1/all-connections?license=${encodeURIComponent(licenseKey)}`;
                const validationResponse = await fetch(validationUrl, {
                    method: 'GET',
                    credentials: 'include',
                    mode: 'cors'
                });
                
                if (!validationResponse.ok) {
                    console.warn('[Luna Widget] License key validation failed:', validationResponse.status);
                    return;
                }
                
                const validationData = await validationResponse.json();
                if (!validationData || !validationData.ok) {
                    console.warn('[Luna Widget] License key is not valid or active');
                    return;
                }
                
                console.log('[Luna Widget] License key validated successfully');

                // Get client profile data from VL Hub API to get the client site URL
                const profileUrl = `https://visiblelight.ai/wp-json/vl-hub/v1/profile?license=${encodeURIComponent(licenseKey)}`;
                console.log('[Luna Widget] Fetching profile from:', profileUrl);
                
                const profileResponse = await fetch(profileUrl, {
                    method: 'GET',
                    credentials: 'include',
                    mode: 'cors'
                });
                
                console.log('[Luna Widget] Profile response status:', profileResponse.status);
                
                if (!profileResponse.ok) {
                    const errorText = await profileResponse.text();
                    console.error('[Luna Widget] Failed to fetch profile:', profileResponse.status, errorText);
                    return;
                }
                
                const profileData = await profileResponse.json();
                console.log('[Luna Widget] Profile data received:', profileData);
                
                // Check if profile data is valid
                if (!profileData || (!profileData.ok && !profileData.license_key && !profileData.site)) {
                    console.error('[Luna Widget] Invalid profile data:', profileData);
                    return;
                }

                // Get client site URL from profile - check multiple possible locations
                let clientSiteUrl = null;
                if (profileData.data?.site_info?.site) {
                    clientSiteUrl = profileData.data.site_info.site;
                } else if (profileData.site_info?.site) {
                    clientSiteUrl = profileData.site_info.site;
                } else if (profileData.site?.home_url) {
                    clientSiteUrl = profileData.site.home_url;
                } else if (profileData.home_url) {
                    clientSiteUrl = profileData.home_url;
                } else if (profileData.site) {
                    clientSiteUrl = typeof profileData.site === 'string' ? profileData.site : profileData.site.home_url;
                }
                
                console.log('[Luna Widget] Client site URL:', clientSiteUrl);
                
                if (!clientSiteUrl) {
                    console.error('[Luna Widget] No client site URL found in profile');
                    return;
                }

                // Fetch the widget HTML/CSS/JS from the client's WordPress site with vl_key parameter
                const widgetHtmlUrl = `${clientSiteUrl.replace(/\/$/, '')}/wp-json/luna_widget/v1/widget/html?vl_key=${encodeURIComponent(licenseKey)}`;
                
                console.log('[Luna Widget] Fetching widget from:', widgetHtmlUrl);
                
                try {
                    const widgetResponse = await fetch(widgetHtmlUrl, {
                        method: 'GET',
                        credentials: 'include',
                        mode: 'cors'
                    });
                    
                    console.log('[Luna Widget] Widget response status:', widgetResponse.status);
                    
                    if (widgetResponse.ok) {
                        const widgetData = await widgetResponse.json();
                        console.log('[Luna Widget] Widget data received:', widgetData);
                        
                        if (widgetData.ok && widgetData.html) {
                            console.log('[Luna Widget] Injecting widget HTML/CSS/JS...');
                            
                            // Inject CSS first
                            if (widgetData.css) {
                                const style = document.createElement('style');
                                style.id = 'luna-widget-embed-styles';
                                style.textContent = widgetData.css;
                                // Remove existing styles if present
                                const existing = document.getElementById('luna-widget-embed-styles');
                                if (existing) existing.remove();
                                document.head.appendChild(style);
                                console.log('[Luna Widget] CSS injected');
                            }
                            
                            // Inject HTML - position in bottom left corner
                            container.innerHTML = widgetData.html;
                            container.style.position = 'fixed';
                            container.style.bottom = '20px';
                            container.style.left = '20px';
                            container.style.zIndex = '2147483646';
                            console.log('[Luna Widget] HTML injected into container');
                            
                            // Inject JavaScript after a short delay to ensure DOM is ready
                            if (widgetData.js) {
                                setTimeout(function() {
                                    const script = document.createElement('script');
                                    script.id = 'luna-widget-embed-script';
                                    // Remove existing script if present
                                    const existing = document.getElementById('luna-widget-embed-script');
                                    if (existing) existing.remove();
                                    script.textContent = widgetData.js;
                                    document.body.appendChild(script);
                                    console.log('[Luna Widget] Widget loaded successfully');
                                    
                                    // After widget loads, setup launcher to open chat directly
                                    setTimeout(function() {
                                        setupLunaLauncherPopup(licenseKey);
                                    }, 500);
                                }, 100);
                            } else {
                                console.warn('[Luna Widget] Widget HTML loaded, but no JavaScript provided');
                            }
                            return;
                        } else if (widgetData.error) {
                            console.error('[Luna Widget] Widget not available:', widgetData.error);
                            return;
                        } else {
                            console.error('[Luna Widget] Widget data missing ok or html:', widgetData);
                            return;
                        }
                    } else {
                        const errorText = await widgetResponse.text();
                        console.error('[Luna Widget] Failed to fetch widget:', widgetResponse.status, errorText);
                        return;
                    }
                } catch (e) {
                    console.error('[Luna Widget] Could not fetch widget HTML:', e);
                    return;
                }
                
            } catch (error) {
                console.error('[Luna Widget] Error loading widget:', error);
            }
        }

        // Store launcher handler reference for removal
        let lunaLauncherClickHandler = null;
        
        /**
         * Setup Luna Launcher Popup - Intercepts launcher click to show popup with four buttons
         */
        function setupLunaLauncherPopup(licenseKey) {
            console.log('[Luna Widget] Setting up launcher direct open...');
            
            // Remove existing handler if any
            if (lunaLauncherClickHandler) {
                document.body.removeEventListener('click', lunaLauncherClickHandler, true);
            }
            
            // Use event delegation on document body to catch launcher clicks
            // Directly open chat panel and start new session
            lunaLauncherClickHandler = function(e) {
                const launcher = e.target.closest('.luna-launcher');
                if (launcher) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    
                    console.log('[Luna Widget] Launcher clicked - opening chat directly...');
                    
                    const panel = document.getElementById('luna-panel');
                    const overlay = document.querySelector('.luna-overlay');
                    const thread = panel ? panel.querySelector('.luna-thread') : null;
                    const input = panel ? panel.querySelector('.luna-input') : null;
                    const sendButton = panel ? panel.querySelector('.luna-send') : null;
                    
                    // Open panel
                        if (panel) {
                            panel.classList.add('show');
                        panel.style.display = '';
                            if (overlay) {
                                overlay.classList.add('show');
                            overlay.style.display = '';
                            }
                            launcher.setAttribute('aria-expanded', 'true');
                        }
                    
                    // Clear thread and start new session
                    if (thread) {
                        thread.innerHTML = '';
                        
                        // Get client name for personalized greeting
                        const clientNameEl = document.getElementById('clientName');
                        let clientName = clientNameEl ? clientNameEl.textContent.trim() : 'there';
                        // Fallback if clientName is empty or default
                        if (!clientName || clientName === 'Client') {
                            clientName = 'there';
                        }
                        const greeting = `Hi, ${clientName}, how would you like to explore your data and content today?`;
                        
                        // Add personalized greeting (replace any default greeting)
                        const greetingMsg = document.createElement('div');
                        greetingMsg.className = 'luna-msg luna-assistant';
                        greetingMsg.textContent = greeting;
                        thread.appendChild(greetingMsg);
                        thread.scrollTop = thread.scrollHeight;
                        
                        // Remove any default "Please provide a message" greeting if widget added it
                        setTimeout(function() {
                            const threadMessages = thread.querySelectorAll('.luna-msg');
                            threadMessages.forEach(function(msg) {
                                if (msg.textContent && msg.textContent.includes('Please provide a message')) {
                                    msg.remove();
                                }
                            });
                        }, 100);
                    }
                    
                    // Start new chat session
                    try {
                        const sessionUrl = 'https://visiblelight.ai/wp-json/luna_widget/v1/chat/session-start';
                        fetch(sessionUrl, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-Luna-License': licenseKey
                            },
                            credentials: 'include',
                            body: JSON.stringify({
                                session_id: 'session_' + Date.now(),
                                started_at: new Date().toISOString()
                            })
                        }).catch(err => console.warn('[Luna Widget] Session start error:', err));
                    } catch (err) {
                        console.warn('[Luna Widget] Session start error:', err);
                    }
                    
                    // Fix Send button functionality
                    if (sendButton && input) {
                        // Remove existing click handlers and add new one
                        const newSendButton = sendButton.cloneNode(true);
                        sendButton.parentNode.replaceChild(newSendButton, sendButton);
                        
                        newSendButton.addEventListener('click', function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            handleLunaSend(input, thread, licenseKey);
                        });
                    }
                    
                    // Also ensure Enter key works (this should already be handled by widget, but ensure it calls our handler)
                    if (input) {
                        input.addEventListener('keydown', function(e) {
                            if (e.key === 'Enter' && !e.shiftKey) {
                                e.preventDefault();
                                handleLunaSend(input, thread, licenseKey);
                            }
                        });
                    }
                    
                    // Focus input after a short delay
                    setTimeout(function() {
                        if (input) {
                            input.focus();
                        }
                    }, 100);
                    
                    return false;
                }
            };
            
            // Add capture phase listener to intercept before widget's handlers
            document.body.addEventListener('click', lunaLauncherClickHandler, true);
            
            console.log('[Luna Widget] Launcher direct open handler registered');
        }
        
        // Handle sending Luna messages
        function handleLunaSend(input, thread, licenseKey) {
            const message = input.value.trim();
            if (!message) return;
            
            // Clear input
            input.value = '';
            
            // Add user message to thread
            const userMsg = document.createElement('div');
            userMsg.className = 'luna-msg luna-user';
            userMsg.textContent = message;
            thread.appendChild(userMsg);
            thread.scrollTop = thread.scrollHeight;
            
            // Show loading indicator
            const loadingMsg = document.createElement('div');
            loadingMsg.className = 'luna-msg luna-assistant';
            loadingMsg.id = 'luna-loading-indicator';
            loadingMsg.innerHTML = '<span class="luna-loader" style="display: inline-block; width: 16px; height: 16px; border: 2px solid #5A5753; border-top-color: #fff4e9; border-radius: 50%; animation: luna-spin 0.8s linear infinite; margin-right: 8px; vertical-align: middle;"></span>Luna is exploring all possibilities...';
            
            // Add CSS animation if not already added
            if (!document.getElementById('luna-loader-style')) {
                const style = document.createElement('style');
                style.id = 'luna-loader-style';
                style.textContent = '@keyframes luna-spin { to { transform: rotate(360deg); } }';
                document.head.appendChild(style);
            }
            
            thread.appendChild(loadingMsg);
            thread.scrollTop = thread.scrollHeight;
            
            // Collect conversation history from thread (exclude loading indicator)
            const conversationHistory = [];
            const threadMessages = thread.querySelectorAll('.luna-msg:not(#luna-loading-indicator)');
            threadMessages.forEach(function(msgEl) {
                // Skip loading indicator
                if (msgEl.id === 'luna-loading-indicator') {
                    return;
                }
                
                const isUser = msgEl.classList.contains('luna-user');
                const isAssistant = msgEl.classList.contains('luna-assistant');
                const content = msgEl.textContent.trim();
                
                if ((isUser || isAssistant) && content) {
                    conversationHistory.push({
                        role: isUser ? 'user' : 'assistant',
                        content: content
                    });
                }
            });
            
            // Send message to chat endpoint with conversation history
            fetch('https://visiblelight.ai/wp-json/luna_widget/v1/chat', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Luna-License': licenseKey
                },
                credentials: 'include',
                mode: 'cors',
                body: JSON.stringify({
                    prompt: message,
                    license: licenseKey,
                    history: conversationHistory
                })
            })
            .then(async response => {
                // Check if response is OK
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('[Luna Widget] Chat endpoint error:', response.status, errorText);
                    let errorData;
                    try {
                        errorData = JSON.parse(errorText);
                    } catch (e) {
                        errorData = { answer: errorText || 'Server error occurred' };
                    }
                    throw new Error(errorData.answer || errorData.error || `HTTP ${response.status}: ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                // Remove loading indicator
                const loadingEl = document.getElementById('luna-loading-indicator');
                if (loadingEl) {
                    loadingEl.remove();
                }
                
                // Add Luna's response
                if (data && data.answer) {
                    const lunaMsg = document.createElement('div');
                    lunaMsg.className = 'luna-msg luna-assistant';
                    lunaMsg.textContent = data.answer;
                    thread.appendChild(lunaMsg);
                    thread.scrollTop = thread.scrollHeight;
                } else {
                    console.error('[Luna Widget] Invalid response data:', data);
                    const errorMsg = document.createElement('div');
                    errorMsg.className = 'luna-msg luna-assistant';
                    errorMsg.textContent = data && data.error ? data.error : 'Sorry, I encountered an error. Please try again.';
                    thread.appendChild(errorMsg);
                    thread.scrollTop = thread.scrollHeight;
                }
            })
            .catch(error => {
                // Handle CORS and network errors gracefully
                console.error('[Luna Widget] Chat error:', error);
                
                // Check if it's a CORS or network error
                const isCorsError = error.message && (
                    error.message.includes('CORS') || 
                    error.message.includes('NetworkError') || 
                    error.message.includes('Failed to fetch') ||
                    error.name === 'TypeError' ||
                    error.name === 'NetworkError'
                );
                
                // Remove loading indicator
                const loadingEl = document.getElementById('luna-loading-indicator');
                if (loadingEl) {
                    loadingEl.remove();
                }
                
                // Show error message with more detail
                const errorMsg = document.createElement('div');
                errorMsg.className = 'luna-msg luna-assistant';
                let errorText = 'Sorry, I encountered an error. Please try again.';
                
                // Provide user-friendly error messages
                if (isCorsError) {
                    errorText = 'Connection error. Please check your internet connection and try again.';
                } else if (error.message) {
                    errorText = error.message;
                }
                
                errorMsg.textContent = errorText;
                thread.appendChild(errorMsg);
                thread.scrollTop = thread.scrollHeight;
            });
        }
        
        /**
         * Show Luna Action Popup with four buttons
         * NOTE: This function is no longer used - launcher now opens chat directly
         * Keeping for backwards compatibility but it should not be called
         */
        function showLunaActionPopup(licenseKey) {
            console.log('[Luna Widget] showLunaActionPopup called but popup functionality has been removed');
            // Popup functionality removed - launcher now opens chat directly
            return;
            
            // Remove existing popup if any
            const existingPopup = document.getElementById('luna-action-popup');
            if (existingPopup) {
                existingPopup.remove();
            }
            
            // Create popup overlay
            const popupOverlay = document.createElement('div');
            popupOverlay.id = 'luna-action-popup';
            popupOverlay.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.5); z-index: 2147483647; display: flex; align-items: center; justify-content: center;';
            
            // Create popup container (styled like luna-msg.luna-assistant)
            const popupContainer = document.createElement('div');
            popupContainer.style.cssText = 'background: rgba(0,0,0,.5); border: 1px solid #1f1d1a; border-radius: 12px; padding: 24px; max-width: 400px; width: 90%; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5); position: relative;backdrop-filter:blur(8px);';
            
            // Create message text (like luna-assistant)
            const messageText = document.createElement('div');
            messageText.className = 'luna-msg luna-assistant';
            messageText.style.cssText = 'color: #fff4e9; font-size: 1rem; font-weight: 500;padding-right: 10px; line-height: 1.6; margin-bottom: 16px;';
            messageText.textContent = "Hi, there! I'm Luna, your WebOps AI assistant. How would you like to continue?";
            
            // Create button container
            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = 'display: flex; flex-direction: column; gap: 8px;';
            
            // Chat Button
            const chatButton = document.createElement('button');
            chatButton.className = 'luna-chat-button';
            chatButton.textContent = 'Luna Chat';
            chatButton.style.cssText = 'padding: 10px 16px; background: linear-gradient(270deg, #974C00 0%, #8D8C00 100%); color: #000; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; width: 100%;';
            chatButton.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                popupOverlay.remove();
                
                // Temporarily disable our launcher handler, then trigger launcher click
                setTimeout(function() {
                    const launcher = document.querySelector('.luna-launcher');
                    if (launcher) {
                        // Mark launcher to skip popup
                        launcher.dataset.skipPopup = 'true';
                        
                        // Create and dispatch click event to trigger widget's native open logic
                        const clickEvent = new MouseEvent('click', {
                            bubbles: true,
                            cancelable: true,
                            view: window
                        });
                        launcher.dispatchEvent(clickEvent);
                        
                        // Remove the skip flag after a short delay
                        setTimeout(function() {
                            delete launcher.dataset.skipPopup;
                        }, 1000);
                        
                        // Wait for panel to open, then focus input
                        setTimeout(function() {
                            const lunaPanel = document.getElementById('luna-panel');
                            const lunaOverlay = document.querySelector('.luna-overlay');
                            if (lunaPanel) {
                                lunaPanel.classList.add('show');
                                lunaPanel.style.display = ''; // Remove inline style to let CSS handle it
                                if (lunaOverlay) {
                                    lunaOverlay.classList.add('show');
                                    lunaOverlay.style.display = ''; // Remove inline style to let CSS handle it
                                }
                            }
                            const lunaInput = document.querySelector('.luna-input');
                            if (lunaInput) {
                                lunaInput.focus();
                            }
                        }, 200);
                    } else {
                        // Fallback: manually show panel if launcher not found
                        const lunaPanel = document.getElementById('luna-panel');
                        const lunaOverlay = document.querySelector('.luna-overlay');
                        if (lunaPanel) {
                            lunaPanel.classList.add('show');
                            lunaPanel.style.display = ''; // Remove inline style to let CSS handle it
                            if (lunaOverlay) {
                                lunaOverlay.classList.add('show');
                                lunaOverlay.style.display = ''; // Remove inline style to let CSS handle it
                            }
                            setTimeout(function() {
                                const lunaInput = document.querySelector('.luna-input');
                                if (lunaInput) {
                                    lunaInput.focus();
                                }
                            }, 100);
                        }
                    }
                }, 50);
            });
            
            // Compose Button
            const composeButton = document.createElement('button');
            composeButton.className = 'luna-compose-button';
            composeButton.textContent = 'Luna Compose';
            composeButton.style.cssText = 'padding: 10px 16px; background: #000; color: #fff4e9; border: 1px solid #1f1d1a; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; width: 100%;';
            composeButton.addEventListener('click', function() {
                const composeUrl = `https://supercluster.visiblelight.ai/?license=${encodeURIComponent(licenseKey)}/luna-compose`;
                window.location.href = composeUrl;
            });
            
            // Report Button
            const reportButton = document.createElement('button');
            reportButton.className = 'luna-report-button';
            reportButton.textContent = 'Luna Report';
            reportButton.style.cssText = 'padding: 10px 16px; background: #000; color: #fff4e9; border: 1px solid #1f1d1a; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; width: 100%;';
            reportButton.addEventListener('click', function() {
                const reportUrl = `https://supercluster.visiblelight.ai/?license=${encodeURIComponent(licenseKey)}/luna/report`;
                window.location.href = reportUrl;
            });
            
            // Automate Button
            const automateButton = document.createElement('button');
            automateButton.className = 'luna-automate-button';
            automateButton.textContent = 'Luna Automate';
            automateButton.style.cssText = 'padding: 10px 16px; background: #000; color: #fff4e9; border: 1px solid #1f1d1a; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; width: 100%;';
            automateButton.addEventListener('click', function() {
                const automateUrl = `https://supercluster.visiblelight.ai/?license=${encodeURIComponent(licenseKey)}/luna/automate`;
                window.location.href = automateUrl;
            });
            
            // Close button (X)
            const closeButton = document.createElement('button');
            closeButton.innerHTML = '×';
            closeButton.style.cssText = 'position: absolute; top: 8px; right: 8px; background: transparent; border: none; color: #fff4e9; font-size: 24px; cursor: pointer; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; line-height: 1;';
            closeButton.addEventListener('click', function() {
                popupOverlay.remove();
            });
            
            // Assemble popup
            buttonContainer.appendChild(chatButton);
            buttonContainer.appendChild(composeButton);
            buttonContainer.appendChild(reportButton);
            buttonContainer.appendChild(automateButton);
            popupContainer.appendChild(messageText);
            popupContainer.appendChild(buttonContainer);
            popupContainer.appendChild(closeButton);
            popupOverlay.appendChild(popupContainer);
            
            // Close on overlay click
            popupOverlay.addEventListener('click', function(e) {
                if (e.target === popupOverlay) {
                    popupOverlay.remove();
                }
            });
            
            // Add to page
            document.body.appendChild(popupOverlay);
        }

        // Function to modify Luna greeting message and add buttons
        // NOTE: This is now handled natively in the Luna Widget plugin
        // Keeping this as a fallback for backwards compatibility, but it should not be needed
        function modifyLunaGreeting(licenseKey) {
            console.log('[Luna Widget] Modifying greeting message...');
            
            // Helper function to add buttons to a message element
            function addButtonsToMessage(messageElement) {
                // Check if buttons already added
                if (messageElement.querySelector('.luna-chat-button')) {
                    console.log('[Luna Widget] Buttons already added to this message');
                    return;
                }
                
                // Find the parent message bubble or container
                let container = messageElement;
                // Try to find a parent that looks like a message bubble
                while (container && container.parentElement) {
                    if (container.classList.contains('luna-message') || 
                        container.classList.contains('message') ||
                        container.querySelector('.luna-message')) {
                        break;
                    }
                    container = container.parentElement;
                }
                
                // If we couldn't find a specific container, use the element itself
                if (!container || container === document.body) {
                    container = messageElement;
                }
                
                // Found the greeting, add buttons
                const buttonContainer = document.createElement('div');
                buttonContainer.style.cssText = 'margin-top: 12px; display: flex; gap: 8px; flex-direction: column;';
                
                const chatButton = document.createElement('button');
                chatButton.className = 'luna-chat-button';
                chatButton.textContent = 'Luna Chat';
                chatButton.style.cssText = 'padding: 10px 16px; background: linear-gradient(270deg, #974C00 0%, #8D8C00 100%); color: #000; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; width: 100%;';
                chatButton.addEventListener('click', function() {
                    const lunaInput = document.querySelector('.luna-input');
                    if (lunaInput) {
                        lunaInput.focus();
                    }
                });
                
                const composeButton = document.createElement('button');
                composeButton.className = 'luna-compose-button';
                composeButton.textContent = 'Luna Compose';
                composeButton.style.cssText = 'padding: 10px 16px; background: #000; color: #fff4e9; border: 1px solid #1f1d1a; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; width: 100%;';
                composeButton.addEventListener('click', function() {
                    const composeUrl = `https://supercluster.visiblelight.ai/?license=${encodeURIComponent(licenseKey)}/luna-compose`;
                    window.location.href = composeUrl;
                });
                
                buttonContainer.appendChild(chatButton);
                buttonContainer.appendChild(composeButton);
                container.appendChild(buttonContainer);
                
                console.log('[Luna Widget] Buttons added to greeting message');
                return true;
            }
            
            // Try to find existing greeting message first
            function checkForExistingGreeting() {
                const lunaThread = document.querySelector('.luna-thread') || document.querySelector('.luna-panel') || document.querySelector('[class*="luna"]');
                if (!lunaThread) {
                    return false;
                }
                
                // Look for any message containing the greeting text
                const allMessages = lunaThread.querySelectorAll('*');
                for (let i = 0; i < allMessages.length; i++) {
                    const element = allMessages[i];
                    const text = element.textContent || element.innerText || '';
                    if ((text.includes("Hi, there! I'm Luna") || 
                         text.includes("I'm Luna") ||
                         text.includes("How would you like to continue")) &&
                        !element.querySelector('.luna-chat-button')) {
                        if (addButtonsToMessage(element)) {
                            return true;
                        }
                    }
                }
                return false;
            }
            
            // Check for existing greeting immediately
            if (checkForExistingGreeting()) {
                console.log('[Luna Widget] Found existing greeting and added buttons');
                return;
            }
            
            // Find the Luna thread/panel where messages appear
            const lunaThread = document.querySelector('.luna-thread') || 
                              document.querySelector('.luna-panel') || 
                              document.querySelector('[class*="luna"]');
            
            if (!lunaThread) {
                console.warn('[Luna Widget] Luna thread not found, retrying...');
                setTimeout(function() {
                    modifyLunaGreeting(licenseKey);
                }, 1000);
                return;
            }
            
            // Use MutationObserver to watch for greeting message - don't interfere with loading
            // This passively waits for the greeting to appear without blocking it
            console.log('[Luna Widget] Setting up observer for greeting message...');
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    mutation.addedNodes.forEach(function(node) {
                        if (node.nodeType === 1) { // Element node
                            const text = node.textContent || node.innerText || '';
                            // Check for various forms of the greeting
                            if (text.includes("Hi, there! I'm Luna") || 
                                text.includes("I'm Luna") ||
                                text.includes("How would you like to continue") ||
                                (text.includes("Luna") && text.includes("WebOps"))) {
                                if (addButtonsToMessage(node)) {
                                    observer.disconnect();
                                }
                            }
                        }
                    });
                });
            });
                
            observer.observe(lunaThread, { childList: true, subtree: true });
            
            // Also check periodically in case observer misses it
            let checkCount = 0;
            const checkInterval = setInterval(function() {
                checkCount++;
                if (checkForExistingGreeting()) {
                    observer.disconnect();
                    clearInterval(checkInterval);
                } else if (checkCount >= 20) { // Stop after 20 seconds
                    observer.disconnect();
                    clearInterval(checkInterval);
                    console.warn('[Luna Widget] Greeting message not found after 20 seconds');
                }
            }, 1000);
            
            // Observer will continue running to allow full loading of all data streams
            // No timeout - let it run until data is fully loaded
        }

            // Load widget after page initialization - try multiple times to ensure DOM is ready
            console.log('[Luna Widget] Scheduling widget load...');
            setTimeout(checkAndLoadLunaWidget, 1000);
            setTimeout(checkAndLoadLunaWidget, 2000);
            setTimeout(checkAndLoadLunaWidget, 3000);

            // Widget hide/show toggle functionality
            function initWidgetToggle() {
            const toggleButtons = document.querySelectorAll('.vl-widget-toggle');
            
            toggleButtons.forEach(function(button) {
                // Skip if already initialized
                if (button.dataset.initialized === 'false') return;
                button.dataset.initialized = 'false';
                
                const widgetId = button.getAttribute('data-widget');
                const widget = document.getElementById(widgetId);
                if (!widget) return;
                
                const widgetBody = widget.querySelector('.vl-widget-body');
                if (!widgetBody) return;
                
                // Get or create the icon element
                let icon = button.querySelector('.vl-toggle-icon');
                if (!icon) {
                    icon = document.createElement('img');
                    icon.className = 'vl-toggle-icon';
                    button.appendChild(icon);
                }
                
                // Set initial state based on whether widget body is hidden
                const isHidden = widgetBody.classList.contains('vl-widget-body-hidden');
                if (isHidden) {
                    // Widget is hidden, show "Show" state
                    icon.src = 'https://visiblelight.ai/wp-content/uploads/2025/11/vl-eye-icon.svg';
                    icon.alt = 'Show';
                    button.setAttribute('aria-label', 'Show widget');
                } else {
                    // Widget is visible, show "Hide" state
                    icon.src = 'https://visiblelight.ai/wp-content/uploads/2025/11/vl-eye-hide-icon.svg';
                    icon.alt = 'Hide';
                    button.setAttribute('aria-label', 'Hide widget');
                }
                
                button.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const widgetId = button.getAttribute('data-widget');
                    const widget = document.getElementById(widgetId);
                    if (!widget) return;
                    
                    const widgetBody = widget.querySelector('.vl-widget-body');
                    if (!widgetBody) return;
                    
                    const isHidden = widgetBody.classList.contains('vl-widget-body-hidden');
                    
                    // Get or create the icon element
                    let icon = button.querySelector('.vl-toggle-icon');
                    if (!icon) {
                        icon = document.createElement('img');
                        icon.className = 'vl-toggle-icon';
                        button.appendChild(icon);
                    }
                    
                    if (isHidden) {
                        // Show the widget body
                        widgetBody.classList.remove('vl-widget-body-hidden');
                        icon.src = 'https://visiblelight.ai/wp-content/uploads/2025/11/vl-eye-hide-icon.svg';
                        icon.alt = 'Hide';
                        button.setAttribute('aria-label', 'Hide widget');
                    } else {
                        // Hide the widget body
                        widgetBody.classList.add('vl-widget-body-hidden');
                        icon.src = 'https://visiblelight.ai/wp-content/uploads/2025/11/vl-eye-icon.svg';
                        icon.alt = 'Show';
                        button.setAttribute('aria-label', 'Show widget');
                    }
                });
            });
        }
        
        // Initialize on DOM ready or immediately if already loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initWidgetToggle);
        } else {
            initWidgetToggle();
        }
        // ============================================================
        // Luna Composer Functions
        // ============================================================
        
        // Use a canned prompt - send to Luna and populate editor
        // Make it globally accessible
        // Scroll function for canned prompts list
        window.scrollCannedPrompts = function(button, direction) {
            const wrapper = button.closest('.canned-prompts-wrapper');
            if (!wrapper) return;
            
            const list = wrapper.querySelector('.canned-prompts-list');
            if (!list) return;
            
            // Scroll amount (adjust as needed)
            const scrollAmount = 400;
            const currentScroll = list.scrollLeft;
            const newScroll = currentScroll + (scrollAmount * direction);
            
            list.scrollTo({
                left: newScroll,
                behavior: 'smooth'
            });
            
            // Update arrow visibility after a short delay to allow scroll to complete
            setTimeout(() => {
                updateCannedPromptsArrows(list, wrapper);
            }, 100);
        };
        
        // Update arrow visibility based on scroll position
        function updateCannedPromptsArrows(list, wrapper) {
            if (!list || !wrapper) return;
            
            const leftBtn = wrapper.querySelector('.canned-prompts-scroll-left');
            const rightBtn = wrapper.querySelector('.canned-prompts-scroll-right');
            
            if (!leftBtn || !rightBtn) return;
            
            const scrollLeft = list.scrollLeft;
            const scrollWidth = list.scrollWidth;
            const clientWidth = list.clientWidth;
            const maxScroll = scrollWidth - clientWidth;
            
            // Show/hide left arrow
            if (scrollLeft > 0) {
                leftBtn.style.display = 'block';
            } else {
                leftBtn.style.display = 'none';
            }
            
            // Show/hide right arrow
            if (scrollLeft < maxScroll - 1) { // -1 for rounding issues
                rightBtn.style.display = 'block';
            } else {
                rightBtn.style.display = 'none';
            }
        }
        
        // Initialize scroll arrows when Luna Composer is rendered
        function initializeCannedPromptsScroll() {
            const list = document.querySelector('.canned-prompts-list');
            if (!list) return;
            
            const wrapper = list.closest('.canned-prompts-wrapper');
            if (!wrapper) return;
            
            // Initial check
            updateCannedPromptsArrows(list, wrapper);
            
            // Update on scroll
            list.addEventListener('scroll', () => {
                updateCannedPromptsArrows(list, wrapper);
            });
            
            // Update on resize
            window.addEventListener('resize', () => {
                updateCannedPromptsArrows(list, wrapper);
            });
        }
        
        // Mode toggle removed - reimagine is now always available in toolbar

        function resetReimagineButton() {
            const reimagineBtn = document.getElementById('luna-composer-reimagine-btn');
            if (!reimagineBtn) return;

            reimagineBtn.style.pointerEvents = 'none';
            reimagineBtn.style.cursor = 'not-allowed';
            reimagineBtn.style.color = '#9A9793';
            reimagineBtn.style.background = '#2E2C2A50';
            reimagineBtn.disabled = true;

            const span = reimagineBtn.querySelector('span');
            if (span) {
                span.textContent = 'Reimagine';
            }

            reimagineBtn.removeAttribute('data-active-mode');
        }

        function updateReimagineButtonState() {
            const editor = document.getElementById('luna-composer-editor');
            const reimagineBtn = document.getElementById('luna-composer-reimagine-btn');

            if (!editor || !reimagineBtn) {
                return;
            }

            const text = editor.innerText || editor.textContent || '';
            const hasContent = text.trim().length > 0;
            
            if (hasContent) {
                reimagineBtn.style.pointerEvents = 'auto';
                reimagineBtn.style.cursor = 'pointer';
                reimagineBtn.style.color = '#fff4e9';
                reimagineBtn.style.background = '#2E2C2A';
                reimagineBtn.disabled = false;
            } else {
                resetReimagineButton();
                hideReimagineMenu();
                if (window.lunaComposerReimagineState) {
                    window.lunaComposerReimagineState.currentMode = null;
                    window.lunaComposerReimagineState.highlightRange = null;
                }
                hideHighlightTooltip();
            }
        }

        function ensureReimagineState() {
            if (!window.lunaComposerReimagineState) {
                window.lunaComposerReimagineState = {
                    currentMode: null,
                    highlightRange: null
                };
            }
            return window.lunaComposerReimagineState;
        }

        function hideReimagineMenu() {
            const menu = document.getElementById('luna-composer-reimagine-menu');
            if (menu) {
                menu.style.display = 'none';
            }
        }

        function hideHighlightTooltip() {
            const tooltip = document.getElementById('luna-composer-highlight-tooltip');
            if (tooltip) {
                tooltip.style.display = 'none';
            }

            const state = ensureReimagineState();
            state.highlightRange = null;
        }

        window.lunaComposerToggleReimagineMenu = function(event) {
            const reimagineBtn = document.getElementById('luna-composer-reimagine-btn');
            const menu = document.getElementById('luna-composer-reimagine-menu');

            if (!reimagineBtn || !menu || reimagineBtn.disabled) {
                return;
            }

            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }

            const isOpen = menu.style.display === 'block';
            hideReimagineMenu();

            if (!isOpen) {
                menu.style.display = 'block';
            }
        };

        window.lunaComposerSelectReimagineMode = function(mode) {
            const reimagineBtn = document.getElementById('luna-composer-reimagine-btn');
            const editor = document.getElementById('luna-composer-editor');
            const state = ensureReimagineState();

            hideReimagineMenu();

            if (!reimagineBtn || !editor) {
                return;
            }

            const span = reimagineBtn.querySelector('span');

            if (mode === 'highlight') {
                if (state.currentMode === 'highlight') {
                    state.currentMode = null;
                    reimagineBtn.removeAttribute('data-active-mode');
                    if (span) {
                        span.textContent = 'Reimagine';
                    }
                    hideHighlightTooltip();
                } else {
                    state.currentMode = 'highlight';
                    reimagineBtn.setAttribute('data-active-mode', 'highlight');
                    if (span) {
                        span.textContent = 'Highlight to Reimagine';
                    }
                    handleHighlightSelection();
                }
                return;
            }

            state.currentMode = null;
            reimagineBtn.removeAttribute('data-active-mode');
            if (span) {
                span.textContent = 'Reimagine';
            }

            hideHighlightTooltip();

            if (mode === 'branding' || mode === 'linguistics') {
                reimagineFullDocument(mode);
            }
        };

        function handleHighlightSelection() {
            const state = ensureReimagineState();
            if (state.currentMode !== 'highlight') {
                hideHighlightTooltip();
                return;
            }

            const editor = document.getElementById('luna-composer-editor');
            const tooltip = document.getElementById('luna-composer-highlight-tooltip');
            if (!editor || !tooltip) {
                return;
            }

            const selection = window.getSelection();
            if (!selection || selection.rangeCount === 0) {
                hideHighlightTooltip();
                return;
            }

            const range = selection.getRangeAt(0);
            if (!editor.contains(range.commonAncestorContainer)) {
                hideHighlightTooltip();
                return;
            }

            const selectedText = selection.toString();
            if (!selectedText || !selectedText.trim()) {
                hideHighlightTooltip();
                return;
            }

            const rect = range.getBoundingClientRect();
            tooltip.style.display = 'flex';
            tooltip.style.top = Math.max(16, rect.top - 12) + 'px';
            tooltip.style.left = rect.left + rect.width / 2 + 'px';
            tooltip.style.transform = 'translate(-50%, -100%)';

            state.highlightRange = range.cloneRange();
        }

        window.lunaComposerReimagineHighlightedText = async function() {
            const state = ensureReimagineState();
            const range = state.highlightRange;
            const tooltip = document.getElementById('luna-composer-highlight-tooltip');
            const actionBtn = document.getElementById('luna-composer-highlight-action');

            if (!range || !actionBtn) {
                hideHighlightTooltip();
                return;
            }

            const selectedText = range.toString();
            if (!selectedText || !selectedText.trim()) {
                hideHighlightTooltip();
                return;
            }

            const originalLabel = actionBtn.textContent;
            actionBtn.disabled = true;
            actionBtn.textContent = 'Reimagining...';

            try {
                const answer = await requestLunaReimagine('highlight', selectedText.trim());
                if (answer) {
                    replaceRangeWithContent(range, answer);
                    updateReimagineButtonState();
                    setTimeout(() => {
                        window.lunaComposerUpdateHeartState();
                    }, 100);
                }
            } catch (error) {
                console.error('[Luna Composer] Highlight reimagine failed:', error);
                window.showVLNotification('Failed to reimagine the highlighted text. Please try again.', 'error');
            } finally {
                actionBtn.disabled = false;
                actionBtn.textContent = originalLabel;
                hideHighlightTooltip();
            }
        };

        async function reimagineFullDocument(mode) {
            const editor = document.getElementById('luna-composer-editor');
            const reimagineBtn = document.getElementById('luna-composer-reimagine-btn');
            if (!editor || !reimagineBtn) {
                return;
            }

            const text = editor.innerText || editor.textContent || '';
            if (!text.trim()) {
                window.showVLNotification('Please enter some text to reimagine.', 'error');
                return;
            }
            
            const span = reimagineBtn.querySelector('span');
            const originalLabel = span ? span.textContent : '';

            reimagineBtn.disabled = true;
            reimagineBtn.style.pointerEvents = 'none';
            reimagineBtn.style.cursor = 'wait';
            if (span) {
                span.textContent = 'Reimagining...';
            }

            const originalHtml = editor.innerHTML;
            editor.innerHTML = '<div class="luna-composer-loading-text" style="display: flex; align-items: center; justify-content: center; padding: 40px; text-align: center;"><div class="luna-composer-loading-icon"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2" stroke-dasharray="31.416" stroke-dashoffset="31.416" stroke-linecap="round"><animate attributeName="stroke-dasharray" dur="2s" values="0 31.416;15.708 15.708;0 31.416;0 31.416" repeatCount="indefinite"/><animate attributeName="stroke-dashoffset" dur="2s" values="0;-15.708;-31.416;-31.416" repeatCount="indefinite"/></circle></svg></div><span class="luna-composer-loading-text">Luna is considering all possibilities...</span></div>';

            try {
                const answer = await requestLunaReimagine(mode, text.trim());
                if (answer) {
                    const formattedAnswer = formatComposerAnswer(answer);
                    editor.innerHTML = formattedAnswer;
                    editor.scrollTop = 0;
                    editor.dispatchEvent(new Event('input', { bubbles: true }));
                    
                    // Add automation prompts
                    const licenseKey = editor.getAttribute('data-license-key');
                    const promptText = editor.getAttribute('data-prompt') || text.trim();
                    lunaComposerRenderAutomationPrompts(formattedAnswer, promptText, licenseKey);
                    
                    setTimeout(() => {
                        window.lunaComposerUpdateHeartState();
                    }, 100);
                    } else {
                    throw new Error('No response from Luna');
                }
            } catch (error) {
                console.error('[Luna Composer] Error reimagining document:', error);
                window.showVLNotification('Failed to reimagine content. Please try again.', 'error');
                editor.innerHTML = originalHtml;
            } finally {
                if (span) {
                    span.textContent = 'Reimagine';
                }
                reimagineBtn.disabled = false;
                reimagineBtn.style.pointerEvents = 'auto';
                reimagineBtn.style.cursor = 'pointer';
                reimagineBtn.style.background = '#2E2C2A';
                reimagineBtn.style.color = '#fff4e9';
                updateReimagineButtonState();
            }
        }

        async function requestLunaReimagine(mode, text) {
            const licenseKey = extractLicenseKey();
                if (!licenseKey) {
                    throw new Error('License key not found');
                }
                
            let message;
            if (mode === 'highlight') {
                message = 'Please refine and enhance the following highlighted selection using Luna\'s GPT-4o and VL Hub insights. Preserve the intent and context while improving clarity and impact.\n\n' + text;
            } else if (mode === 'branding') {
                message = 'Please rewrite the following content with a compelling brand voice that aligns with the client\'s business, leveraging VL Hub data and historical insights. Maintain key information while elevating tone and resonance.\n\n' + text;
            } else if (mode === 'linguistics') {
                message = 'Please revise the following content for grammar, linguistics, and readability using Luna\'s advanced checks while keeping the original message intact.\n\n' + text;
            } else {
                message = text;
            }

                // Fetch client data for context
                const clientData = await lunaComposerFetchClientData(licenseKey);

                try {
                const response = await fetch('https://visiblelight.ai/wp-json/luna_widget/v1/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                        mode: 'cors',
                    body: JSON.stringify({
                    message: message,
                        license: licenseKey,
                        context: 'composer',
                        client_data: clientData, // Include client data for data-driven responses
                        use_hub_data: true // Flag to indicate backend should use Hub data
                    })
                    }).catch(error => {
                        // Handle CORS and network errors
                        console.error('[Luna Composer] Chat fetch error:', error);
                        if (error.message && (error.message.includes('CORS') || error.message.includes('NetworkError') || error.message.includes('Failed to fetch'))) {
                            throw new Error('Network connection error. Please check your internet connection and try again.');
                        }
                        throw error;
                });
                
                if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`HTTP ${response.status}: ${errorText || response.statusText}`);
                }
                
                const data = await response.json();
            if (!data || !data.answer) {
                throw new Error('No response from Luna');
            }

            return data.answer;
                } catch (error) {
                    // Handle all errors including CORS
                    console.error('[Luna Composer] Error in chat request:', error);
                    throw error;
                }
        }

        function extractLicenseKey() {
            const urlParams = new URLSearchParams(window.location.search);
            const urlLicense = urlParams.get('license') || '';
            if (!urlLicense) {
                return '';
            }

            const match = urlLicense.match(/^([^/]+)/);
            if (match) {
                return match[1];
            }

            return urlLicense;
        }

        // Initialize heading style selector
        function initHeadingStyleSelector() {
            const headingBtn = document.getElementById('headingStyleSelectBtn');
            const dropdown = document.getElementById('headingStyleDropdown');
            const editor = document.getElementById('luna-composer-editor');
            
            if (!headingBtn || !dropdown || !editor) {
                // Retry after a short delay if elements aren't ready
                setTimeout(initHeadingStyleSelector, 200);
                return;
            }
            
            // Toggle dropdown on button click
            headingBtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                const isVisible = dropdown.style.display !== 'none';
                dropdown.style.display = isVisible ? 'none' : 'block';
            });
            
            // Close dropdown when clicking outside
            document.addEventListener('click', function(e) {
                if (!headingBtn.contains(e.target) && !dropdown.contains(e.target)) {
                    dropdown.style.display = 'none';
                }
            });
            
            // Handle heading style selection
            const options = dropdown.querySelectorAll('.heading-style-option');
            options.forEach(function(option) {
                option.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    const style = option.getAttribute('data-style');
                    applyHeadingStyle(style);
                    dropdown.style.display = 'none';
                });
            });
        }
        
        // Apply heading style to selected text
        function applyHeadingStyle(style) {
            const editor = document.getElementById('luna-composer-editor');
            if (!editor) return;
            
            // Get selection
            const selection = window.getSelection();
            if (!selection || selection.rangeCount === 0) {
                // No selection - can't apply style
                return;
            }
            
            const range = selection.getRangeAt(0);
            if (range.collapsed) {
                // No text selected - can't apply style
                return;
            }
            
            // Get selected content
            const selectedText = range.toString();
            if (!selectedText.trim()) return;
            
            // Define font sizes for each heading style
            const fontSizes = {
                'h1': '2rem',
                'h2': '1.5rem',
                'h3': '1.25rem',
                'h4': '1.1rem',
                'h5': '1rem',
                'h6': '0.9rem',
                'normal': '0.875rem'
            };
            
            const fontWeight = style === 'normal' ? '400' : '700';
            const fontSize = fontSizes[style] || '0.875rem';
            
            // Create a span with the style
            const span = document.createElement('span');
            span.style.fontSize = fontSize;
            span.style.fontWeight = fontWeight;
            span.textContent = selectedText;
            
            // Replace selected content
            range.deleteContents();
            range.insertNode(span);
            
            // Clear selection
            selection.removeAllRanges();
            
            // Focus editor
            editor.focus();
        }

        function formatComposerAnswer(answer) {
            if (!answer) {
                return '';
            }

            let cleaned = answer.trim();
            
            // Remove markdown special characters:
            // 1. Remove asterisks used for bold/italic (**text** or *text*)
            // First remove double asterisks (bold)
            cleaned = cleaned.replace(/\*\*([^*]+)\*\*/g, '$1'); // Remove **text** but keep text
            // Then remove single asterisks used for italic (but be careful not to remove standalone asterisks)
            cleaned = cleaned.replace(/\*([^*\n]+)\*/g, '$1'); // Remove *text* but keep text (not at line start/end)
            
            // 2. Remove dashes at the beginning of lines (markdown list items like "- Heading")
            cleaned = cleaned.replace(/^-\s+/gm, ''); // Remove "- " at start of lines
            
            // 3. Remove hashtags from headings (e.g., # Heading, ## Heading, etc.)
            cleaned = cleaned.replace(/^#+\s+/gm, '');
            
            const hasHtml = /<\/?[a-z][\s\S]*>/i.test(cleaned);
            if (hasHtml) {
                return cleaned;
            }

            // Process plain text into HTML paragraphs
            const normalized = cleaned.replace(/\r\n/g, '\n');
            const paragraphs = normalized.split(/\n\n+/).map(para => para.replace(/\n/g, '<br>'));
            return '<p>' + paragraphs.join('</p><p>') + '</p>';
        }

        function replaceRangeWithContent(range, content) {
            if (!range) {
                return;
            }

            const editor = document.getElementById('luna-composer-editor');
            if (!editor) {
                return;
            }

            range.deleteContents();

            let insertionContent = content ? content.trim() : '';
            let nodes = [];

            if (insertionContent && /<\/?[a-z][\s\S]*>/i.test(insertionContent)) {
                const temp = document.createElement('div');
                temp.innerHTML = insertionContent;
                while (temp.firstChild) {
                    nodes.push(temp.firstChild);
                    temp.removeChild(temp.firstChild);
                }
            } else if (insertionContent) {
                nodes.push(document.createTextNode(insertionContent.replace(/\s+/g, ' ').trim()));
            }

            const fragment = document.createDocumentFragment();
            let lastNode = null;
            nodes.forEach(node => {
                lastNode = node;
                fragment.appendChild(node);
            });

            if (fragment.childNodes.length) {
                range.insertNode(fragment);
            }

            const selection = window.getSelection();
            if (selection) {
                selection.removeAllRanges();
                const newRange = document.createRange();

                if (lastNode) {
                    if (lastNode.nodeType === Node.TEXT_NODE) {
                        newRange.setStart(lastNode, lastNode.textContent.length);
                        newRange.setEnd(lastNode, lastNode.textContent.length);
                    } else {
                        newRange.selectNode(lastNode);
                        newRange.collapse(false);
                    }
                } else {
                    newRange.setStart(range.endContainer, range.endOffset);
                    newRange.collapse(true);
                }

                selection.addRange(newRange);
            }

            editor.dispatchEvent(new Event('input', { bubbles: true }));
        }

        function initializeLunaComposerIntelligentMode() {
            const editor = document.getElementById('luna-composer-editor');

            if (!editor) {
                return;
            }

            if (!window.lunaComposerIntelligentInitialized) {
                window.lunaComposerIntelligentInitialized = true;

                editor.addEventListener('input', () => {
                    updateReimagineButtonState();
                });

                editor.addEventListener('paste', () => {
                    setTimeout(() => {
                        updateReimagineButtonState();
                    }, 100);
                });

                editor.addEventListener('mouseup', () => {
                    handleHighlightSelection();
                });

                editor.addEventListener('keyup', () => {
                    handleHighlightSelection();
                });

                document.addEventListener('selectionchange', () => {
                    const state = ensureReimagineState();
                    if (state.currentMode === 'highlight') {
                        handleHighlightSelection();
                    }
                });

                document.addEventListener('click', (event) => {
                    const wrapper = document.getElementById('luna-composer-reimagine-wrapper');
                    const tooltip = document.getElementById('luna-composer-highlight-tooltip');
                    const menu = document.getElementById('luna-composer-reimagine-menu');

                    if (menu && menu.style.display === 'block' && wrapper && !wrapper.contains(event.target)) {
                        hideReimagineMenu();
                    }

                    if (tooltip && tooltip.style.display === 'flex') {
                        if (!tooltip.contains(event.target) && !editor.contains(event.target)) {
                            hideHighlightTooltip();
                        }
                    }
                });

                window.addEventListener('scroll', () => {
                    const state = ensureReimagineState();
                    if (state.currentMode === 'highlight') {
                        hideHighlightTooltip();
                    }
                }, true);

                window.addEventListener('resize', () => {
                    const state = ensureReimagineState();
                    if (state.currentMode === 'highlight') {
                        hideHighlightTooltip();
                    }
                });
            }

            const highlightAction = document.getElementById('luna-composer-highlight-action');
            if (highlightAction && !highlightAction.dataset.listenerAttached) {
                highlightAction.addEventListener('click', (event) => {
                    event.preventDefault();
                    event.stopPropagation();
                    window.lunaComposerReimagineHighlightedText();
                });
                highlightAction.dataset.listenerAttached = 'true';
            }

            updateReimagineButtonState();
        }
        
        // Category filtering functions
        window.lunaComposerFilterByCategory = function(categoryName) {
            console.log('[Luna Composer] Filtering by category:', categoryName);
            window.lunaComposerSelectedCategory = categoryName || null;
            
            // Update dropdown value
            const dropdown = document.getElementById('luna-composer-category-dropdown');
            if (dropdown) {
                dropdown.value = categoryName || '';
            }
            
            // Filter items
            const promptItems = document.querySelectorAll('.canned-prompt-item');
            let visibleCount = 0;
            promptItems.forEach(item => {
                if (!categoryName || categoryName === '') {
                    // Show all items
                    item.style.display = 'block';
                    visibleCount++;
                } else {
                const itemCategories = item.getAttribute('data-categories') || '';
                const categories = itemCategories.split(',').map(c => c.trim());
                if (categories.includes(categoryName)) {
                    item.style.display = 'block';
                    visibleCount++;
                } else {
                    item.style.display = 'none';
                    }
                }
            });
            
            console.log('[Luna Composer] Showing', visibleCount, 'items for category:', categoryName || 'All');
        };
        
        window.lunaComposerResetCategoryFilter = function() {
            console.log('[Luna Composer] Resetting category filter');
            window.lunaComposerSelectedCategory = null;
            
            // Reset dropdown
            const dropdown = document.getElementById('luna-composer-category-dropdown');
            if (dropdown) {
                dropdown.value = '';
            }
            
            // Show all items
            const promptItems = document.querySelectorAll('.canned-prompt-item');
            promptItems.forEach(item => {
                item.style.display = 'block';
            });
            
            console.log('[Luna Composer] Showing all', promptItems.length, 'items');
        };

        function lunaComposerNormalizeActionText(text) {
            return (text || '').replace(/\s+/g, ' ').replace(/^[^:]+:\s*/, '').trim();
        }

        function lunaComposerInferTeam(actionText) {
            const lower = (actionText || '').toLowerCase();
            if (lower.match(/security|waf|tls|ssl|firewall|vuln|patch/)) return 'Security';
            if (lower.match(/plugin|theme|code|dev|engineering|bug|fix|update/)) return 'Engineering';
            if (lower.match(/content|copy|page|post|blog|seo/)) return 'Content';
            if (lower.match(/campaign|ads?|marketing|engagement/)) return 'Marketing';
            return 'Operations';
        }

        function lunaComposerExtractActionables(answerHtml) {
            const tmp = document.createElement('div');
            tmp.innerHTML = answerHtml || '';
            const rawText = (tmp.textContent || '').replace(/\u00a0/g, ' ').trim();
            if (!rawText) return [];

            const lines = rawText.split(/\n+/).map(line => line.trim()).filter(Boolean);
            const actions = [];

            const pushAction = (value) => {
                const normalized = lunaComposerNormalizeActionText(value);
                if (normalized && !actions.includes(normalized)) {
                    actions.push(normalized);
                }
            };

            lines.forEach((line, idx) => {
                if (/^next steps?/i.test(line)) {
                    const afterColon = line.split(/:/)[1];
                    if (afterColon) {
                        pushAction(afterColon);
                    } else if (lines[idx + 1]) {
                        pushAction(lines[idx + 1]);
                    }
                    if (lines[idx + 2] && lines[idx + 2].startsWith('-')) {
                        pushAction(lines[idx + 2]);
                    }
                }

                if (/^recommendations?/i.test(line)) {
                    const afterColon = line.split(/:/)[1];
                    if (afterColon) {
                        pushAction(afterColon);
                    }
                    for (let offset = 1; offset <= 3; offset++) {
                        if (lines[idx + offset] && /^[-•]/.test(lines[idx + offset])) {
                            pushAction(lines[idx + offset]);
                        }
                    }
                }

                if (/^actionable next steps?/i.test(line)) {
                    const afterColon = line.split(/:/)[1];
                    if (afterColon) pushAction(afterColon);
                    if (lines[idx + 1]) pushAction(lines[idx + 1]);
                }
            });

            return actions.slice(0, 3);
        }

        function lunaComposerScheduleFollowup(promptText, licenseKey, type) {
            const payload = {
                prompt: lunaComposerNormalizeActionText(promptText),
                license: licenseKey || null,
                created: Date.now(),
                type: type || 'followup'
            };
            try {
                localStorage.setItem('lunaComposerFollowupPrompt', JSON.stringify(payload));
            } catch (e) {
                console.warn('[Luna Composer] Failed to cache follow-up prompt:', e);
            }

            const newWin = window.open(window.location.href, '_blank');
            if (!newWin) {
                window.showVLNotification('Please allow pop-ups so Luna can open the follow-up in a new tab.', 'error');
            }
        }

        function lunaComposerRenderActionables(answerHtml, promptText, licenseKey) {
            const editor = document.getElementById('luna-composer-editor');
            if (!editor) return;

            const existing = document.getElementById('luna-composer-actionables');
            if (existing) existing.remove();

            const actions = lunaComposerExtractActionables(answerHtml);
            if (!actions.length) return;

            const wrapper = document.createElement('div');
            wrapper.id = 'luna-composer-actionables';
            wrapper.style.cssText = 'margin-top: 16px; padding: 16px; border: 1px solid #1f1d1a; border-radius: 8px; background: #0b0b0b; display: flex; flex-direction: column; gap: 12px; color: #fff4e9;';

            const heading = document.createElement('div');
            heading.textContent = 'Make Luna\'s recommendations actionable:';
            heading.style.cssText = 'font-weight: 700; font-size: 1rem;';
            wrapper.appendChild(heading);

            actions.forEach((actionText, index) => {
                const actionRow = document.createElement('div');
                actionRow.style.cssText = 'border-top: 1px solid #1f1d1a; padding-top: 12px; margin-top: 12px; display: flex; flex-direction: column; gap: 10px;';

                const actionLabel = document.createElement('div');
                actionLabel.style.cssText = 'font-weight: 600; color: #d9d5d0;';
                actionLabel.textContent = 'Recommendation ' + (index + 1) + ': ' + actionText;
                actionRow.appendChild(actionLabel);

                const followupPrompt = 'Would you like me to save this doc and run a new prompt with this recommendation?';
                const followupBlock = document.createElement('div');
                followupBlock.style.cssText = 'display: flex; flex-wrap: wrap; gap: 8px; align-items: center;';
                const followupText = document.createElement('span');
                followupText.textContent = followupPrompt;
                followupText.style.cssText = 'flex: 1; min-width: 220px; color: #c8c4be;';
                followupBlock.appendChild(followupText);

                const yesFollow = document.createElement('button');
                yesFollow.textContent = 'Yes — open follow-up';
                yesFollow.style.cssText = 'background: #8D8C00; color: #000; border: none; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-weight: 700;';
                yesFollow.addEventListener('click', () => {
                    lunaComposerScheduleFollowup(actionText, licenseKey, 'recommendation');
                });

                const noFollow = document.createElement('button');
                noFollow.textContent = 'No';
                noFollow.style.cssText = 'background: #2E2C2A; color: #fff4e9; border: 1px solid #1f1d1a; padding: 8px 12px; border-radius: 6px; cursor: pointer;';
                noFollow.addEventListener('click', () => {
                    noFollow.disabled = true;
                });

                followupBlock.appendChild(yesFollow);
                followupBlock.appendChild(noFollow);
                actionRow.appendChild(followupBlock);

                const team = lunaComposerInferTeam(actionText);
                const ticketText = document.createElement('span');
                ticketText.textContent = 'Would you like me to formulate a ticket summary for your ' + team + ' team?';
                ticketText.style.cssText = 'flex: 1; min-width: 220px; color: #c8c4be;';

                const ticketBlock = document.createElement('div');
                ticketBlock.style.cssText = 'display: flex; flex-wrap: wrap; gap: 8px; align-items: center;';
                ticketBlock.appendChild(ticketText);

                const yesTicket = document.createElement('button');
                yesTicket.textContent = 'Yes — draft ticket';
                yesTicket.style.cssText = 'background: #5A5753; color: #fff4e9; border: 1px solid #1f1d1a; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-weight: 700;';
                yesTicket.addEventListener('click', () => {
                    const ticketPrompt = 'Create a hand-off ready ticket summary for the ' + team + ' team to address: ' + actionText + '. Include context, expected impact, and a concise checklist.';
                    lunaComposerScheduleFollowup(ticketPrompt, licenseKey, 'ticket');
                });

                const noTicket = document.createElement('button');
                noTicket.textContent = 'No';
                noTicket.style.cssText = 'background: #2E2C2A; color: #fff4e9; border: 1px solid #1f1d1a; padding: 8px 12px; border-radius: 6px; cursor: pointer;';
                noTicket.addEventListener('click', () => {
                    noTicket.disabled = true;
                });

                ticketBlock.appendChild(yesTicket);
                ticketBlock.appendChild(noTicket);
                actionRow.appendChild(ticketBlock);

                // WordPress Post Automation Block
                const wpPostText = document.createElement('span');
                wpPostText.textContent = 'Would you like me to turn this into a WordPress Post?';
                wpPostText.style.cssText = 'flex: 1; min-width: 220px; color: #c8c4be;';

                const wpPostBlock = document.createElement('div');
                wpPostBlock.style.cssText = 'display: flex; flex-wrap: wrap; gap: 8px; align-items: center; margin-top: 8px;';
                wpPostBlock.appendChild(wpPostText);

                const autoPostBtn = document.createElement('button');
                autoPostBtn.textContent = 'Auto-post now';
                autoPostBtn.style.cssText = 'background: linear-gradient(270deg, #974C00 0%, #8D8C00 100%); color: #000; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: 700; transition: opacity 0.2s;';
                autoPostBtn.addEventListener('click', async () => {
                    autoPostBtn.disabled = true;
                    autoPostBtn.textContent = 'Posting...';
                    autoPostBtn.style.opacity = '0.6';
                    
                    try {
                        await window.lunaComposerAutoPostFromRecommendation(actionText, licenseKey, editor);
                    } catch (error) {
                        console.error('[Luna Composer] Auto-post failed:', error);
                        window.showVLNotification('Failed to create WordPress post: ' + (error.message || 'Unknown error'), 'error');
                        autoPostBtn.disabled = false;
                        autoPostBtn.textContent = 'Auto-post now';
                        autoPostBtn.style.opacity = '1';
                    }
                });

                wpPostBlock.appendChild(autoPostBtn);
                actionRow.appendChild(wpPostBlock);

                wrapper.appendChild(actionRow);
            });

            editor.appendChild(wrapper);
        }
        
        // Extract actionable items from response text more broadly
        function lunaComposerExtractAutomationActions(answerHtml) {
            const tmp = document.createElement('div');
            tmp.innerHTML = answerHtml || '';
            const rawText = (tmp.textContent || '').replace(/\u00a0/g, ' ').trim();
            if (!rawText) return [];
            
            const actions = [];
            const lines = rawText.split(/\n+/).map(line => line.trim()).filter(Boolean);
            
            // Look for common action patterns
            const actionPatterns = [
                /^(recommendations?|next steps?|action items?|suggestions?|actions?|steps?|tasks?)[:\.]?\s*(.+)/i,
                /^[-•*]\s*(.+)/, // Bullet points
                /(?:should|could|would|can|must|need to|consider|implement|create|generate|build|develop|optimize|improve|enhance|update|review|analyze|audit|monitor|track|measure|evaluate|assess|establish|set up|configure|deploy|launch|publish|share|post|write|draft|design|plan|execute|perform|complete|finish|deliver|submit|send|schedule|automate)/i
            ];
            
            // Extract from sections like "Recommendations", "Next Steps", etc.
            let inActionSection = false;
            lines.forEach((line, idx) => {
                const lowerLine = line.toLowerCase();
                
                // Detect action sections
                if (/^(recommendations?|next steps?|action items?|suggestions?|actions?|steps?|tasks?|automation|automate)/i.test(line)) {
                    inActionSection = true;
                    // Extract items after the header
                    for (let i = idx + 1; i < Math.min(idx + 10, lines.length); i++) {
                        if (lines[i] && /^[-•*]/.test(lines[i])) {
                            const actionText = lines[i].replace(/^[-•*]\s*/, '').trim();
                            if (actionText && actionText.length > 10) {
                                actions.push(actionText);
                            }
                        } else if (lines[i] && lines[i].length > 0 && !/^#/.test(lines[i])) {
                            // Non-header line in action section
                            if (lines[i].length > 20 && lines[i].length < 200) {
                                actions.push(lines[i]);
                            }
                        } else {
                            break;
                        }
                    }
                }
                
                // Extract bullet points anywhere
                if (/^[-•*]\s*(.+)/.test(line)) {
                    const actionText = line.replace(/^[-•*]\s*/, '').trim();
                    if (actionText && actionText.length > 15 && actionText.length < 200) {
                        // Check if it's an actionable item
                        if (actionPatterns[2].test(actionText)) {
                            actions.push(actionText);
                        }
                    }
                }
            });
            
            // Remove duplicates and limit to top 5
            const uniqueActions = [];
            actions.forEach(action => {
                const normalized = action.trim();
                if (normalized && !uniqueActions.includes(normalized) && normalized.length > 10) {
                    uniqueActions.push(normalized);
                }
            });
            
            return uniqueActions.slice(0, 5);
        }
        
        // Fetch client data from VL Hub for context
        async function lunaComposerFetchClientData(licenseKey) {
            console.log('[Luna Composer] Fetching client data for context...');
            
            // Cache key for storing client data
            const CACHE_KEY = `luna_composer_client_data_${licenseKey}`;
            const CACHE_TIMESTAMP_KEY = `luna_composer_client_data_timestamp_${licenseKey}`;
            const CACHE_MAX_AGE = 24 * 60 * 60 * 1000; // 24 hours
            
            // Try to get cached data first (as fallback)
            let cachedData = null;
            try {
                const cachedDataStr = localStorage.getItem(CACHE_KEY);
                const cachedTimestamp = localStorage.getItem(CACHE_TIMESTAMP_KEY);
                if (cachedDataStr && cachedTimestamp) {
                    const age = Date.now() - parseInt(cachedTimestamp, 10);
                    if (age < CACHE_MAX_AGE) {
                        cachedData = JSON.parse(cachedDataStr);
                        console.log('[Luna Composer] Found cached client data (age: ' + Math.round(age / 1000 / 60) + ' minutes)');
                    }
                }
            } catch (cacheError) {
                console.warn('[Luna Composer] Error reading cache:', cacheError);
            }
            
            const clientData = {
                connections: {},
                streams: {},
                wordpress_data: null,
                profile: null
            };
            
            let fetchSuccessful = false;
            
            try {
                // Fetch content/connections data in parallel with timeout
                const fetchWithTimeout = (url, options, timeout = 10000) => {
                    return Promise.race([
                        fetch(url, options),
                        new Promise((_, reject) => 
                            setTimeout(() => reject(new Error('Request timeout')), timeout)
                        )
                    ]);
                };
                
                const [contentResult, connectionsResult] = await Promise.allSettled([
                    fetchWithTimeout(`https://visiblelight.ai/wp-json/vl-hub/v1/content?license=${encodeURIComponent(licenseKey)}`, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        mode: 'cors'
                    }).catch(error => {
                        console.warn('[Luna Composer] Content fetch failed:', error);
                        throw error;
                    }),
                    fetchWithTimeout(`https://visiblelight.ai/wp-json/vl-hub/v1/all-connections?license=${encodeURIComponent(licenseKey)}`, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        mode: 'cors'
                    }).catch(error => {
                        console.warn('[Luna Composer] Connections fetch failed:', error);
                        throw error;
                    })
                ]);
                
                // Process content result
                if (contentResult.status === 'fulfilled' && contentResult.value.ok) {
                    const contentData = await contentResult.value.json();
                    const data = contentData?.ok && contentData?.data ? contentData.data : contentData;
                    if (data) {
                        // Get streams
                        const streams = data.client_streams || data.streams || {};
                        if (Object.keys(streams).length > 0) {
                            clientData.streams = streams;
                        }
                        
                        // Get WordPress data - check multiple possible locations
                        let wpData = null;
                        
                        // Priority 1: Check wordpress_content from /content endpoint
                        if (data.wordpress_content && typeof data.wordpress_content === 'object') {
                            // Convert wordpress_content structure to wordpress_data format
                            wpData = {
                                posts_total: data.wordpress_content.total_posts || (data.wordpress_content.posts ? data.wordpress_content.posts.length : 0),
                                pages_total: data.wordpress_content.total_pages || (data.wordpress_content.pages ? data.wordpress_content.pages.length : 0),
                                posts_data: data.wordpress_content.posts || [],
                                pages_data: data.wordpress_content.pages || []
                            };
                            console.log('[Luna Composer] Found WordPress data in wordpress_content:', wpData);
                        }
                        
                        // Priority 2: Check wordpress_data
                        if (!wpData && data.wordpress_data && typeof data.wordpress_data === 'object') {
                            wpData = data.wordpress_data;
                            console.log('[Luna Composer] Found WordPress data in wordpress_data');
                        }
                        
                        // Priority 3: Check if WordPress data is in a stream
                        if (!wpData && streams) {
                            for (const streamId in streams) {
                                const stream = streams[streamId];
                                if (stream && typeof stream === 'object') {
                                    // Check if this stream contains WordPress data
                                    if (stream.wp_version || stream.wp_core_data || stream.posts_data || stream.pages_data ||
                                        stream.posts_total || stream.pages_total || stream.plugins_data || stream.themes_data ||
                                        (stream.name && stream.name.toLowerCase().includes('wordpress'))) {
                                        wpData = stream;
                                        console.log('[Luna Composer] Found WordPress data in stream:', streamId);
                                        break;
                                    }
                                }
                            }
                        }
                        
                        if (wpData) {
                            clientData.wordpress_data = wpData;
                            console.log('[Luna Composer] WordPress data extracted:', {
                                posts_total: wpData.posts_total || (wpData.posts_data ? wpData.posts_data.length : 0),
                                pages_total: wpData.pages_total || (wpData.pages_data ? wpData.pages_data.length : 0),
                                has_posts_data: !!(wpData.posts_data && wpData.posts_data.length > 0),
                                has_pages_data: !!(wpData.pages_data && wpData.pages_data.length > 0)
                            });
                        } else {
                            console.warn('[Luna Composer] No WordPress data found in content response');
                        }
                        
                        clientData.connections = data;
                    }
                }
                
                // Process connections result
                if (connectionsResult.status === 'fulfilled' && connectionsResult.value.ok) {
                    const connectionsData = await connectionsResult.value.json();
                    const data = connectionsData?.ok && connectionsData?.data ? connectionsData.data : connectionsData;
                    if (data) {
                        // Merge streams
                        const allStreams = data.client_streams || data.streams || {};
                        if (Object.keys(allStreams).length > 0) {
                            // Merge with existing streams
                            clientData.streams = { ...clientData.streams, ...allStreams };
                        }
                        
                        // If WordPress data not found yet, check in connections data
                        if (!clientData.wordpress_data) {
                            let wpData = null;
                            
                            // Check wordpress_content in connections data
                            if (data.wordpress_content && typeof data.wordpress_content === 'object') {
                                wpData = {
                                    posts_total: data.wordpress_content.total_posts || (data.wordpress_content.posts ? data.wordpress_content.posts.length : 0),
                                    pages_total: data.wordpress_content.total_pages || (data.wordpress_content.pages ? data.wordpress_content.pages.length : 0),
                                    posts_data: data.wordpress_content.posts || [],
                                    pages_data: data.wordpress_content.pages || []
                                };
                                console.log('[Luna Composer] Found WordPress data in connections wordpress_content');
                            }
                            
                            // Check wordpress_data
                            if (!wpData && data.wordpress_data && typeof data.wordpress_data === 'object') {
                                wpData = data.wordpress_data;
                            }
                            
                            // Check streams in connections data
                            if (!wpData && allStreams) {
                                for (const streamId in allStreams) {
                                    const stream = allStreams[streamId];
                                    if (stream && typeof stream === 'object') {
                                        if (stream.wp_version || stream.wp_core_data || stream.posts_data || stream.pages_data ||
                                            stream.posts_total || stream.pages_total || stream.plugins_data || stream.themes_data ||
                                            (stream.name && stream.name.toLowerCase().includes('wordpress'))) {
                                            wpData = stream;
                                            console.log('[Luna Composer] Found WordPress data in connections stream:', streamId);
                                            break;
                                        }
                                    }
                                }
                            }
                            
                            if (wpData) {
                                clientData.wordpress_data = wpData;
                            }
                        }
                        
                        // Merge connections
                        clientData.connections = { ...clientData.connections, ...data };
                        
                        // CRITICAL: Also merge client_streams from connections data into clientData.streams
                        // The all-connections endpoint returns streams in client_streams, not streams
                        if (data.client_streams && typeof data.client_streams === 'object') {
                            clientData.streams = { ...clientData.streams, ...data.client_streams };
                            console.log('[Luna Composer] Merged client_streams from connections. Total streams now:', Object.keys(clientData.streams).length);
                        }
                    }
                }
                
                // Extract analytics data from streams (GA4, Search Console, Lighthouse, etc.)
                // IMPORTANT: Check both clientData.streams AND clientData.connections.client_streams
                const allStreamsForAnalytics = {
                    ...clientData.streams,
                    ...(clientData.connections?.client_streams || {})
                };
                
                console.log('[Luna Composer] Preparing to extract analytics. Streams available:', Object.keys(allStreamsForAnalytics).length);
                console.log('[Luna Composer] Stream IDs:', Object.keys(allStreamsForAnalytics).slice(0, 10));
                
                const analytics = {
                    ga4: null,
                    search_console: null,
                    lighthouse: [],
                    competitor: []
                };
                
                // Extract key insights from streams
                const insights = {
                    total_streams: Object.keys(allStreamsForAnalytics).length,
                    stream_categories: {},
                    active_streams: 0,
                    health_scores: [],
                    anomalies: [],
                    patterns: []
                };
                
                console.log('[Luna Composer] Extracting analytics from streams. Total streams:', Object.keys(allStreamsForAnalytics).length);
                console.log('[Luna Composer] Stream IDs:', Object.keys(allStreamsForAnalytics));
                
                Object.values(allStreamsForAnalytics).forEach(stream => {
                    if (stream.status === 'active') insights.active_streams++;
                    if (stream.health_score) insights.health_scores.push(stream.health_score);
                    if (stream.categories) {
                        stream.categories.forEach(cat => {
                            insights.stream_categories[cat] = (insights.stream_categories[cat] || 0) + 1;
                        });
                    }
                    
                    // Extract GA4 data - check multiple possible stream ID patterns and properties
                    const streamId = stream.id || '';
                    const isGA4Stream = streamId.startsWith('ga4_') || 
                                       streamId.includes('ga4') || 
                                       (stream.name && stream.name.toLowerCase().includes('google analytics')) ||
                                       !!stream.ga4_property_id ||
                                       !!stream.ga4_metrics;
                    
                    if (isGA4Stream && stream.ga4_metrics) {
                        console.log('[Luna Composer] Found GA4 stream:', streamId, stream.name);
                        analytics.ga4 = {
                            property_id: stream.ga4_property_id || streamId,
                            name: stream.name || 'Google Analytics 4',
                            last_synced: stream.ga4_last_synced || stream.last_updated,
                            date_range: stream.ga4_date_range || {},
                            metrics: {
                                totalUsers: parseInt(stream.ga4_metrics.totalUsers) || 0,
                                newUsers: parseInt(stream.ga4_metrics.newUsers) || 0,
                                activeUsers: parseInt(stream.ga4_metrics.activeUsers) || 0,
                                sessions: parseInt(stream.ga4_metrics.sessions) || 0,
                                screenPageViews: parseInt(stream.ga4_metrics.screenPageViews) || 0,
                                bounceRate: parseFloat(stream.ga4_metrics.bounceRate) || 0,
                                averageSessionDuration: parseFloat(stream.ga4_metrics.averageSessionDuration) || 0,
                                engagementRate: parseFloat(stream.ga4_metrics.engagementRate) || 0,
                                engagedSessions: parseInt(stream.ga4_metrics.engagedSessions) || 0,
                                eventCount: parseInt(stream.ga4_metrics.eventCount) || 0,
                                conversions: parseInt(stream.ga4_metrics.conversions) || 0,
                                totalRevenue: parseFloat(stream.ga4_metrics.totalRevenue) || 0
                            },
                            dimensions: {
                                geographic: stream.ga4_dimensions?.geographic?.rows || stream.ga4_geographic || [],
                                device: stream.ga4_dimensions?.device?.rows || stream.ga4_device || [],
                                traffic: stream.ga4_dimensions?.traffic?.rows || stream.ga4_traffic || [],
                                pages: stream.ga4_dimensions?.pages?.rows || stream.ga4_pages || [],
                                events: stream.ga4_dimensions?.events?.rows || stream.ga4_events || []
                            }
                        };
                        console.log('[Luna Composer] Extracted GA4 data:', {
                            users: analytics.ga4.metrics.totalUsers,
                            sessions: analytics.ga4.metrics.sessions,
                            pageViews: analytics.ga4.metrics.screenPageViews,
                            has_dimensions: !!(analytics.ga4.dimensions.geographic.length || analytics.ga4.dimensions.device.length || analytics.ga4.dimensions.pages.length)
                        });
                    }
                    
                    // Extract Google Search Console data
                    if (stream.id === 'google_search_console' || (stream.name && stream.name.toLowerCase().includes('search console'))) {
                        analytics.search_console = {
                            name: stream.name || 'Google Search Console',
                            last_sync: stream.last_sync || stream.last_updated,
                            data_points: stream.data_points || 0,
                            search_queries: stream.gsc_data?.search_queries || [],
                            top_pages: stream.gsc_data?.top_pages || [],
                            countries: stream.gsc_data?.countries || [],
                            devices: stream.gsc_data?.devices || [],
                            date_range: stream.gsc_data?.date_range || []
                        };
                        console.log('[Luna Composer] Extracted Search Console data:', {
                            queries: analytics.search_console.search_queries.length,
                            pages: analytics.search_console.top_pages.length
                        });
                    }
                    
                    // Extract Lighthouse reports
                    if (stream.id && stream.id.startsWith('lighthouse_') && stream.report_data) {
                        analytics.lighthouse.push({
                            report_id: stream.report_id,
                            url: stream.url || stream.source_url,
                            date: stream.report_data.date || stream.last_updated,
                            scores: {
                                performance: stream.report_data.performance_score || 0,
                                accessibility: stream.report_data.accessibility_score || 0,
                                best_practices: stream.report_data.best_practices_score || 0,
                                seo: stream.report_data.seo_score || 0,
                                overall: stream.report_data.overall_score || 0
                            },
                            opportunities: stream.report_data.opportunities || [],
                            passed_audits: stream.report_data.passed_audits || []
                        });
                    }
                    
                    // Extract Competitor data
                    if (stream.id && stream.id.startsWith('competitor_') && stream.report_data) {
                        analytics.competitor.push({
                            name: stream.name,
                            url: stream.competitor_url || stream.source_url,
                            last_analysis: stream.last_analysis || stream.last_updated,
                            domain_ranking: stream.vl_dr || stream.report_data.domain_ranking || 0,
                            lighthouse: stream.report_data.lighthouse || {},
                            public_pages: stream.report_data.public_pages || 0,
                            top_keywords: stream.report_data.top_keywords || [],
                            meta_info: stream.report_data.meta_info || {}
                        });
                    }
                    
                    // Detect anomalies (low health scores, errors)
                    if (stream.health_score && stream.health_score < 70) {
                        insights.anomalies.push({
                            stream: stream.name || stream.id,
                            issue: 'Low health score',
                            score: stream.health_score
                        });
                    }
                    if (stream.error_count && stream.error_count > 0) {
                        insights.anomalies.push({
                            stream: stream.name || stream.id,
                            issue: 'Has errors',
                            count: stream.error_count
                        });
                    }
                });
                
                // Calculate average health score
                if (insights.health_scores.length > 0) {
                    insights.avg_health_score = insights.health_scores.reduce((a, b) => a + b, 0) / insights.health_scores.length;
                }
                
                // Add analytics to clientData
                clientData.analytics = analytics;
                clientData.insights = insights;
                
                console.log('[Luna Composer] Analytics data extracted:', {
                    has_ga4: !!analytics.ga4,
                    has_search_console: !!analytics.search_console,
                    lighthouse_reports: analytics.lighthouse.length,
                    competitor_analyses: analytics.competitor.length
                });
                
                // Debug: Log analytics data structure
                if (analytics.ga4) {
                    console.log('[Luna Composer] GA4 data structure:', {
                        has_metrics: !!analytics.ga4.metrics,
                        has_dimensions: !!analytics.ga4.dimensions,
                        users: analytics.ga4.metrics?.totalUsers,
                        sessions: analytics.ga4.metrics?.sessions
                    });
                }
                
                fetchSuccessful = true;
                
                // Cache the successfully fetched data
                try {
                    localStorage.setItem(CACHE_KEY, JSON.stringify(clientData));
                    localStorage.setItem(CACHE_TIMESTAMP_KEY, Date.now().toString());
                    console.log('[Luna Composer] Client data cached for offline use');
                } catch (cacheError) {
                    console.warn('[Luna Composer] Error caching data:', cacheError);
                }
                
                console.log('[Luna Composer] Client data fetched:', {
                    streams: Object.keys(clientData.streams).length,
                    insights: insights
                });
            } catch (error) {
                console.warn('[Luna Composer] Error fetching client data from VL Hub:', error);
                
                // If fetch failed, use cached data if available
                if (cachedData) {
                    console.log('[Luna Composer] Using cached client data due to fetch failure');
                    Object.assign(clientData, cachedData);
                    // Mark that we're using cached data
                    clientData._cached = true;
                    clientData._cacheAge = Date.now() - parseInt(localStorage.getItem(CACHE_TIMESTAMP_KEY), 10);
                } else {
                    console.warn('[Luna Composer] No cached data available, continuing without client data');
                    // Continue without data - Luna can still respond with general knowledge
                }
            }
            
            return clientData;
        }
        
        // Render automation prompts at the end of every response
        function lunaComposerRenderAutomationPrompts(answerHtml, promptText, licenseKey) {
            const editor = document.getElementById('luna-composer-editor');
            if (!editor) return;
            
            // Remove existing automation prompts
            const existing = document.getElementById('luna-composer-automation-prompts');
            if (existing) existing.remove();
            
            // Extract actionable items
            const actions = lunaComposerExtractAutomationActions(answerHtml);
            
            // Always show automation section, even if no specific actions found
            const wrapper = document.createElement('div');
            wrapper.id = 'luna-composer-automation-prompts';
            wrapper.style.cssText = 'margin-top: 24px; padding: 20px 0; border-top: 2px solid #1f1d1a; display: flex; flex-direction: column; gap: 16px; color: #fff4e9;';
            
            
            // If we have specific actions, create buttons for them
            if (actions.length > 0) {
                actions.forEach((actionText, index) => {
                    // Create a simplified action text for the button
                    let buttonText = actionText;
                    if (buttonText.length > 60) {
                        buttonText = buttonText.substring(0, 57) + '...';
                    }
                    
                    // Determine automation type based on action text
                    const lowerAction = actionText.toLowerCase();
                    let automationType = 'general';
                    let automationLabel = 'Automate';
                    
                    if (lowerAction.includes('post') || lowerAction.includes('blog') || lowerAction.includes('article') || lowerAction.includes('content') || lowerAction.includes('write')) {
                        automationType = 'wordpress-post';
                        automationLabel = 'Create WordPress Post';
                    } else if (lowerAction.includes('audit') || lowerAction.includes('review') || lowerAction.includes('analyze') || lowerAction.includes('report')) {
                        automationType = 'generate-report';
                        automationLabel = 'Generate Report';
                    } else if (lowerAction.includes('ticket') || lowerAction.includes('task') || lowerAction.includes('issue')) {
                        automationType = 'create-ticket';
                        automationLabel = 'Create Ticket';
                    } else if (lowerAction.includes('schedule') || lowerAction.includes('plan') || lowerAction.includes('calendar')) {
                        automationType = 'schedule';
                        automationLabel = 'Schedule Task';
                    }
                    
                    const actionBlock = document.createElement('div');
                    actionBlock.style.cssText = 'display: flex; flex-wrap: wrap; gap: 12px; align-items: center; padding: 12px; background: transparent; border: 1px solid #1f1d1a; border-radius: 6px;';
                    
                    const actionLabel = document.createElement('div');
                    actionLabel.textContent = actionText;
                    actionLabel.style.cssText = 'flex: 1; min-width: 200px; color: #d9d5d0; font-size: 0.9rem; line-height: 1.4;';
                    actionBlock.appendChild(actionLabel);
                    
                    const automateBtn = document.createElement('button');
                    automateBtn.textContent = automationLabel;
                    automateBtn.style.cssText = 'background: linear-gradient(270deg, #974C00 0%, #8D8C00 100%); color: #000; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-weight: 700; font-size: 0.875rem; white-space: nowrap; transition: opacity 0.2s;';
                    
                    // Add flag to prevent multiple simultaneous clicks
                    let isAutomating = false;
                    
                    automateBtn.addEventListener('click', async (e) => {
                        // Prevent multiple clicks
                        if (isAutomating || automateBtn.disabled) {
                            e.preventDefault();
                            e.stopPropagation();
                            return;
                        }
                        
                        isAutomating = true;
                        automateBtn.disabled = true;
                        automateBtn.textContent = 'Automating...';
                        automateBtn.style.opacity = '0.6';
                        automateBtn.style.cursor = 'not-allowed';
                        
                        try {
                            await window.lunaComposerExecuteAutomation(automationType, actionText, licenseKey, editor);
                            // Reset button state after successful automation
                            automateBtn.disabled = false;
                            automateBtn.textContent = automationLabel;
                            automateBtn.style.opacity = '1';
                            automateBtn.style.cursor = 'pointer';
                            isAutomating = false;
                        } catch (error) {
                            console.error('[Luna Composer] Automation failed:', error);
                            window.showVLNotification('Failed to automate: ' + (error.message || 'Unknown error'), 'error');
                            automateBtn.disabled = false;
                            automateBtn.textContent = automationLabel;
                            automateBtn.style.opacity = '1';
                            automateBtn.style.cursor = 'pointer';
                            isAutomating = false;
                        }
                    }, { once: false });
                    
                    actionBlock.appendChild(automateBtn);
                    wrapper.appendChild(actionBlock);
                });
            } else {
                // Default automation options when no specific actions detected
                const defaultActions = [
                    { text: 'Post to WordPress', type: 'wordpress-post', label: 'Create WordPress Post' },
                    { text: 'Generate a Luna Report from this content', type: 'generate-report', label: 'Generate Report' },
                    { text: 'Create a new Luna Automation from this task', type: 'create-ticket', label: 'Create Ticket' }
                ];
                
                defaultActions.forEach((defaultAction) => {
                    const actionBlock = document.createElement('div');
                    actionBlock.style.cssText = 'display: flex; font-weight:600; font-weight:600;  align-items: center; padding: 12px; background: transparent; border: 1px solid #1f1d1a; border-radius: 6px;';
                    
                    const actionLabel = document.createElement('div');
                    actionLabel.textContent = defaultAction.text;
                    actionLabel.style.cssText = 'flex: 1; min-width: 200px; color: #d9d5d0; font-size: 0.9rem;';
                    actionBlock.appendChild(actionLabel);
                    
                    const automateBtn = document.createElement('button');
                    automateBtn.textContent = defaultAction.label;
                    automateBtn.style.cssText = 'background: linear-gradient(270deg, #974C00 0%, #8D8C00 100%); color: #000; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-weight: 700; font-size: 0.875rem; white-space: nowrap; transition: opacity 0.2s;';
                    
                    // Add flag to prevent multiple simultaneous clicks
                    let isAutomatingDefault = false;
                    
                    automateBtn.addEventListener('click', async (e) => {
                        // Prevent multiple clicks
                        if (isAutomatingDefault || automateBtn.disabled) {
                            e.preventDefault();
                            e.stopPropagation();
                            return;
                        }
                        
                        isAutomatingDefault = true;
                        automateBtn.disabled = true;
                        automateBtn.textContent = 'Automating...';
                        automateBtn.style.opacity = '0.6';
                        automateBtn.style.cursor = 'not-allowed';
                        
                        try {
                            await window.lunaComposerExecuteAutomation(defaultAction.type, defaultAction.text, licenseKey, editor);
                            // Reset button state after successful automation
                            automateBtn.disabled = false;
                            automateBtn.textContent = defaultAction.label;
                            automateBtn.style.opacity = '1';
                            automateBtn.style.cursor = 'pointer';
                            isAutomatingDefault = false;
                        } catch (error) {
                            console.error('[Luna Composer] Automation failed:', error);
                            window.showVLNotification('Failed to automate: ' + (error.message || 'Unknown error'), 'error');
                            automateBtn.disabled = false;
                            automateBtn.textContent = defaultAction.label;
                            automateBtn.style.opacity = '1';
                            automateBtn.style.cursor = 'pointer';
                            isAutomatingDefault = false;
                        }
                    }, { once: false });
                    
                    actionBlock.appendChild(automateBtn);
                    wrapper.appendChild(actionBlock);
                });
            }
            
            editor.appendChild(wrapper);
        }
        
        // Execute automation based on type
        window.lunaComposerExecuteAutomation = async function(automationType, actionText, licenseKey, editor) {
            console.log('[Luna Composer] Executing automation:', automationType, actionText);
            
            if (!editor) {
                editor = document.getElementById('luna-composer-editor');
            }
            
            if (!editor) {
                throw new Error('Editor not found');
            }
            
            const documentId = editor.getAttribute('data-document-id');
            const prompt = editor.getAttribute('data-prompt') || '';
            const content = editor.innerHTML;
            
            try {
                switch (automationType) {
                    case 'wordpress-post':
                        // Use the existing auto-post functionality
                        await window.lunaComposerAutoPostFromRecommendation(actionText, licenseKey, editor);
                        break;
                        
                    case 'generate-report':
                        // Create a new document with a report generation prompt
                        const reportPrompt = `Generate a detailed report based on: ${actionText}. Include analysis, findings, and recommendations.`;
                        window.lunaComposerScheduleFollowup(reportPrompt, licenseKey, 'report');
                        break;
                        
                    case 'create-ticket':
                        // Create a ticket summary
                        const ticketPrompt = `Create a hand-off ready ticket summary to address: ${actionText}. Include context, expected impact, and a concise checklist.`;
                        window.lunaComposerScheduleFollowup(ticketPrompt, licenseKey, 'ticket');
                        break;
                        
                    case 'schedule':
                        // Schedule task (could integrate with calendar systems)
                        window.showVLNotification('Task scheduling will be available soon. For now, the task has been saved.', 'success');
                        break;
                        
                    default:
                        // Default: create WordPress post
                        await window.lunaComposerAutoPostFromRecommendation(actionText, licenseKey, editor);
                        break;
                }
            } catch (error) {
                console.error('[Luna Composer] Automation execution error:', error);
                throw error; // Re-throw to be caught by the button handler
            }
        };
        
        // Toggle canned prompt expand/collapse
        window.toggleCannedPrompt = function(headerElement, promptId, promptText) {
            const item = headerElement.closest('.canned-prompt-item');
            if (!item) return;
            
            const content = item.querySelector('.canned-prompt-content');
            const arrow = headerElement.querySelector('.canned-prompt-arrow');
            
            if (!content || !arrow) return;
            
            const isOpen = content.style.display !== 'none' && content.style.maxHeight !== '0px';
            
            if (isOpen) {
                // Close
                content.style.maxHeight = '0px';
                content.style.opacity = '0';
                setTimeout(() => {
                    content.style.display = 'none';
                }, 300);
                arrow.style.transform = 'rotate(0deg)';
            } else {
                // Open
                content.style.display = 'block';
                // Get the actual height
                const height = content.scrollHeight;
                content.style.maxHeight = height + 'px';
                content.style.opacity = '1';
                arrow.style.transform = 'rotate(180deg)';
            }
        };
        
        window.lunaComposerUsePrompt = async function(promptId, promptText, responseContent) {
            console.log('[Luna Composer] Using prompt:', promptId, promptText);
            const editor = document.getElementById('luna-composer-editor');
            if (!editor) {
                console.error('[Luna Composer] Editor not found');
                return;
            }
            
            // Generate new document ID for this prompt
            const licenseKey = editor.getAttribute('data-license-key');
            if (!licenseKey) {
                console.error('[Luna Composer] License key not found');
                return;
            }
            
            const documentId = 'doc_' + Date.now() + '_' + Math.random().toString(36).substring(2, 11);
            editor.setAttribute('data-document-id', documentId);
            editor.setAttribute('data-prompt', promptText);
            
            // Update URL with new document ID
            const currentParams = new URLSearchParams(window.location.search);
            const currentLicense = currentParams.get('license') || '';
            if (currentLicense) {
                const baseLicense = currentLicense.split('/luna/compose/')[0];
                const newUrl = new URL(window.location.href);
                newUrl.searchParams.set('license', baseLicense + '/luna/compose/' + documentId);
                window.history.replaceState({}, '', newUrl.toString());
            }
            
            // Show loading state with circular loading icon and gradient text
            // Create thought process display
            const thoughtProcessContainer = document.createElement('div');
            thoughtProcessContainer.id = 'luna-composer-thinking';
            thoughtProcessContainer.style.cssText = 'padding: 40px 0; min-height: 300px; background: transparent; border-radius: 8px;';
            
            const thinkingHeader = document.createElement('div');
            thinkingHeader.style.cssText = 'display: flex; align-items: center; gap: 12px; margin-bottom: 24px; padding-bottom: 16px; border-bottom: 1px solid #1f1d1a;';
            
            const thinkingIcon = document.createElement('div');
            thinkingIcon.innerHTML = '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="width: 24px; height: 24px;"><circle cx="12" cy="12" r="10" stroke="#fff4e9" stroke-width="2" stroke-linecap="round" stroke-dasharray="31.416" stroke-dashoffset="23.562" opacity="0.6"><animate attributeName="stroke-dashoffset" dur="1.5s" values="31.416;0" repeatCount="indefinite"/></circle></svg>';
            
            const thinkingTitle = document.createElement('span');
            thinkingTitle.style.cssText = 'color: #fff4e9; font-size: 1.1rem; font-weight: 600;';
            thinkingTitle.textContent = 'Luna is considering all possibilities...';
            
            thinkingHeader.appendChild(thinkingIcon);
            thinkingHeader.appendChild(thinkingTitle);
            
            const thoughtProcessList = document.createElement('div');
            thoughtProcessList.id = 'luna-thinking-process';
            thoughtProcessList.style.cssText = 'display: flex; flex-direction: column; gap: 16px;';
            
            thoughtProcessContainer.appendChild(thinkingHeader);
            thoughtProcessContainer.appendChild(thoughtProcessList);
            editor.innerHTML = '';
            editor.appendChild(thoughtProcessContainer);
            
            // Generate thought processes based on prompt
            const thoughtProcesses = generateThoughtProcesses(promptText);
            let currentThoughtIndex = 0;
            let thoughtInterval = null;
            
            // Display first thought immediately
            if (thoughtProcesses.length > 0) {
                addThoughtProcess(thoughtProcessList, thoughtProcesses[0], 0);
                currentThoughtIndex = 1;
            }
            
            // Update thought processes every 3 seconds
            thoughtInterval = setInterval(() => {
                if (currentThoughtIndex < thoughtProcesses.length) {
                    addThoughtProcess(thoughtProcessList, thoughtProcesses[currentThoughtIndex], currentThoughtIndex);
                    currentThoughtIndex++;
                } else {
                    // Cycle through thoughts if we've shown them all
                    currentThoughtIndex = 0;
                    thoughtProcessList.innerHTML = '';
                    if (thoughtProcesses.length > 0) {
                        addThoughtProcess(thoughtProcessList, thoughtProcesses[0], 0);
                        currentThoughtIndex = 1;
                    }
                }
            }, 3000);
            
            // Always send prompt to Luna (don't use canned response content directly)
            // Luna will use GPT-4o + VL Hub data to generate a thoughtful response
            try {
                // Fetch client data for context
                const clientData = await lunaComposerFetchClientData(licenseKey);
                
                console.log('[Luna Composer] Sending prompt to Luna API with client data context...');
                const response = await fetch('https://visiblelight.ai/wp-json/luna_widget/v1/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Luna-Composer': 'canned'
                    },
                    credentials: 'include',
                    mode: 'cors',
                    body: JSON.stringify({
                        prompt: promptText,
                        context: 'composer',
                        composer: '1',
                        intent: 'luna_composer_canned',
                        license: licenseKey,
                        client_data: clientData, // Include client data for data-driven responses
                        use_hub_data: true // Flag to indicate backend should use Hub data
                    })
                }).catch(error => {
                    // Handle CORS and network errors
                    console.error('[Luna Composer] Chat fetch error:', error);
                    if (error.message && (error.message.includes('CORS') || error.message.includes('NetworkError') || error.message.includes('Failed to fetch'))) {
                        throw new Error('Network connection error. Please check your internet connection and try again.');
                    }
                    throw error;
                });
                
                console.log('[Luna Composer] Response status:', response.status);
                
                if (response.ok) {
                    try {
                    const data = await response.json();
                    console.log('[Luna Composer] Response data:', data);
                    if (data.answer) {
                        // Clear thought process interval
                        if (thoughtInterval) {
                            clearInterval(thoughtInterval);
                            thoughtInterval = null;
                        }
                        
                        // Convert newlines to <br> tags and preserve formatting
                        // Remove markdown special characters:
                        let cleanedAnswer = data.answer;
                        // Remove asterisks used for bold/italic (**text** or *text*)
                        // First remove double asterisks (bold)
                        cleanedAnswer = cleanedAnswer.replace(/\*\*([^*]+)\*\*/g, '$1'); // Remove **text** but keep text
                        // Then remove single asterisks used for italic
                        cleanedAnswer = cleanedAnswer.replace(/\*([^*\n]+)\*/g, '$1'); // Remove *text* but keep text
                        // Remove dashes at the beginning of lines (markdown list items)
                        cleanedAnswer = cleanedAnswer.replace(/^-\s+/gm, ''); // Remove "- " at start of lines
                        // Remove hashtags from headings
                        cleanedAnswer = cleanedAnswer.replace(/^#+\s+/gm, '');
                        
                        let formattedAnswer = cleanedAnswer.replace(/\n\n/g, '</p><p>').replace(/\n/g, '<br>');
                        if (!formattedAnswer.startsWith('<p>')) {
                            formattedAnswer = '<p>' + formattedAnswer + '</p>';
                        }
                        editor.innerHTML = formattedAnswer;
                        editor.scrollTop = 0;
                        console.log('[Luna Composer] Response displayed in editor');

                        // Always render automation prompts at the end of every response
                        lunaComposerRenderAutomationPrompts(formattedAnswer, promptText, licenseKey);
                        
                        // Also render traditional actionables if found
                        lunaComposerRenderActionables(formattedAnswer, promptText, licenseKey);
                        
                        // Show and initialize heart icon state (defaults to dislike)
                        setTimeout(() => {
                            const heartBtn = document.getElementById('luna-composer-editor-heart-btn');
                            if (heartBtn) {
                                heartBtn.style.display = 'flex';
                            }
                            window.lunaComposerUpdateHeartState();
                        }, 100);
                        
                        // Auto-save the new document
                        const documentData = {
                            id: documentId,
                            content: formattedAnswer,
                            prompt: promptText,
                            timestamp: Date.now(),
                            license: licenseKey,
                            feedback: 'dislike' // Default to dislike for new documents
                        };
                        
                        const docKey = `luna_composer_doc_${documentId}`;
                        localStorage.setItem(docKey, JSON.stringify(documentData));
                        
                        // Add to history
                        const historyKey = `luna_composer_history_${licenseKey}`;
                        let history = [];
                        try {
                            const historyStr = localStorage.getItem(historyKey);
                            if (historyStr) {
                                history = JSON.parse(historyStr);
                            }
                        } catch (e) {
                            console.warn('[Luna Composer] Could not parse history:', e);
                        }
                        
                        // Find existing entry with same document ID and update it, or add new
                        const existingIndex = history.findIndex(doc => doc.id === documentId);
                        if (existingIndex !== -1) {
                            // Update existing entry
                            history[existingIndex].prompt = promptText;
                            history[existingIndex].timestamp = Date.now();
                            history[existingIndex].feedback = 'dislike'; // Ensure feedback is set
                        } else {
                            // Add new entry to beginning of history with feedback
                            history.unshift({
                                id: documentId,
                                prompt: promptText,
                                timestamp: Date.now(),
                                feedback: 'dislike' // Default to dislike for new documents
                            });
                        }
                        
                        if (history.length > 50) {
                            history = history.slice(0, 50);
                        }
                        
                        localStorage.setItem(historyKey, JSON.stringify(history));
                        
                        // Save to WordPress via REST API
                        fetch('https://visiblelight.ai/wp-json/luna_widget/v1/composer/save', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            credentials: 'include',
                            mode: 'cors',
                            body: JSON.stringify({
                                license: licenseKey,
                                document_id: documentId,
                                prompt: promptText,
                                content: formattedAnswer,
                                feedback: 'dislike' // Include feedback in save
                            })
                        }).catch(error => {
                            // Handle CORS and network errors gracefully
                            console.error('[Luna Composer] Save fetch error:', error);
                            // Don't throw - saving is optional, continue silently
                        }).then(response => {
                            if (!response) return; // Skip if fetch failed
                            if (response.ok) {
                                console.log('[Luna Composer] Document saved to WordPress');
                                
                                // Show "Saved to VL Cloud" message with fade-in
                                const saveMessage = document.getElementById('luna-composer-save-message');
                                if (saveMessage) {
                                    // Ensure transition is set for fade-in
                                    saveMessage.style.transition = 'opacity 0.3s ease';
                                    const now = new Date();
                                    saveMessage.textContent = 'Saved to VL Cloud • ' + now.toLocaleTimeString();
                                    saveMessage.style.color = '#fff4e9';
                                    saveMessage.style.opacity = '1';
                                    
                                    // Fade out after 5 seconds
                                    setTimeout(() => {
                                        saveMessage.style.transition = 'opacity 0.5s ease';
                                        saveMessage.style.opacity = '0';
                                        // Clear text after fade completes
                                        setTimeout(() => {
                                            saveMessage.textContent = '';
                                        }, 500);
                                    }, 5000);
                                }
                                
                                // Reload history to show new document in Disliked section
                                setTimeout(() => {
                                    if (typeof loadLunaComposerHistory === 'function') {
                                        loadLunaComposerHistory();
                                    }
                                }, 500);
                                
                                // Add activity notification to main Supercluster page (not on /luna/compose/)
                                const currentParams = new URLSearchParams(window.location.search);
                                const currentLicense = currentParams.get('license') || '';
                                const isLunaComposePage = currentLicense.includes('/luna/compose/');
                                
                                if (!isLunaComposePage) {
                                    // Add to activity stream
                                    const activityList = document.getElementById('recentActivityList');
                                    if (activityList) {
                                        const now = new Date();
                                        const activityItem = document.createElement('li');
                                        activityItem.className = 'vl-activity-item';
                                        
                                        const timeSpan = document.createElement('span');
                                        timeSpan.id = 'activityTimeStamp';
                                        timeSpan.textContent = now.toLocaleString();
                                        activityItem.appendChild(timeSpan);
                                        activityItem.appendChild(document.createElement('br'));
                                        
                                        const labelText = document.createTextNode('Luna Compose Doc was created');
                                        activityItem.appendChild(labelText);
                                        
                                        // Remove "No recent activity" if present
                                        const emptyItem = activityList.querySelector('.vl-activity-empty');
                                        if (emptyItem) {
                                            emptyItem.remove();
                                        }
                                        
                                        // Insert at the beginning
                                        activityList.insertBefore(activityItem, activityList.firstChild);
                                        
                                        // Keep only last 10 items
                                        const items = activityList.querySelectorAll('.vl-activity-item');
                                        if (items.length > 10) {
                                            for (let i = 10; i < items.length; i++) {
                                                items[i].remove();
                                            }
                                        }
                                    }
                                }
                            } else {
                                console.warn('[Luna Composer] Failed to save to WordPress:', response.status);
                            }
                        }).catch(e => {
                            console.warn('[Luna Composer] Error saving to WordPress:', e);
                        });
                        
                        // Refresh history list
                        loadLunaComposerHistory();
                    } else {
                        // Clear thought process interval on no answer
                        if (thoughtInterval) {
                            clearInterval(thoughtInterval);
                            thoughtInterval = null;
                        }
                        editor.innerHTML = '<p style="color: #d63638;">Error: No answer received from Luna</p>';
                        }
                    } catch (parseError) {
                        // Handle JSON parsing errors
                        console.error('[Luna Composer] Error parsing response:', parseError);
                        if (thoughtInterval) {
                            clearInterval(thoughtInterval);
                            thoughtInterval = null;
                        }
                        editor.innerHTML = '<p style="color: #d63638;">Error: Invalid response from Luna</p>';
                    }
                } else {
                    // Clear thought process interval on API error
                    if (thoughtInterval) {
                        clearInterval(thoughtInterval);
                        thoughtInterval = null;
                    }
                    const errorText = await response.text();
                    console.error('[Luna Composer] API error:', response.status, errorText);
                    editor.innerHTML = '<p style="color: #d63638;">Error: Failed to get response from Luna (HTTP ' + response.status + ')</p>';
                }
            } catch (e) {
                console.error('[Luna Composer] Error sending prompt:', e);
                // Clear thought process interval on error
                if (thoughtInterval) {
                    clearInterval(thoughtInterval);
                    thoughtInterval = null;
                }
                editor.innerHTML = '<p style="color: #d63638;">Error: ' + (e.message || 'Failed to connect to Luna') + '</p>';
            }
        };

        window.lunaComposerAutoRunFollowup = function() {
            let stored = null;
            try {
                stored = JSON.parse(localStorage.getItem('lunaComposerFollowupPrompt'));
            } catch (e) {
                stored = null;
            }

            if (!stored || !stored.prompt || (Date.now() - (stored.created || 0)) > 5 * 60 * 1000) {
                return;
            }

            const editor = document.getElementById('luna-composer-editor');
            if (!editor) {
                setTimeout(window.lunaComposerAutoRunFollowup, 400);
                return;
            }

            try {
                localStorage.removeItem('lunaComposerFollowupPrompt');
            } catch (e) {
                console.warn('[Luna Composer] Failed to clear follow-up prompt cache:', e);
            }

            window.lunaComposerUsePrompt('auto_followup', stored.prompt, '');
        };

        window.addEventListener('load', () => {
            setTimeout(window.lunaComposerAutoRunFollowup, 800);
        });
        
        // Generate thought processes based on prompt
        function generateThoughtProcesses(promptText) {
            const thoughts = [];
            const lowerPrompt = promptText.toLowerCase();
            
            // Analyze prompt and generate relevant thoughts
            if (lowerPrompt.includes('report') || lowerPrompt.includes('analysis') || lowerPrompt.includes('summary')) {
                thoughts.push({
                    icon: '📊',
                    text: 'Analyzing data streams from VL Hub Profile...',
                    detail: 'Reviewing performance metrics, security status, and infrastructure health'
                });
                thoughts.push({
                    icon: '🔍',
                    text: 'Cross-referencing multiple data sources...',
                    detail: 'Connecting WordPress data, analytics, and cloud service insights'
                });
                thoughts.push({
                    icon: '📈',
                    text: 'Identifying key patterns and trends...',
                    detail: 'Detecting anomalies, opportunities, and areas for optimization'
                });
                thoughts.push({
                    icon: '💡',
                    text: 'Synthesizing actionable recommendations...',
                    detail: 'Combining technical insights with strategic WebOps expertise'
                });
            } else if (lowerPrompt.includes('blog') || lowerPrompt.includes('post') || lowerPrompt.includes('article') || lowerPrompt.includes('content')) {
                thoughts.push({
                    icon: '✍️',
                    text: 'Researching topic and gathering context...',
                    detail: 'Reviewing existing content, keywords, and audience insights'
                });
                thoughts.push({
                    icon: '📚',
                    text: 'Structuring content for maximum impact...',
                    detail: 'Organizing information flow and ensuring readability'
                });
                thoughts.push({
                    icon: '🎯',
                    text: 'Optimizing for SEO and engagement...',
                    detail: 'Incorporating relevant keywords and compelling narratives'
                });
                thoughts.push({
                    icon: '✨',
                    text: 'Adding strategic insights and value...',
                    detail: 'Enhancing with data-driven examples and expert perspectives'
                });
            } else if (lowerPrompt.includes('security') || lowerPrompt.includes('vulnerability') || lowerPrompt.includes('audit')) {
                thoughts.push({
                    icon: '🔒',
                    text: 'Scanning security infrastructure...',
                    detail: 'Reviewing SSL/TLS certificates, Cloudflare settings, and firewall configurations'
                });
                thoughts.push({
                    icon: '🛡️',
                    text: 'Analyzing potential vulnerabilities...',
                    detail: 'Cross-checking against known security best practices and threats'
                });
                thoughts.push({
                    icon: '⚡',
                    text: 'Evaluating security posture...',
                    detail: 'Assessing current protections and identifying gaps'
                });
                thoughts.push({
                    icon: '🎯',
                    text: 'Formulating security recommendations...',
                    detail: 'Prioritizing critical fixes and actionable improvements'
                });
            } else {
                // Generic thought processes
                thoughts.push({
                    icon: '🧠',
                    text: 'Processing your request...',
                    detail: 'Understanding context and requirements from VL Hub data'
                });
                thoughts.push({
                    icon: '🔗',
                    text: 'Connecting to VL Hub intelligence...',
                    detail: 'Accessing real-time data streams and historical insights'
                });
                thoughts.push({
                    icon: '⚙️',
                    text: 'Analyzing relevant information...',
                    detail: 'Cross-referencing multiple data sources for accuracy'
                });
                thoughts.push({
                    icon: '💭',
                    text: 'Generating intelligent response...',
                    detail: 'Synthesizing insights with GPT-4o reasoning capabilities'
                });
                thoughts.push({
                    icon: '✨',
                    text: 'Refining and optimizing output...',
                    detail: 'Ensuring clarity, accuracy, and actionable value'
                });
            }
            
            return thoughts;
        }
        
        // Add a thought process item to the display
        function addThoughtProcess(container, thought, index) {
            const thoughtItem = document.createElement('div');
            thoughtItem.className = 'luna-thinking-item';
            thoughtItem.style.cssText = 'opacity: 0; transform: translateY(10px); transition: all 0.5s ease; padding: 16px; background: linear-gradient(to right, #000000, #1f1d1a50); border: 1px solid #1f1d1a; border-radius: 4px;';
            
            const thoughtContent = document.createElement('div');
            thoughtContent.style.cssText = 'display: flex; align-items: flex-start; gap: 12px;';
            
            const thoughtIcon = document.createElement('span');
            thoughtIcon.style.cssText = 'font-size: 1.5rem; flex-shrink: 0;';
            thoughtIcon.textContent = thought.icon;
            
            const thoughtText = document.createElement('div');
            thoughtText.style.cssText = 'flex: 1;';
            
            const thoughtMain = document.createElement('div');
            thoughtMain.style.cssText = 'color: #fff4e9; font-size: 0.95rem; font-weight: 500; margin-bottom: 4px;';
            thoughtMain.textContent = thought.text;
            
            const thoughtDetail = document.createElement('div');
            thoughtDetail.style.cssText = 'color: #9A9793; font-size: 0.85rem; line-height: 1.4;';
            thoughtDetail.textContent = thought.detail;
            
            thoughtText.appendChild(thoughtMain);
            thoughtText.appendChild(thoughtDetail);
            thoughtContent.appendChild(thoughtIcon);
            thoughtContent.appendChild(thoughtText);
            thoughtItem.appendChild(thoughtContent);
            
            container.appendChild(thoughtItem);
            
            // Animate in
            setTimeout(() => {
                thoughtItem.style.opacity = '1';
                thoughtItem.style.transform = 'translateY(0)';
            }, 50);
            
            // Keep only last 4 thoughts visible
            const items = container.querySelectorAll('.luna-thinking-item');
            if (items.length > 4) {
                items[0].style.opacity = '0';
                items[0].style.transform = 'translateY(-10px)';
                setTimeout(() => {
                    if (items[0].parentNode) {
                        items[0].parentNode.removeChild(items[0]);
                    }
                }, 500);
            }
        }
        
        // Initialize auto-save with document ID generation
        function initializeLunaComposerAutoSave() {
            const editor = document.getElementById('luna-composer-editor');
            const statusEl = document.getElementById('luna-composer-auto-save-status');
            if (!editor) return;
            
            // Ensure auto-save status is visible
            if (statusEl) {
                statusEl.style.display = 'flex';
            }
            
            let saveTimeout = null;
            let lastSaved = null;
            const licenseKey = editor.getAttribute('data-license-key');
            let documentId = editor.getAttribute('data-document-id');
            
            // Generate document ID if not present
            if (!documentId || documentId === '') {
                documentId = 'doc_' + Date.now() + '_' + Math.random().toString(36).substring(2, 11);
                editor.setAttribute('data-document-id', documentId);
                
                // Update URL with document ID
                const currentParams = new URLSearchParams(window.location.search);
                const currentLicense = currentParams.get('license') || '';
                if (currentLicense) {
                    const baseLicense = currentLicense.split('/luna/compose/')[0];
                    const newUrl = new URL(window.location.href);
                    newUrl.searchParams.set('license', baseLicense + '/luna/compose/' + documentId);
                    window.history.replaceState({}, '', newUrl.toString());
                }
            }
            
            // Auto-save on input
            editor.addEventListener('input', () => {
                // Show auto-save status
                if (statusEl) {
                    statusEl.style.display = 'flex';
                }
                
                // Auto-saving state - icon remains visible, no message
                const saveMessage = document.getElementById('luna-composer-save-message');
                if (saveMessage) {
                    saveMessage.textContent = '';
                    saveMessage.style.opacity = '0';
                }
                
                clearTimeout(saveTimeout);
                saveTimeout = setTimeout(() => {
                    const content = editor.innerHTML;
                    const prompt = editor.getAttribute('data-prompt') || '';
                    
                    if (!licenseKey) return;
                    
                    // Get existing document data to preserve feedback
                    const docKey = `luna_composer_doc_${documentId}`;
                    let existingDocData = null;
                    try {
                        const existingDocStr = localStorage.getItem(docKey);
                        if (existingDocStr) {
                            existingDocData = JSON.parse(existingDocStr);
                        }
                    } catch (e) {
                        console.warn('[Luna Composer] Could not parse existing doc data:', e);
                    }
                    
                    // Save document with metadata, preserving feedback
                    const documentData = {
                        id: documentId,
                        content: content,
                        prompt: prompt,
                        timestamp: Date.now(),
                        license: licenseKey,
                        feedback: existingDocData?.feedback || 'dislike' // Preserve existing feedback or default to dislike
                    };
                    
                    // Save to localStorage with document ID
                    localStorage.setItem(docKey, JSON.stringify(documentData));
                    
                    // Also save to history list
                    const historyKey = `luna_composer_history_${licenseKey}`;
                    let history = [];
                    try {
                        const historyStr = localStorage.getItem(historyKey);
                        if (historyStr) {
                            history = JSON.parse(historyStr);
                        }
                    } catch (e) {
                        console.warn('[Luna Composer] Could not parse history:', e);
                    }
                    
                    // Find existing entry with same document ID and update it
                    const existingIndex = history.findIndex(doc => doc.id === documentId);
                    if (existingIndex !== -1) {
                        // Update existing entry, preserving feedback
                        history[existingIndex].prompt = prompt || 'Untitled Document';
                        history[existingIndex].timestamp = Date.now();
                        if (documentData.feedback) {
                            history[existingIndex].feedback = documentData.feedback;
                        }
                    } else {
                        // Add new entry to beginning of history
                        history.unshift({
                            id: documentId,
                            prompt: prompt || 'Untitled Document',
                            timestamp: Date.now(),
                            feedback: documentData.feedback || 'dislike'
                        });
                    }
                    
                    // Keep only last 50 documents
                    if (history.length > 50) {
                        history = history.slice(0, 50);
                    }
                    
                    localStorage.setItem(historyKey, JSON.stringify(history));
                    
                    // Save to WordPress via REST API
                    fetch('https://visiblelight.ai/wp-json/luna_widget/v1/composer/save', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify({
                            license: licenseKey,
                            document_id: documentId,
                            prompt: prompt,
                            content: content,
                            feedback: documentData.feedback || 'dislike' // Include feedback in save
                        })
                    }).then(response => {
                        if (response.ok) {
                            console.log('[Luna Composer] Document saved to WordPress');
                            
                            // Show "Saved to VL Cloud" message with fade-in and timestamp
                            const saveMessage = document.getElementById('luna-composer-save-message');
                            if (saveMessage) {
                                // Ensure transition is set for fade-in
                                saveMessage.style.transition = 'opacity 0.3s ease';
                                const now = new Date();
                                saveMessage.textContent = 'Saved to VL Cloud • ' + now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                                saveMessage.style.color = '#fff4e9';
                                saveMessage.style.opacity = '1';
                                
                                // Fade out after 5 seconds
                                setTimeout(() => {
                                    saveMessage.style.transition = 'opacity 0.5s ease';
                                    saveMessage.style.opacity = '0';
                                    // Clear text after fade completes
                                    setTimeout(() => {
                                        saveMessage.textContent = '';
                                    }, 500);
                                }, 5000);
                            }
                            
                            // Reload history to show updated document
                            setTimeout(() => {
                                if (typeof loadLunaComposerHistory === 'function') {
                                    loadLunaComposerHistory();
                                }
                            }, 500);
                            
                            // Add activity notification to main Supercluster page (not on /luna/compose/)
                            const currentParams = new URLSearchParams(window.location.search);
                            const currentLicense = currentParams.get('license') || '';
                            const isLunaComposePage = currentLicense.includes('/luna/compose/');
                            
                            if (!isLunaComposePage) {
                                // Add to activity stream
                                const activityList = document.getElementById('recentActivityList');
                                if (activityList) {
                                    const now = new Date();
                                    const activityItem = document.createElement('li');
                                    activityItem.className = 'vl-activity-item';
                                    
                                    const timeSpan = document.createElement('span');
                                    timeSpan.id = 'activityTimeStamp';
                                    timeSpan.textContent = now.toLocaleString();
                                    activityItem.appendChild(timeSpan);
                                    activityItem.appendChild(document.createElement('br'));
                                    
                                    const labelText = document.createTextNode('Luna Compose Doc was created');
                                    activityItem.appendChild(labelText);
                                    
                                    // Remove "No recent activity" if present
                                    const emptyItem = activityList.querySelector('.vl-activity-empty');
                                    if (emptyItem) {
                                        emptyItem.remove();
                                    }
                                    
                                    // Insert at the beginning
                                    activityList.insertBefore(activityItem, activityList.firstChild);
                                    
                                    // Keep only last 10 items
                                    const items = activityList.querySelectorAll('.vl-activity-item');
                                    if (items.length > 10) {
                                        for (let i = 10; i < items.length; i++) {
                                            items[i].remove();
                                        }
                                    }
                                }
                            }
                        } else {
                            console.warn('[Luna Composer] Failed to save to WordPress:', response.status);
                        }
                    }).catch(e => {
                        console.warn('[Luna Composer] Error saving to WordPress:', e);
                    });
                    
                    lastSaved = new Date();
                    
                    // Refresh history list
                    loadLunaComposerHistory();
                }, 2000); // Save after 2 seconds of inactivity
            });
            
            // Load saved content on page load from URL document ID
            if (documentId && documentId !== '') {
                console.log('[Luna Composer] Loading document from URL:', documentId);
                
                // Async function to load document
                (async function() {
                    // Try to fetch from WordPress first
                    try {
                        const response = await fetch(`https://visiblelight.ai/wp-json/luna_widget/v1/composer/fetch?license=${encodeURIComponent(licenseKey)}&document_id=${encodeURIComponent(documentId)}`, {
                            method: 'GET',
                            headers: { 'Content-Type': 'application/json' },
                            credentials: 'include'
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            if (data.documents && data.documents.length > 0) {
                                const docData = data.documents[0];
                                if (docData.content) {
                                    editor.innerHTML = docData.content;
                                    editor.setAttribute('data-document-id', documentId);
                                    if (docData.prompt) {
                                        editor.setAttribute('data-prompt', docData.prompt);
                                    }
                                    
                                    // Render automation prompts
                                    if (docData.content && docData.prompt) {
                                        lunaComposerRenderAutomationPrompts(docData.content, docData.prompt, licenseKey);
                                    }
                                    
                                    // Show and update heart icon state
                                    setTimeout(() => {
                                        const heartBtn = document.getElementById('luna-composer-editor-heart-btn');
                                        if (heartBtn) {
                                            heartBtn.style.display = 'flex';
                                        }
                                        window.lunaComposerUpdateHeartState();
                                    }, 100);
                                    
                                    console.log('[Luna Composer] Document loaded from WordPress');
                                    return; // Successfully loaded, exit
                                }
                            }
                        }
                    } catch (e) {
                        console.warn('[Luna Composer] Could not fetch document from WordPress, trying localStorage:', e);
                    }
                    
                    // Fallback to localStorage
                const docKey = `luna_composer_doc_${documentId}`;
                const savedDoc = localStorage.getItem(docKey);
                if (savedDoc) {
                    try {
                        const docData = JSON.parse(savedDoc);
                        if (docData.content) {
                            editor.innerHTML = docData.content;
                                editor.setAttribute('data-document-id', documentId);
                            if (docData.prompt) {
                                editor.setAttribute('data-prompt', docData.prompt);
                            }
                                
                                // Render automation prompts
                                if (docData.content && docData.prompt) {
                                    lunaComposerRenderAutomationPrompts(docData.content, docData.prompt, licenseKey);
                                }
                                
                                // Show and update heart icon state
                                setTimeout(() => {
                                    const heartBtn = document.getElementById('luna-composer-editor-heart-btn');
                                    if (heartBtn) {
                                        heartBtn.style.display = 'flex';
                                    }
                                    window.lunaComposerUpdateHeartState();
                                }, 100);
                                
                                console.log('[Luna Composer] Document loaded from localStorage');
                        }
                    } catch (e) {
                        console.warn('[Luna Composer] Could not parse saved document:', e);
                    }
                    } else {
                        console.warn('[Luna Composer] Document not found in localStorage:', documentId);
                }
                })();
            } else if (licenseKey) {
                // Fallback: load latest document for this license
                const historyKey = `luna_composer_history_${licenseKey}`;
                const historyStr = localStorage.getItem(historyKey);
                if (historyStr) {
                    try {
                        const history = JSON.parse(historyStr);
                        if (history.length > 0) {
                            const latestDoc = history[0];
                            const docKey = `luna_composer_doc_${latestDoc.id}`;
                            const savedDoc = localStorage.getItem(docKey);
                            if (savedDoc) {
                                const docData = JSON.parse(savedDoc);
                                if (docData.content) {
                                    editor.innerHTML = docData.content;
                                    editor.setAttribute('data-document-id', latestDoc.id);
                                    if (docData.prompt) {
                                        editor.setAttribute('data-prompt', docData.prompt);
                                    }
                                }
                            }
                        }
                    } catch (e) {
                        console.warn('[Luna Composer] Could not load latest document:', e);
                    }
                }
            }
        }
        
        // Load and display history in sidebar - fetch from WordPress first
        async function loadLunaComposerHistory() {
            const historyList = document.getElementById('lunaComposerHistoryList');
            if (!historyList) return;
            
            const editor = document.getElementById('luna-composer-editor');
            if (!editor) return;
            
            const licenseKey = editor.getAttribute('data-license-key');
            if (!licenseKey) return;
            
            // Try to fetch from WordPress first (last 30 days)
            // Get the client's WordPress site URL from the editor data attribute or use visiblelight.ai as fallback
            const clientSiteUrl = editor.getAttribute('data-client-site-url') || 'https://visiblelight.ai';
            let historyFetched = false;
            
            // Try client site first
            if (clientSiteUrl && clientSiteUrl !== 'https://visiblelight.ai') {
            try {
                const response = await fetch(`${clientSiteUrl}/wp-json/luna_widget/v1/composer/fetch?license=${encodeURIComponent(licenseKey)}`, {
                    method: 'GET',
                    headers: { 
                        'Content-Type': 'application/json',
                        'X-Luna-License': licenseKey
                    },
                    credentials: 'include'
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.documents && data.documents.length > 0) {
                        // Update localStorage with WordPress data
                        const history = data.documents.map(doc => ({
                            id: doc.id,
                            prompt: doc.prompt || 'Untitled Document',
                            timestamp: doc.timestamp,
                            feedback: doc.feedback || 'dislike' // Include feedback from WordPress
                        }));
                        
                        const historyKey = `luna_composer_history_${licenseKey}`;
                        localStorage.setItem(historyKey, JSON.stringify(history));
                        
                        // Cache individual documents with feedback
                        data.documents.forEach(doc => {
                            const docKey = `luna_composer_doc_${doc.id}`;
                            localStorage.setItem(docKey, JSON.stringify({
                                id: doc.id,
                                content: doc.content,
                                prompt: doc.prompt,
                                timestamp: doc.timestamp,
                                license: licenseKey,
                                feedback: doc.feedback || 'dislike' // Include feedback from WordPress
                            }));
                            
                            // Also store feedback separately for easy lookup
                            if (doc.feedback) {
                                const feedbackKey = `luna_composer_feedback_${doc.id}`;
                                localStorage.setItem(feedbackKey, JSON.stringify({
                                    feedback: doc.feedback,
                                    timestamp: Date.now()
                                }));
                            }
                        });
                        
                        // Display history
                        displayHistory(history, historyList, editor, licenseKey);
                            historyFetched = true;
                        return;
                    }
                }
            } catch (e) {
                    console.warn('[Luna Composer] Could not fetch history from client WordPress site:', e);
                }
            }
            
            // Fallback to Hub if client site fetch failed
            if (!historyFetched) {
                try {
                    const hubResponse = await fetch(`https://visiblelight.ai/wp-json/luna_widget/v1/composer/fetch?license=${encodeURIComponent(licenseKey)}`, {
                        method: 'GET',
                        headers: { 
                            'Content-Type': 'application/json',
                            'X-Luna-License': licenseKey
                        },
                        credentials: 'include'
                    });
                    
                    if (hubResponse.ok) {
                        const data = await hubResponse.json();
                        if (data.documents && data.documents.length > 0) {
                            // Update localStorage with WordPress data
                            const history = data.documents.map(doc => ({
                                id: doc.id,
                                prompt: doc.prompt || 'Untitled Document',
                                timestamp: doc.timestamp,
                                feedback: doc.feedback || 'dislike' // Include feedback from WordPress
                            }));
                            
                            const historyKey = `luna_composer_history_${licenseKey}`;
                            localStorage.setItem(historyKey, JSON.stringify(history));
                            
                            // Cache individual documents with feedback
                            data.documents.forEach(doc => {
                                const docKey = `luna_composer_doc_${doc.id}`;
                                localStorage.setItem(docKey, JSON.stringify({
                                    id: doc.id,
                                    content: doc.content,
                                    prompt: doc.prompt,
                                    timestamp: doc.timestamp,
                                    license: licenseKey,
                                    feedback: doc.feedback || 'dislike' // Include feedback from WordPress
                                }));
                                
                                // Also store feedback separately for easy lookup
                                if (doc.feedback) {
                                    const feedbackKey = `luna_composer_feedback_${doc.id}`;
                                    localStorage.setItem(feedbackKey, JSON.stringify({
                                        feedback: doc.feedback,
                                        timestamp: Date.now()
                                    }));
                                }
                            });
                            
                            // Display history
                            displayHistory(history, historyList, editor, licenseKey);
                            return;
                        }
                    }
                } catch (e) {
                    console.warn('[Luna Composer] Could not fetch history from Hub:', e);
                }
            }
            
            // Fallback to localStorage
            const historyKey = `luna_composer_history_${licenseKey}`;
            const historyStr = localStorage.getItem(historyKey);
            
            if (!historyStr) {
                historyList.innerHTML = '<li class="vl-activity-empty">No saved documents.</li>';
                return;
            }
            
            try {
                const history = JSON.parse(historyStr);
                
                if (history.length === 0) {
                    historyList.innerHTML = '<li class="vl-activity-empty">No saved documents.</li>';
                    return;
                }
                
                displayHistory(history, historyList, editor, licenseKey);
            } catch (e) {
                console.error('[Luna Composer] Could not parse history:', e);
                historyList.innerHTML = '<li class="vl-activity-empty">Error loading history.</li>';
            }
        }
        
        // Display history list with Liked/Disliked categories
        function displayHistory(history, historyList, editor, licenseKey) {
            historyList.innerHTML = '';
            
            // Separate into liked and disliked
            const likedDocs = [];
            const dislikedDocs = [];
            
            history.forEach(doc => {
                // Check feedback from doc object first (from WordPress), then localStorage
                let feedback = doc.feedback || null;
                
                if (!feedback) {
                    // Check feedback from localStorage document data
                    const docKey = `luna_composer_doc_${doc.id}`;
                    const savedDoc = localStorage.getItem(docKey);
                    if (savedDoc) {
                        try {
                            const docData = JSON.parse(savedDoc);
                            feedback = docData.feedback || null;
                        } catch (e) {
                            console.warn('[Luna Composer] Could not parse doc data:', e);
                        }
                    }
                }
                
                // Also check if feedback was stored separately
                if (!feedback) {
                    const feedbackKey = `luna_composer_feedback_${doc.id}`;
                    const feedbackStr = localStorage.getItem(feedbackKey);
                    if (feedbackStr) {
                        try {
                            const feedbackData = JSON.parse(feedbackStr);
                            feedback = feedbackData.feedback || null;
                        } catch (e) {
                            console.warn('[Luna Composer] Could not parse feedback:', e);
                        }
                    }
                }
                
                // Default to dislike if no feedback found
                if (!feedback) {
                    feedback = 'dislike';
                }
                
                if (feedback === 'like') {
                    likedDocs.push({...doc, feedback: 'like'});
                } else {
                    // Default to dislike for unrated documents
                    dislikedDocs.push({...doc, feedback: 'dislike'});
                }
            });
            
            // Sort liked docs by timestamp (newest first)
            likedDocs.sort((a, b) => {
                const timeA = typeof a.timestamp === 'number' ? a.timestamp : new Date(a.timestamp).getTime();
                const timeB = typeof b.timestamp === 'number' ? b.timestamp : new Date(b.timestamp).getTime();
                return (isNaN(timeB) ? 0 : timeB) - (isNaN(timeA) ? 0 : timeA);
            });
            
            // Sort disliked docs by timestamp (newest first)
            dislikedDocs.sort((a, b) => {
                const timeA = typeof a.timestamp === 'number' ? a.timestamp : new Date(a.timestamp).getTime();
                const timeB = typeof b.timestamp === 'number' ? b.timestamp : new Date(b.timestamp).getTime();
                return (isNaN(timeB) ? 0 : timeB) - (isNaN(timeA) ? 0 : timeA);
            });
            
            // Create Liked section
            if (likedDocs.length > 0) {
                const likedSection = document.createElement('div');
                likedSection.className = 'luna-composer-history-section';
                
                const likedHeader = document.createElement('div');
                likedHeader.className = 'luna-composer-history-header';
                likedHeader.style.cssText = 'display: flex; align-items: center; justify-content: space-between; padding: 0; border-bottom: 1px solid #1f1d1a; cursor: pointer; user-select: none;';
                likedHeader.onclick = function() {
                    const content = this.nextElementSibling;
                    const arrow = this.querySelector('.luna-composer-section-arrow');
                    if (content.style.display === 'none') {
                        content.style.display = 'block';
                        arrow.style.transform = 'rotate(180deg)';
                    } else {
                        content.style.display = 'none';
                        arrow.style.transform = 'rotate(0deg)';
                    }
                };
                
                const likedTitle = document.createElement('span');
                likedTitle.style.cssText = 'color: #fff4e9; font-weight: 600; font-size: 0.875rem;';
                likedTitle.textContent = 'Liked';
                
                const likedArrow = document.createElement('img');
                likedArrow.className = 'luna-composer-section-arrow';
                likedArrow.src = 'https://visiblelight.ai/wp-content/uploads/2025/08/downarrow.svg';
                likedArrow.style.cssText = 'width: 12px; height: 12px; transition: transform 0.2s ease; transform: rotate(180deg); filter: brightness(0) invert(1);';
                
                likedHeader.appendChild(likedTitle);
                likedHeader.appendChild(likedArrow);
                
                const likedContent = document.createElement('ul');
                likedContent.className = 'luna-composer-history-content';
                likedContent.style.cssText = 'list-style: none; padding: 0; margin: 0;';
                
                // Add liked docs (already sorted, newest first)
                likedDocs.forEach(doc => {
                    const li = createHistoryItem(doc, editor, licenseKey);
                    likedContent.appendChild(li);
                });
                
                likedSection.appendChild(likedHeader);
                likedSection.appendChild(likedContent);
                historyList.appendChild(likedSection);
            }
            
            // Create Disliked section
            if (dislikedDocs.length > 0) {
                const dislikedSection = document.createElement('div');
                dislikedSection.className = 'luna-composer-history-section';
                
                const dislikedHeader = document.createElement('div');
                dislikedHeader.className = 'luna-composer-history-header';
                dislikedHeader.style.cssText = 'display: flex; align-items: center; justify-content: space-between; padding: 12px 0; border-bottom: 1px solid #1f1d1a; cursor: pointer; user-select: none;';
                dislikedHeader.onclick = function() {
                    const content = this.nextElementSibling;
                    const arrow = this.querySelector('.luna-composer-section-arrow');
                    if (content.style.display === 'none') {
                        content.style.display = 'block';
                        arrow.style.transform = 'rotate(180deg)';
                    } else {
                        content.style.display = 'none';
                        arrow.style.transform = 'rotate(0deg)';
                    }
                };
                
                const dislikedTitle = document.createElement('span');
                dislikedTitle.style.cssText = 'color: #fff4e9; font-weight: 600; font-size: 0.875rem;';
                dislikedTitle.textContent = 'Disliked';
                
                const dislikedArrow = document.createElement('img');
                dislikedArrow.className = 'luna-composer-section-arrow';
                dislikedArrow.src = 'https://visiblelight.ai/wp-content/uploads/2025/08/downarrow.svg';
                dislikedArrow.style.cssText = 'width: 12px; height: 12px; transition: transform 0.2s ease; transform: rotate(0deg); filter: brightness(0) invert(1);';
                
                dislikedHeader.appendChild(dislikedTitle);
                dislikedHeader.appendChild(dislikedArrow);
                
                const dislikedContent = document.createElement('ul');
                dislikedContent.className = 'luna-composer-history-content';
                dislikedContent.style.cssText = 'list-style: none; padding: 0; margin: 0; display: none;';
                
                dislikedDocs.forEach(doc => {
                    const li = createHistoryItem(doc, editor, licenseKey);
                    dislikedContent.appendChild(li);
                });
                
                dislikedSection.appendChild(dislikedHeader);
                dislikedSection.appendChild(dislikedContent);
                historyList.appendChild(dislikedSection);
            }
            
            if (likedDocs.length === 0 && dislikedDocs.length === 0) {
                historyList.innerHTML = '<li class="vl-activity-empty">No saved documents.</li>';
            }
        }
        
        // Create a history item
        function createHistoryItem(doc, editor, licenseKey) {
            const li = document.createElement('li');
            li.className = 'vl-activity-item';
            li.style.cssText = 'padding: 12px; border-bottom: 1px solid #1f1d1a; cursor: pointer; transition: background 0.2s ease; position: relative;';
            li.setAttribute('data-document-id', doc.id);
            
            // Delete button (x icon) - shown on hover
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'luna-composer-history-delete';
            deleteBtn.innerHTML = '×';
            deleteBtn.style.cssText = 'position: absolute; top: 8px; right: 8px; background: transparent; border: none; color: #d63638; font-size: 1.25rem; cursor: pointer; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; opacity: 0; transition: opacity 0.2s ease; z-index: 10; line-height: 1;';
            deleteBtn.onclick = function(e) {
                e.stopPropagation();
                window.lunaComposerShowDeleteModalForHistory(doc.id, licenseKey);
            };
            
            li.onmouseover = function() { 
                this.style.background = '#2E2C2A';
                const btn = this.querySelector('.luna-composer-history-delete');
                if (btn) btn.style.opacity = '1';
            };
            li.onmouseout = function() { 
                this.style.background = 'transparent';
                const btn = this.querySelector('.luna-composer-history-delete');
                if (btn) btn.style.opacity = '0';
            };
            
            const title = document.createElement('div');
            title.style.cssText = 'color: #fff4e9; font-weight: 600; font-size: 0.8rem; margin-bottom: 0; padding-right: 30px;';
            title.textContent = doc.prompt || 'Untitled Document';
            
            const timestamp = document.createElement('div');
            timestamp.style.cssText = 'color: #5A5753; font-size: 0.7rem;';
            // Handle timestamp - could be number (milliseconds) or date string
            let date;
            if (typeof doc.timestamp === 'number') {
                date = new Date(doc.timestamp);
            } else if (typeof doc.timestamp === 'string') {
                date = new Date(doc.timestamp);
            } else {
                // Fallback to current date if timestamp is invalid
                date = new Date();
            }
            
            // Check if date is valid
            if (isNaN(date.getTime())) {
                // If invalid, try to get from document data
                const docKey = `luna_composer_doc_${doc.id}`;
                const savedDoc = localStorage.getItem(docKey);
                if (savedDoc) {
                    try {
                        const docData = JSON.parse(savedDoc);
                        if (docData.timestamp) {
                            date = new Date(docData.timestamp);
                        }
                    } catch (e) {
                        // Use current date as fallback
                        date = new Date();
                    }
                } else {
                    date = new Date();
                }
            }
            
            // Format date properly
            const dateStr = date.toLocaleDateString();
            const timeStr = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            timestamp.textContent = dateStr + ' ' + timeStr;
            
            li.appendChild(title);
            li.appendChild(timestamp);
            li.appendChild(deleteBtn);
            
            li.onclick = async function() {
                    // Try to load from WordPress first, then localStorage
                    try {
                        const response = await fetch(`https://visiblelight.ai/wp-json/luna_widget/v1/composer/fetch?license=${encodeURIComponent(licenseKey)}&document_id=${encodeURIComponent(doc.id)}`, {
                            method: 'GET',
                            headers: { 'Content-Type': 'application/json' },
                            credentials: 'include'
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            if (data.documents && data.documents.length > 0) {
                                const docData = data.documents[0];
                                if (docData.content) {
                                    editor.innerHTML = docData.content;
                                    editor.setAttribute('data-document-id', doc.id);
                                    if (docData.prompt) {
                                        editor.setAttribute('data-prompt', docData.prompt);
                                    }
                                    
                                    // Render automation prompts (same as new prompts)
                                    if (docData.content && docData.prompt) {
                                        lunaComposerRenderAutomationPrompts(docData.content, docData.prompt, licenseKey);
                                    }
                                    
                                    // Show and update heart icon state
                                    setTimeout(() => {
                                        const heartBtn = document.getElementById('luna-composer-editor-heart-btn');
                                        if (heartBtn) {
                                            heartBtn.style.display = 'flex';
                                        }
                                        window.lunaComposerUpdateHeartState();
                                    }, 100);
                                    
                                    // Update URL
                                    const currentParams = new URLSearchParams(window.location.search);
                                    const currentLicense = currentParams.get('license') || '';
                                    if (currentLicense) {
                                        const baseLicense = currentLicense.split('/luna/compose/')[0];
                                        const newUrl = new URL(window.location.href);
                                        newUrl.searchParams.set('license', baseLicense + '/luna/compose/' + doc.id);
                                        window.history.replaceState({}, '', newUrl.toString());
                                    }
                                    
                                    // Cache in localStorage with feedback
                                    const docKey = `luna_composer_doc_${doc.id}`;
                                    localStorage.setItem(docKey, JSON.stringify({
                                        id: doc.id,
                                        content: docData.content,
                                        prompt: docData.prompt,
                                        timestamp: docData.timestamp,
                                        license: licenseKey,
                                        feedback: docData.feedback || 'dislike' // Include feedback from WordPress
                                    }));
                                    
                                    // Also store feedback separately
                                    if (docData.feedback) {
                                        const feedbackKey = `luna_composer_feedback_${doc.id}`;
                                        localStorage.setItem(feedbackKey, JSON.stringify({
                                            feedback: docData.feedback,
                                            timestamp: Date.now()
                                        }));
                                    }
                                    
                                    // Render automation prompts (same as new prompts)
                                    if (docData.content && docData.prompt) {
                                        lunaComposerRenderAutomationPrompts(docData.content, docData.prompt, licenseKey);
                                    }
                                    
                                    // Scroll editor to top
                                    editor.scrollTop = 0;
                                    return;
                                }
                            }
                        }
                    } catch (e) {
                        console.warn('[Luna Composer] Could not fetch document from WordPress:', e);
                    }
                    
                    // Fallback to localStorage
                    const docKey = `luna_composer_doc_${doc.id}`;
                    const savedDoc = localStorage.getItem(docKey);
                    if (savedDoc) {
                        try {
                            const docData = JSON.parse(savedDoc);
                            if (docData.content) {
                                editor.innerHTML = docData.content;
                                editor.setAttribute('data-document-id', doc.id);
                                if (docData.prompt) {
                                    editor.setAttribute('data-prompt', docData.prompt);
                                }
                                
                                // Store feedback if present
                                if (docData.feedback) {
                                    const feedbackKey = `luna_composer_feedback_${doc.id}`;
                                    localStorage.setItem(feedbackKey, JSON.stringify({
                                        feedback: docData.feedback,
                                        timestamp: Date.now()
                                    }));
                                }
                                
                                // Render automation prompts (same as new prompts)
                                if (docData.content && docData.prompt) {
                                    lunaComposerRenderAutomationPrompts(docData.content, docData.prompt, licenseKey);
                                }
                                
                                // Show and update heart icon state
                                setTimeout(() => {
                                    const heartBtn = document.getElementById('luna-composer-editor-heart-btn');
                                    if (heartBtn) {
                                        heartBtn.style.display = 'flex';
                                    }
                                    window.lunaComposerUpdateHeartState();
                                }, 100);
                                
                                // Update URL
                                const currentParams = new URLSearchParams(window.location.search);
                                const currentLicense = currentParams.get('license') || '';
                                if (currentLicense) {
                                    const baseLicense = currentLicense.split('/luna/compose/')[0];
                                    const newUrl = new URL(window.location.href);
                                    newUrl.searchParams.set('license', baseLicense + '/luna/compose/' + doc.id);
                                    window.history.replaceState({}, '', newUrl.toString());
                                }
                                
                                // Scroll editor to top
                                editor.scrollTop = 0;
                            }
                        } catch (e) {
                            console.error('[Luna Composer] Could not load document:', e);
                        }
                    }
                };
                
                return li;
        }
        
        // Find and Replace functions - make globally accessible
        window.lunaComposerShowFindReplace = function() {
            console.log('[Luna Composer] Showing find/replace modal');
            const modal = document.getElementById('luna-composer-find-replace-modal');
            if (modal) {
                modal.style.display = 'flex';
                const findInput = document.getElementById('luna-composer-find-text');
                if (findInput) {
                    findInput.focus();
                }
            } else {
                console.error('[Luna Composer] Find/replace modal not found');
            }
        };
        
        window.lunaComposerCloseFindReplace = function() {
            console.log('[Luna Composer] Closing find/replace modal');
            const modal = document.getElementById('luna-composer-find-replace-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        };
        
        window.lunaComposerExecuteFindReplace = function() {
            console.log('[Luna Composer] Executing find/replace');
            const findText = document.getElementById('luna-composer-find-text');
            const replaceText = document.getElementById('luna-composer-replace-text');
            const editor = document.getElementById('luna-composer-editor');
            
            if (!editor) {
                console.error('[Luna Composer] Editor not found');
                return;
            }
            
            if (!findText || !findText.value) {
                window.showVLNotification('Please enter text to find', 'error');
                return;
            }
            
            // Get plain text content from editor (not HTML)
            let content = editor.innerText || editor.textContent || '';
            const findValue = findText.value;
            const replaceValue = replaceText ? replaceText.value : '';
            
            // Replace all occurrences (case-insensitive)
            const regex = new RegExp(findValue.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
            content = content.replace(regex, replaceValue);
            
            // Update editor with new content
            editor.innerText = content;
            editor.textContent = content;
            
            console.log('[Luna Composer] Find/replace completed');
            window.lunaComposerCloseFindReplace();
        };
        
        // Share functions - make globally accessible
        window.lunaComposerShowShareModal = async function() {
            console.log('[Luna Composer] Showing share modal');
            const editor = document.getElementById('luna-composer-editor');
            if (!editor) {
                console.error('[Luna Composer] Editor not found');
                return;
            }
            
            const documentId = editor.getAttribute('data-document-id');
            const licenseKey = editor.getAttribute('data-license-key');
            const content = editor.innerHTML;
            const prompt = editor.getAttribute('data-prompt') || '';
            
            if (!documentId || !licenseKey) {
                console.error('[Luna Composer] Document ID or license key not found');
                window.showVLNotification('Please save your document before sharing.', 'error');
                return;
            }
            
            // Generate unique share ID (longer for uniqueness)
            const shareId = 'lcid_' + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 10);
            
            // Save shared document to WordPress backend
            try {
                const response = await fetch('https://visiblelight.ai/wp-json/luna_widget/v1/composer/share', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                        license: licenseKey,
                        document_id: documentId,
                        share_id: shareId,
                        content: content,
                        prompt: prompt
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('[Luna Composer] Share link created:', data);
                } else {
                    console.warn('[Luna Composer] Failed to create share link:', response.status);
                }
            } catch (e) {
                console.error('[Luna Composer] Error creating share link:', e);
            }
            
            // Generate secure shareable URL (without license key)
            const shareUrl = `https://supercluster.visiblelight.ai/invite_from/luna/compose/${shareId}`;
            
            // Show modal and set link
            const modal = document.getElementById('luna-composer-share-modal');
            const linkInput = document.getElementById('luna-composer-share-link-input');
            if (modal && linkInput) {
                linkInput.value = shareUrl;
                modal.style.display = 'flex';
            } else {
                console.error('[Luna Composer] Share modal or input not found');
            }
        };
        
        window.lunaComposerCloseShareModal = function() {
            console.log('[Luna Composer] Closing share modal');
            const modal = document.getElementById('luna-composer-share-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        };
        
        window.lunaComposerSelectShareAction = function(action) {
            console.log('[Luna Composer] Selecting share action:', action);
            const copyBtn = document.getElementById('luna-composer-share-action-copy');
            const postBtn = document.getElementById('luna-composer-share-action-post');
            const copySection = document.getElementById('luna-composer-share-copy-section');
            const postSection = document.getElementById('luna-composer-share-post-section');
            
            if (action === 'copy') {
                if (copyBtn) copyBtn.classList.add('active');
                if (postBtn) postBtn.classList.remove('active');
                if (copySection) copySection.style.display = 'block';
                if (postSection) postSection.style.display = 'none';
            } else if (action === 'post') {
                if (copyBtn) copyBtn.classList.remove('active');
                if (postBtn) postBtn.classList.add('active');
                if (copySection) copySection.style.display = 'none';
                if (postSection) postSection.style.display = 'block';
            }
        };
        
        window.lunaComposerCopyShareLink = function() {
            console.log('[Luna Composer] Copying share link');
            const linkInput = document.getElementById('luna-composer-share-link-input');
            if (!linkInput) {
                console.error('[Luna Composer] Share link input not found');
                return;
            }
            
            const shareUrl = linkInput.value;
            
            // Copy to clipboard
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(shareUrl).then(() => {
                    const copyBtn = document.getElementById('luna-composer-share-copy-btn');
                    if (copyBtn) {
                        const originalText = copyBtn.textContent;
                        copyBtn.textContent = 'Copied!';
                        copyBtn.style.background = '#1f1d1a';
                        setTimeout(() => {
                            copyBtn.textContent = originalText;
                            copyBtn.style.background = '#fff4e9';
                        }, 2000);
                    }
                    console.log('[Luna Composer] Link copied:', shareUrl);
                }).catch((err) => {
                    console.error('[Luna Composer] Clipboard error:', err);
                    // Fallback
                    linkInput.select();
                    document.execCommand('copy');
                    window.showVLNotification('Shareable link copied to clipboard!', 'success');
                });
            } else {
                // Fallback for older browsers
                linkInput.select();
                document.execCommand('copy');
                alert('Shareable link copied to clipboard!');
            }
        };
        
        window.lunaComposerCreatePost = async function(platform, options = {}) {
            console.log('[Luna Composer] Creating post on platform:', platform);
            const editor = document.getElementById('luna-composer-editor');
            if (!editor) {
                console.error('[Luna Composer] Editor not found');
                return;
            }
            
            const documentId = editor.getAttribute('data-document-id');
            const licenseKey = editor.getAttribute('data-license-key');
            let content = options.content !== undefined ? options.content : editor.innerHTML;
            const prompt = options.title !== undefined ? options.title : (editor.getAttribute('data-prompt') || '');
            
            // Validate required fields
            if (!licenseKey) {
                console.error('[Luna Composer] License key not found');
                window.showVLNotification('License key not found. Please refresh the page and try again.', 'error');
                return;
            }
            
            // If documentId is missing, generate one or use a temporary one
            let finalDocumentId = documentId;
            if (!finalDocumentId || finalDocumentId === '') {
                finalDocumentId = 'doc_' + Date.now() + '_' + Math.random().toString(36).substring(2, 11);
                editor.setAttribute('data-document-id', finalDocumentId);
                console.log('[Luna Composer] Generated new document ID:', finalDocumentId);
            }
            
            // Clean and validate content
            // Remove empty paragraphs and whitespace-only content
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = content;
            const textContent = tempDiv.textContent || tempDiv.innerText || '';
            const trimmedText = textContent.trim();
            
            // If content is empty or only whitespace, use a default message
            if (!trimmedText || trimmedText === '') {
                console.warn('[Luna Composer] Content is empty, using default content');
                content = '<p>New post from Luna Composer</p>';
            }
            
            // Strip HTML tags for plain text content (for Medium and LinkedIn)
            const plainText = trimmedText || 'New post from Luna Composer';
            
            console.log('[Luna Composer] Post data:', {
                license: licenseKey ? 'present' : 'missing',
                document_id: finalDocumentId,
                title: prompt || 'New Post from Luna Composer',
                content_length: content.length,
                has_content: content.length > 0
            });
            
            if (platform === 'wp') {
                // Create WordPress post as draft
                try {
                    const postData = {
                        license: licenseKey,
                        document_id: finalDocumentId,
                        title: prompt || 'New Post from Luna Composer',
                        content: content,
                        status: 'draft'
                    };
                    
                    console.log('[Luna Composer] Sending post data:', postData);
                    
                    const response = await fetch('https://visiblelight.ai/wp-json/luna_widget/v1/composer/create-post', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify(postData)
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        console.log('[Luna Composer] WordPress post created:', data);
                        if (data.post_id && data.edit_url) {
                            // Mark that a post has been created for this document
                            if (editor) {
                                editor.setAttribute('data-wp-post-created', 'true');
                            }
                            
                            // Check if this is a duplicate
                            if (data.duplicate) {
                                window.open(data.edit_url, '_blank');
                                window.showVLNotification('Post already exists. Opening existing post in WP Admin...', 'success');
                            } else {
                            // Open WordPress admin edit page in new tab
                            window.open(data.edit_url, '_blank');
                                let successMessage = 'WordPress post created as draft! Opening in WP Admin...';
                                // Only show "unreachable" message if created_on_hub is true AND client_site_url exists (meaning we tried but failed)
                                if (data.created_on_hub && data.client_site_url) {
                                    successMessage = 'WordPress post created on Hub. The post is available in WP Admin.';
                                }
                                window.showVLNotification(successMessage, 'success');
                            }
                            window.lunaComposerCloseShareModal();
                        } else {
                            window.showVLNotification('Post created successfully! Post ID: ' + (data.post_id || 'N/A'), 'success');
                            // Mark that a post has been created even if we don't have edit_url
                            if (editor) {
                                editor.setAttribute('data-wp-post-created', 'true');
                            }
                        }
                    } else {
                        const errorData = await response.json().catch(() => ({ message: 'Unknown error' }));
                        console.error('[Luna Composer] Failed to create WordPress post:', response.status, errorData);
                        let errorMessage = errorData.message || 'Unknown error';
                        // Provide more helpful error message for timeout errors
                        if (errorMessage.includes('timeout') || errorMessage.includes('Operation timed out')) {
                            errorMessage = 'Connection to client site timed out. The post will be created on the Hub instead. Please try again.';
                        }
                        window.showVLNotification('Failed to create WordPress post: ' + errorMessage, 'error');
                    }
                } catch (e) {
                    console.error('[Luna Composer] Error creating WordPress post:', e);
                    window.showVLNotification('Error creating WordPress post. Please try again.', 'error');
                }
            } else if (platform === 'wp-auto') {
                // Auto-post from recommendation - same as 'wp' but with additional data stream sync
                try {
                    const postData = {
                        license: licenseKey,
                        document_id: finalDocumentId,
                        title: prompt || 'New Post from Luna Composer',
                        content: content,
                        status: 'draft',
                        auto_post: true // Flag to indicate this is an auto-post from recommendation
                    };
                    
                    console.log('[Luna Composer] Sending auto-post data:', postData);
                    
                    const response = await fetch('https://visiblelight.ai/wp-json/luna_widget/v1/composer/create-post', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify(postData)
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        console.log('[Luna Composer] WordPress auto-post created:', data);
                        
                        // Sync post details as a new data stream
                        if (data.post_id) {
                            await window.lunaComposerSyncPostAsStream(licenseKey, data, content, prompt);
                        }
                        
                        if (data.post_id && data.edit_url) {
                            // Mark that a post has been created for this document
                            const editor = document.getElementById('luna-composer-editor');
                            if (editor) {
                                editor.setAttribute('data-wp-post-created', 'true');
                            }
                            
                            // Check if this is a duplicate
                            if (data.duplicate) {
                                window.open(data.edit_url, '_blank');
                                window.showVLNotification('Post already exists. Opening existing post in WP Admin...', 'success');
                            } else {
                                window.open(data.edit_url, '_blank');
                                let successMessage = 'WordPress post created as draft! Opening in WP Admin...';
                                // Only show "unreachable" message if created_on_hub is true AND client_site_url exists (meaning we tried but failed)
                                if (data.created_on_hub && data.client_site_url) {
                                    successMessage = 'WordPress post created on Hub. The post is available in WP Admin.';
                                }
                                window.showVLNotification(successMessage, 'success');
                            }
                        } else {
                            window.showVLNotification('Post created successfully! Post ID: ' + (data.post_id || 'N/A'), 'success');
                            // Mark that a post has been created even if we don't have edit_url
                            const editor = document.getElementById('luna-composer-editor');
                            if (editor) {
                                editor.setAttribute('data-wp-post-created', 'true');
                            }
                        }
                    } else {
                        const errorData = await response.json().catch(() => ({ message: 'Unknown error' }));
                        console.error('[Luna Composer] Failed to create WordPress auto-post:', response.status, errorData);
                        let errorMessage = errorData.message || 'Unknown error';
                        if (errorMessage.includes('timeout') || errorMessage.includes('Operation timed out')) {
                            errorMessage = 'Connection to client site timed out. The post will be created on the Hub instead. Please try again.';
                        }
                        window.showVLNotification('Failed to create WordPress post: ' + errorMessage, 'error');
                    }
                } catch (e) {
                    console.error('[Luna Composer] Error creating WordPress auto-post:', e);
                    window.showVLNotification('Error creating WordPress post. Please try again.', 'error');
                }
            } else if (platform === 'medium') {
                // Open Medium.com in new tab
                // Medium doesn't have a direct API for creating posts, so we'll open the new post page
                const mediumUrl = 'https://medium.com/new-story';
                window.open(mediumUrl, '_blank');
                
                // Copy content to clipboard so user can paste it
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(plainText).then(() => {
                        window.showVLNotification('Content copied to clipboard! Opening Medium.com... Paste your content when ready.', 'success');
                    }).catch(() => {
                        window.showVLNotification('Opening Medium.com... Please copy your content manually.', 'success');
                    });
                } else {
                    window.showVLNotification('Opening Medium.com... Please copy your content manually.', 'success');
                }
                window.lunaComposerCloseShareModal();
            } else if (platform === 'linkedin') {
                // Open LinkedIn post composer
                // LinkedIn doesn't have a public API for creating posts, so we'll open the post composer
                const linkedinUrl = 'https://www.linkedin.com/feed/';
                window.open(linkedinUrl, '_blank');
                
                // Copy content to clipboard so user can paste it
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(plainText).then(() => {
                        window.showVLNotification('Content copied to clipboard! Opening LinkedIn... Paste your content when ready.', 'success');
                    }).catch(() => {
                        window.showVLNotification('Opening LinkedIn... Please copy your content manually.', 'success');
                    });
                } else {
                    window.showVLNotification('Opening LinkedIn... Please copy your content manually.', 'success');
                }
                window.lunaComposerCloseShareModal();
            }
        };
        
        // Auto-post from recommendation - creates WordPress post from recommendation text
        window.lunaComposerAutoPostFromRecommendation = async function(recommendationText, licenseKey, editor) {
            console.log('[Luna Composer] Auto-posting from recommendation:', recommendationText);
            
            if (!editor) {
                editor = document.getElementById('luna-composer-editor');
            }
            
            if (!editor) {
                console.error('[Luna Composer] Editor not found');
                window.showVLNotification('Editor not found. Please refresh the page and try again.', 'error');
                return;
            }
            
            const documentId = editor.getAttribute('data-document-id');
            const prompt = editor.getAttribute('data-prompt') || '';
            
            // Check if a post has already been created for this document
            const postCreatedFlag = editor.getAttribute('data-wp-post-created');
            if (postCreatedFlag === 'true') {
                console.log('[Luna Composer] Post already created for this document, skipping duplicate creation');
                window.showVLNotification('A WordPress post has already been created for this document. Check WP Admin > Posts for the existing draft.', 'success');
                return;
            }
            
            let content = editor.innerHTML;
            
            // Generate title from recommendation or use prompt
            const title = recommendationText || prompt || 'New Post from Luna Composer';
            
            // If content is empty, use the recommendation text
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = content;
            const textContent = (tempDiv.textContent || '').trim();
            
            if (!textContent || textContent.length < 50) {
                // Use the full editor content plus recommendation
                content = editor.innerHTML + '<h2>Recommended Action</h2><p>' + recommendationText + '</p>';
            }
            
            // Call the WordPress post creation with wp-auto platform
            try {
                await window.lunaComposerCreatePost('wp-auto', {
                    title: title,
                    content: content,
                    recommendation: recommendationText
                });
                
                // Mark that a post has been created for this document
                editor.setAttribute('data-wp-post-created', 'true');
            } catch (error) {
                console.error('[Luna Composer] Error creating post:', error);
                throw error; // Re-throw to be handled by the button handler
            }
        };
        
        // Sync WordPress post as a new data stream to Hub Profile
        window.lunaComposerSyncPostAsStream = async function(licenseKey, postData, content, prompt) {
            console.log('[Luna Composer] Syncing post as data stream:', postData);
            
            try {
                // Extract post metadata
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = content;
                const plainText = (tempDiv.textContent || '').trim();
                const wordCount = plainText.split(/\s+/).length;
                
                // Extract potential categories and tags from content (basic extraction)
                const contentLower = plainText.toLowerCase();
                const commonCategories = ['technology', 'business', 'marketing', 'design', 'development', 'security', 'seo', 'content'];
                const detectedCategories = commonCategories.filter(cat => contentLower.includes(cat));
                
                // Extract SEO-relevant info
                const firstParagraph = plainText.split('\n')[0] || plainText.substring(0, 160);
                const metaDescription = firstParagraph.length > 160 ? firstParagraph.substring(0, 157) + '...' : firstParagraph;
                
                // Create stream data
                const streamData = {
                    id: 'luna-automation-wp-post-' + postData.post_id,
                    name: 'Luna Automation: WordPress Post #' + postData.post_id,
                    description: 'WordPress post created automatically from Luna Compose recommendation',
                    categories: ['luna-automation', 'content', 'wordpress'],
                    stream_type: 'luna-automation-wp-post',
                    status: 'active',
                    health_score: 100.0,
                    error_count: 0,
                    warning_count: 0,
                    last_updated: new Date().toISOString(),
                    post_details: {
                        post_id: postData.post_id,
                        title: prompt || 'New Post from Luna Composer',
                        status: 'draft',
                        author: 'Luna Composer',
                        publish_date: null, // Draft posts don't have publish date
                        created_date: new Date().toISOString(),
                        site_url: postData.site_url || postData.client_site_url || 'Hub',
                        edit_url: postData.edit_url,
                        word_count: wordCount,
                        categories: detectedCategories.length > 0 ? detectedCategories : ['Uncategorized'],
                        tags: [], // Can be enhanced later
                        seo_info: {
                            meta_description: metaDescription,
                            focus_keyword: null, // Can be extracted or set later
                            title_length: (prompt || 'New Post from Luna Composer').length,
                            description_length: metaDescription.length,
                            word_count: wordCount
                        },
                        automation_source: 'luna-compose-recommendation',
                        document_id: postData.document_id || null
                    }
                };
                
                // Sync to Hub
                const syncResponse = await fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/sync-client-data?license=${encodeURIComponent(licenseKey)}&category=luna-automation`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        license: licenseKey,
                        category: 'luna-automation',
                        data: {
                            [streamData.id]: streamData
                        }
                    })
                });
                
                if (syncResponse.ok) {
                    console.log('[Luna Composer] Post synced as data stream successfully');
                } else {
                    console.warn('[Luna Composer] Failed to sync post as data stream:', syncResponse.status);
                }
            } catch (error) {
                console.error('[Luna Composer] Error syncing post as data stream:', error);
                // Don't throw - this is a non-critical operation
            }
        };
        
        // Auto-post from recommendation - creates WordPress post from recommendation text
        window.lunaComposerAutoPostFromRecommendation = async function(recommendationText, licenseKey, editor) {
            console.log('[Luna Composer] Auto-posting from recommendation:', recommendationText);
            
            if (!editor) {
                editor = document.getElementById('luna-composer-editor');
            }
            
            if (!editor) {
                console.error('[Luna Composer] Editor not found');
                window.showVLNotification('Editor not found. Please refresh the page and try again.', 'error');
                return;
            }
            
            const documentId = editor.getAttribute('data-document-id');
            const prompt = editor.getAttribute('data-prompt') || '';
            
            // Check if a post has already been created for this document
            const postCreatedFlag = editor.getAttribute('data-wp-post-created');
            if (postCreatedFlag === 'true') {
                console.log('[Luna Composer] Post already created for this document, skipping duplicate creation');
                window.showVLNotification('A WordPress post has already been created for this document. Check WP Admin > Posts for the existing draft.', 'success');
                return;
            }
            
            let content = editor.innerHTML;
            
            // Generate title from recommendation or use prompt
            const title = recommendationText || prompt || 'New Post from Luna Composer';
            
            // If content is empty, use the recommendation text
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = content;
            const textContent = (tempDiv.textContent || '').trim();
            
            if (!textContent || textContent.length < 50) {
                // Use the full editor content plus recommendation
                content = editor.innerHTML + '<h2>Recommended Action</h2><p>' + recommendationText + '</p>';
            }
            
            // Call the WordPress post creation with wp-auto platform
            try {
                await window.lunaComposerCreatePost('wp-auto', {
                    title: title,
                    content: content,
                    recommendation: recommendationText
                });
                
                // Mark that a post has been created for this document
                editor.setAttribute('data-wp-post-created', 'true');
            } catch (error) {
                console.error('[Luna Composer] Error creating post:', error);
                throw error; // Re-throw to be handled by the button handler
            }
        };
        
        // Sync WordPress post as a new data stream to Hub Profile
        window.lunaComposerSyncPostAsStream = async function(licenseKey, postData, content, prompt) {
            console.log('[Luna Composer] Syncing post as data stream:', postData);
            
            try {
                // Extract post metadata
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = content;
                const plainText = (tempDiv.textContent || '').trim();
                const wordCount = plainText.split(/\s+/).length;
                
                // Extract potential categories and tags from content (basic extraction)
                const contentLower = plainText.toLowerCase();
                const commonCategories = ['technology', 'business', 'marketing', 'design', 'development', 'security', 'seo', 'content'];
                const detectedCategories = commonCategories.filter(cat => contentLower.includes(cat));
                
                // Extract SEO-relevant info
                const firstParagraph = plainText.split('\n')[0] || plainText.substring(0, 160);
                const metaDescription = firstParagraph.length > 160 ? firstParagraph.substring(0, 157) + '...' : firstParagraph;
                
                // Create stream data
                const streamData = {
                    id: 'luna-automation-wp-post-' + postData.post_id,
                    name: 'Luna Automation: WordPress Post #' + postData.post_id,
                    description: 'WordPress post created automatically from Luna Compose recommendation',
                    categories: ['luna-automation', 'content', 'wordpress'],
                    stream_type: 'luna-automation-wp-post',
                    status: 'active',
                    health_score: 100.0,
                    error_count: 0,
                    warning_count: 0,
                    last_updated: new Date().toISOString(),
                    post_details: {
                        post_id: postData.post_id,
                        title: prompt || 'New Post from Luna Composer',
                        status: 'draft',
                        author: 'Luna Composer',
                        publish_date: null, // Draft posts don't have publish date
                        created_date: new Date().toISOString(),
                        site_url: postData.site_url || postData.client_site_url || 'Hub',
                        edit_url: postData.edit_url,
                        word_count: wordCount,
                        categories: detectedCategories.length > 0 ? detectedCategories : ['Uncategorized'],
                        tags: [], // Can be enhanced later
                        seo_info: {
                            meta_description: metaDescription,
                            focus_keyword: null, // Can be extracted or set later
                            title_length: (prompt || 'New Post from Luna Composer').length,
                            description_length: metaDescription.length,
                            word_count: wordCount
                        },
                        automation_source: 'luna-compose-recommendation',
                        document_id: postData.document_id || null
                    }
                };
                
                // Sync to Hub
                const syncResponse = await fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/sync-client-data?license=${encodeURIComponent(licenseKey)}&category=luna-automation`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        license: licenseKey,
                        category: 'luna-automation',
                        data: {
                            [streamData.id]: streamData
                        }
                    })
                });
                
                if (syncResponse.ok) {
                    console.log('[Luna Composer] Post synced as data stream successfully');
                } else {
                    console.warn('[Luna Composer] Failed to sync post as data stream:', syncResponse.status);
                }
            } catch (error) {
                console.error('[Luna Composer] Error syncing post as data stream:', error);
                // Don't throw - this is a non-critical operation
            }
        };
        
        window.lunaComposerEmail = function() {
            console.log('[Luna Composer] Opening email client');
            const editor = document.getElementById('luna-composer-editor');
            if (!editor) {
                console.error('[Luna Composer] Editor not found');
                return;
            }
            
            const content = editor.innerText || editor.textContent || '';
            const subject = encodeURIComponent('Luna Composer Document');
            const body = encodeURIComponent(content);
            const mailtoLink = `mailto:?subject=${subject}&body=${body}`;
            
            window.location.href = mailtoLink;
            window.lunaComposerToggleShareMenu();
        };
        
        // Export functions - make globally accessible
        window.lunaComposerToggleExportMenu = function() {
            console.log('[Luna Composer] Toggling export menu');
            const menu = document.getElementById('luna-composer-export-menu');
            const btn = document.getElementById('luna-composer-export-btn');
            if (menu && btn) {
                const isVisible = menu.style.display === 'block' || menu.style.display === '';
                if (isVisible) {
                    menu.style.display = 'none';
                } else {
                    // Calculate position relative to button
                    const btnRect = btn.getBoundingClientRect();
                    menu.style.position = 'fixed';
                    menu.style.display = 'block';
                    // Force backdrop-filter styles
                    menu.style.setProperty('background', 'rgba(0,0,0,0.85)', 'important');
                    menu.style.setProperty('backdrop-filter', 'blur(12px)', 'important');
                    menu.style.setProperty('-webkit-backdrop-filter', 'blur(12px)', 'important');
                    menu.style.setProperty('z-index', '10000', 'important');
                }
            } else {
                console.error('[Luna Composer] Export menu or button not found');
            }
        };
        
        window.lunaComposerExportTo = function(format) {
            console.log('[Luna Composer] Exporting to:', format);
            const editor = document.getElementById('luna-composer-editor');
            if (!editor) {
                console.error('[Luna Composer] Editor not found');
                return;
            }
            
            const content = editor.innerText || editor.textContent || '';
            const htmlContent = editor.innerHTML;
            
            if (format === 'google-docs') {
                // Open Google Docs in new tab
                const url = 'https://docs.google.com/document/create?usp=sharing';
                window.open(url, '_blank');
                // Note: Google Docs doesn't support direct content injection via URL
                // User will need to paste content manually
                alert('Google Docs opened in a new tab. Please paste your content manually.');
            } else if (format === 'csv') {
                // Export as CSV
                const csvContent = '"Content"\n"' + content.replace(/"/g, '""') + '"';
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'luna-composer-' + Date.now() + '.csv';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                console.log('[Luna Composer] CSV exported');
            } else if (format === 'pdf') {
                // Export as PDF with exact formatting using browser print
                const printWindow = window.open('', '_blank');
                if (!printWindow) {
                    alert('Please allow popups to export as PDF');
                    return;
                }
                
                // Create a styled document that preserves formatting
                printWindow.document.write(`
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <title>Luna Composer Export</title>
                            <meta charset="utf-8">
                            <style>
                                body { 
                                    font-family: Arial, sans-serif; 
                                    padding: 40px; 
                                    color: #000; 
                                    background: #fff;
                                    line-height: 1.6;
                                }
                                .content { 
                                    white-space: pre-wrap;
                                    word-wrap: break-word;
                                }
                                p { margin: 1em 0; }
                                strong { font-weight: bold; }
                                em { font-style: italic; }
                                u { text-decoration: underline; }
                                s { text-decoration: line-through; }
                                ul, ol { margin: 1em 0; padding-left: 2em; }
                            </style>
                        </head>
                        <body>
                            <div class="content">${htmlContent}</div>
                        </body>
                    </html>
                `);
                printWindow.document.close();
                
                // Wait for content to load, then print
                setTimeout(() => {
                    printWindow.print();
                }, 250);
                console.log('[Luna Composer] PDF export initiated');
            } else if (format === 'mp3') {
                // Export as MP3 audio file
                if (!content.trim()) {
                    alert('No text to convert to audio.');
                    return;
                }
                
                // Show loading message
                const exportBtn = document.getElementById('luna-composer-export-btn');
                if (exportBtn) {
                    const originalText = exportBtn.textContent;
                    exportBtn.textContent = 'Generating audio...';
                    exportBtn.disabled = true;
                    
                    try {
                        // Use Web Speech API to generate audio
                        const synth = window.speechSynthesis;
                        if (!synth) {
                            throw new Error('Speech synthesis not supported');
                        }
                        
                        // Create utterance
                        const utterance = new SpeechSynthesisUtterance(content);
                        utterance.lang = 'en-US';
                        utterance.rate = 1.0;
                        utterance.pitch = 1.0;
                        utterance.volume = 1.0;
                        
                        // Use MediaRecorder API to record the speech
                        // Note: This requires a MediaStream, which we'll create from the audio context
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const destination = audioContext.createMediaStreamDestination();
                        
                        // Create a MediaRecorder to capture the audio
                        const mediaRecorder = new MediaRecorder(destination.stream);
                        const chunks = [];
                        
                        mediaRecorder.ondataavailable = (event) => {
                            if (event.data.size > 0) {
                                chunks.push(event.data);
                            }
                        };
                        
                        mediaRecorder.onstop = () => {
                            const blob = new Blob(chunks, { type: 'audio/webm' });
                            
                            // Convert WebM to MP3 using a library or service
                            // For now, we'll download as WebM and note that MP3 conversion requires server-side processing
                            // In a production environment, you'd send this to a server to convert to MP3
                            
                            // For client-side conversion, we can use a library like lamejs
                            // But for simplicity, we'll download as WebM and note the limitation
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = 'luna-composer-' + Date.now() + '.webm';
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                            
                            // Note: WebM to MP3 conversion typically requires server-side processing
                            // For now, downloading as WebM. To get MP3, you'd need to:
                            // 1. Send the WebM blob to a server endpoint
                            // 2. Convert using ffmpeg or similar tool
                            // 3. Return the MP3 file
                            
                            alert('Audio exported as WebM. Note: MP3 conversion requires server-side processing. The file can be converted using online tools or server-side conversion.');
                            
                            if (exportBtn) {
                                exportBtn.textContent = originalText;
                                exportBtn.disabled = false;
                            }
                        };
                        
                        // Start recording
                        mediaRecorder.start();
                        
                        // Speak the text
                        utterance.onend = () => {
                            setTimeout(() => {
                                mediaRecorder.stop();
                            }, 500); // Small delay to ensure all audio is captured
                        };
                        
                        synth.speak(utterance);
                        
                    } catch (error) {
                        console.error('[Luna Composer] Error generating audio:', error);
                        alert('Error generating audio file. Please try again or use a different browser.');
                        if (exportBtn) {
                            exportBtn.textContent = originalText;
                            exportBtn.disabled = false;
                        }
                    }
                }
            }
            
            window.lunaComposerToggleExportMenu();
        };
        
        // Initialize prompt form functionality
        function initializePromptForm() {
            const promptTextarea = document.getElementById('prompt-textarea');
            const saveBtn = document.getElementById('luna-composer-save-prompt-btn');
            
            if (!promptTextarea || !saveBtn) {
                console.warn('[Luna Composer] Prompt form elements not found');
                return;
            }
            
            // Initialize placeholder visibility
            const placeholder = promptTextarea.querySelector('.placeholder');
            if (placeholder) {
                // Ensure placeholder is visible initially
                placeholder.style.display = 'block';
                placeholder.style.color = '#fff4e7';
            }
            
            // Handle text input and update placeholder
            promptTextarea.addEventListener('input', function() {
                const text = promptTextarea.textContent.trim();
                const placeholder = promptTextarea.querySelector('.placeholder');
                
                // Check if text is just the placeholder text
                const placeholderText = placeholder ? placeholder.textContent.replace(/\s+/g, ' ').trim() : '';
                const isPlaceholderOnly = text === placeholderText || text === '';
                
                if (!isPlaceholderOnly && text.length > 0) {
                    // Hide placeholder and show save button
                    if (placeholder) {
                        placeholder.style.display = 'none';
                    }
                    saveBtn.style.display = 'flex';
                    saveBtn.style.visibility = 'visible';
                } else {
                    // Show placeholder and hide save button
                    if (placeholder) {
                        placeholder.style.display = 'block';
                        placeholder.style.color = '#fff4e7';
                    }
                    saveBtn.style.display = 'none';
                    saveBtn.style.visibility = 'hidden';
                }
            });
            
            // Handle focus - hide placeholder when user starts typing
            promptTextarea.addEventListener('focus', function() {
                const text = promptTextarea.textContent.trim();
                const placeholder = promptTextarea.querySelector('.placeholder');
                const placeholderText = placeholder ? placeholder.textContent.replace(/\s+/g, ' ').trim() : '';
                
                if (text === placeholderText || text === '') {
                    // Clear placeholder text when focused so user can type
                    if (placeholder && promptTextarea.textContent.trim() === placeholderText) {
                        promptTextarea.textContent = '';
                    }
                }
            });
            
            // Handle blur - show placeholder if empty
            promptTextarea.addEventListener('blur', function() {
                const text = promptTextarea.textContent.trim();
                const placeholder = promptTextarea.querySelector('.placeholder');
                if ((text.length === 0 || text === '') && placeholder) {
                    // Restore placeholder text
                    placeholder.style.display = 'block';
                    placeholder.style.color = '#fff4e7';
                    if (promptTextarea.textContent.trim() === '') {
                        promptTextarea.innerHTML = '<p data-placeholder="Write a custom prompt or choose from <i>Saved Prompts</i>..." class="placeholder" style="color: #fff4e7; margin: 0;">Write a custom prompt or choose from <i>Saved Prompts</i>...<br class="ProseMirror-trailingBreak"></p>';
                    }
                }
            });
            
            // Handle Enter key to submit (prevent default new line)
            promptTextarea.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    const text = promptTextarea.textContent.trim();
                    if (text.length > 0) {
                        // Use the prompt as a command
                        window.lunaComposerUsePrompt(null, text, '');
                        // Clear the textarea
                        promptTextarea.textContent = '';
                        const placeholder = promptTextarea.querySelector('.placeholder');
                        if (placeholder) {
                            placeholder.style.display = 'block';
                        }
                        saveBtn.style.display = 'none';
                    }
                }
            });
        }
        
        // Save prompt to Essentials
        window.lunaComposerSavePrompt = async function(e) {
            if (e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            const promptTextarea = document.getElementById('prompt-textarea');
            if (!promptTextarea) {
                console.error('[Luna Composer] Prompt textarea not found');
                return;
            }
            
            const promptText = promptTextarea.textContent.trim();
            if (!promptText) {
                console.warn('[Luna Composer] No text to save');
                return;
            }
            
            const saveBtn = document.getElementById('luna-composer-save-prompt-btn');
            if (saveBtn) {
                saveBtn.disabled = true;
                saveBtn.style.opacity = '0.5';
                saveBtn.style.cursor = 'not-allowed';
            }
            
            try {
                // Get license key
                const urlParams = new URLSearchParams(window.location.search);
                const urlLicense = urlParams.get('license') || '';
                let extractedLicenseKey = '';
                if (urlLicense) {
                    const parts = urlLicense.split('/');
                    extractedLicenseKey = parts[0];
                }
                
                if (!extractedLicenseKey) {
                    throw new Error('License key not found');
                }
                
                // Get client site URL from Hub
                let clientSiteUrl = null;
                try {
                    const hubResp = await fetch(`https://visiblelight.ai/wp-json/vl-hub/v1/all-connections?license=${encodeURIComponent(extractedLicenseKey)}`, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include'
                    });
                    if (hubResp.ok) {
                        const hubData = await hubResp.json();
                        const data = hubData?.ok && hubData?.data ? hubData.data : hubData;
                        if (data && data.client_streams) {
                            // Find WordPress connection
                            const streams = Object.values(data.client_streams);
                            const wpStream = streams.find(s => s.category === 'content' || s.name?.toLowerCase().includes('wordpress'));
                            if (wpStream && wpStream.data && wpStream.data.home_url) {
                                clientSiteUrl = wpStream.data.home_url;
                            }
                        }
                    }
                } catch (err) {
                    console.warn('[Luna Composer] Could not fetch client site URL:', err);
                }
                
                // Try to save to client site first, then Hub
                let saved = false;
                const sitesToTry = clientSiteUrl ? [clientSiteUrl, 'https://visiblelight.ai'] : ['https://visiblelight.ai'];
                
                for (const siteUrl of sitesToTry) {
                    try {
                        // Create new Essential via WordPress REST API
                        const restUrl = `${siteUrl}/wp-json/wp/v2/luna_essentials`;
                        const createResp = await fetch(restUrl, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-WP-Nonce': await getWpNonce(siteUrl)
                            },
                            credentials: 'include',
                            body: JSON.stringify({
                                title: promptText.substring(0, 100), // Use first 100 chars as title
                                content: promptText,
                                status: 'publish'
                            })
                        });
                        
                        if (createResp.ok) {
                            const newEssential = await createResp.json();
                            console.log('[Luna Composer] Saved prompt to Essentials:', newEssential);
                            
                            // Add to canned-prompts-list in UI
                            addPromptToUIList(newEssential.id, promptText, newEssential.title);
                            
                            saved = true;
                            break;
                        } else {
                            console.warn(`[Luna Composer] Failed to save to ${siteUrl}:`, createResp.status);
                        }
                    } catch (err) {
                        console.warn(`[Luna Composer] Error saving to ${siteUrl}:`, err);
                    }
                }
                
                if (saved) {
                    // Show success notification
                    if (typeof window.showVLNotification === 'function') {
                        window.showVLNotification('Prompt saved to Essentials!', 'success');
                    }
                    
                    // Clear the textarea
                    promptTextarea.textContent = '';
                    const placeholder = promptTextarea.querySelector('.placeholder');
                    if (placeholder) {
                        placeholder.style.display = 'block';
                    }
                    saveBtn.style.display = 'none';
                } else {
                    throw new Error('Failed to save prompt to any site');
                }
            } catch (error) {
                console.error('[Luna Composer] Error saving prompt:', error);
                if (typeof window.showVLNotification === 'function') {
                    window.showVLNotification('Failed to save prompt. Please try again.', 'error');
                }
            } finally {
                if (saveBtn) {
                    saveBtn.disabled = false;
                    saveBtn.style.opacity = '1';
                    saveBtn.style.cursor = 'pointer';
                }
            }
        };
        
        // Helper function to get WordPress nonce
        async function getWpNonce(siteUrl) {
            try {
                const nonceResp = await fetch(`${siteUrl}/wp-json/wp/v2/`, {
                    method: 'GET',
                    credentials: 'include'
                });
                // WordPress REST API doesn't require nonce for cookie-based auth
                // Return empty string - WordPress will use cookies
                return '';
            } catch (err) {
                return '';
            }
        }
        
        // Helper function to add prompt to UI list
        function addPromptToUIList(id, text, title) {
            const list = document.querySelector('.canned-prompts-list');
            if (!list) {
                console.warn('[Luna Composer] Canned prompts list not found');
                return;
            }
            
            // Create new prompt item
            const escapedText = text.replace(/'/g, "\\'").replace(/"/g, '&quot;');
            const escapedTitle = (title || text.substring(0, 50)).replace(/'/g, "\\'").replace(/"/g, '&quot;');
            const itemHTML = `
                <div class="canned-prompt-item" data-prompt-id="${id}" style="width: 100%; flex-shrink: 0; border-bottom: 1px solid rgb(46, 44, 42); padding-bottom: 10px;" onmouseover="this.style.borderColor='#5A5753';" onmouseout="this.style.borderColor='#2E2C2A';">
                    <div class="canned-prompt-header" style="display: flex; align-items: center; justify-content: space-between; cursor: pointer; margin-bottom: 0;" onclick="window.toggleCannedPrompt(this, '${id}', '${escapedText}')">
                        <h3 class="canned-prompt-title" data-tooltip="${(text || escapedTitle).replace(/"/g, '&quot;')}" style="color: #fff4e9; margin: 0; font-size: 1rem; font-weight: 400; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; position: relative;">${escapedTitle}</h3>
                        <img src="https://visiblelight.ai/wp-content/uploads/2025/08/downarrow.svg" class="canned-prompt-arrow" alt="Toggle" style="width: 13px; height: 8px; margin-left: 10px; flex-shrink: 0; transition: transform 0.3s ease;" />
                    </div>
                    <div class="canned-prompt-content" style="display: none; color: #9A9793; margin: 0; font-size: 0.8rem; line-height: 1.4; overflow: hidden; transition: max-height 0.3s ease, opacity 0.3s ease; opacity: 0; max-height: 0;">
                        <p style="margin: 0; padding-top: 8px;">${text}</p>
                        <div"><button onclick="event.stopPropagation(); window.lunaComposerUsePrompt('${id}', '${escapedText}', '')" style="background: #fff4e9; color: #000; border: none; padding: 3px 7px; border-radius: 4px; cursor: pointer; font-size: 0.8rem; font-weight: 500;">Use Prompt</button></div>
                    </div>
                    <div style="color: #9A9793; font-size: 0.75rem;">${text.length > 100 ? text.substring(0, 100) + '...' : text}</div>
                </div>
            `;
            
            // Insert at the beginning of the list
            list.insertAdjacentHTML('afterbegin', itemHTML);
        }
        
        // Dictate functionality
        let recognition = null;
        let isDictating = false;
        
        window.lunaComposerToggleDictate = function() {
            // Check if prompt textarea is focused, otherwise use editor
            const promptTextarea = document.getElementById('prompt-textarea');
            const editor = document.getElementById('luna-composer-editor');
            const dictateBtn = document.getElementById('luna-composer-dictate-btn');
            
            // Determine which element to use based on focus
            const activeElement = document.activeElement;
            const targetElement = (activeElement && activeElement.id === 'prompt-textarea') ? promptTextarea : editor;
            
            if (!targetElement) {
                console.error('[Luna Composer] Target element not found');
                return;
            }
            
            // Check if browser supports Speech Recognition
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                alert('Speech recognition is not supported in your browser. Please use Chrome, Edge, or Safari.');
                return;
            }
            
            if (!isDictating) {
                // Start dictation
                if (!recognition) {
                    recognition = new SpeechRecognition();
                    recognition.continuous = true;
                    recognition.interimResults = true;
                    recognition.lang = 'en-US';
                    
                    recognition.onresult = function(event) {
                        const currentTarget = (document.activeElement && document.activeElement.id === 'prompt-textarea') 
                            ? document.getElementById('prompt-textarea') 
                            : document.getElementById('luna-composer-editor');
                        if (!currentTarget) return;
                        let interimTranscript = '';
                        let finalTranscript = '';
                        
                        for (let i = event.resultIndex; i < event.results.length; i++) {
                            const transcript = event.results[i][0].transcript;
                            if (event.results[i].isFinal) {
                                finalTranscript += transcript + ' ';
                            } else {
                                interimTranscript += transcript;
                            }
                        }
                        
                        if (finalTranscript) {
                            // Insert final transcript at cursor position
                            const selection = window.getSelection();
                            if (selection.rangeCount > 0) {
                                const range = selection.getRangeAt(0);
                                range.deleteContents();
                                const textNode = document.createTextNode(finalTranscript);
                                range.insertNode(textNode);
                                range.setStartAfter(textNode);
                                range.collapse(true);
                                selection.removeAllRanges();
                                selection.addRange(range);
                            } else {
                                // Append to end if no selection
                                currentTarget.textContent += finalTranscript;
                                // Trigger input event to update save button visibility
                                currentTarget.dispatchEvent(new Event('input', { bubbles: true }));
                            }
                        }
                    };
                    
                    recognition.onerror = function(event) {
                        console.error('[Luna Composer] Speech recognition error:', event.error);
                        if (event.error === 'no-speech') {
                            alert('No speech detected. Please try again.');
                        } else if (event.error === 'not-allowed') {
                            alert('Microphone permission denied. Please allow microphone access.');
                        }
                        isDictating = false;
                        if (dictateBtn) {
                            dictateBtn.textContent = 'Dictate';
                            dictateBtn.style.background = '#2E2C2A50';
                        }
                    };
                    
                    recognition.onend = function() {
                        isDictating = false;
                        if (dictateBtn) {
                            dictateBtn.textContent = 'Dictate';
                            dictateBtn.style.background = '#2E2C2A50';
                        }
                    };
                }
                
                try {
                    recognition.start();
                    isDictating = true;
                    if (dictateBtn) {
                        dictateBtn.textContent = 'Stop Dictating';
                        dictateBtn.style.background = '#d63638';
                    }
                } catch (e) {
                    console.error('[Luna Composer] Error starting recognition:', e);
                    alert('Error starting speech recognition. Please try again.');
                }
            } else {
                // Stop dictation
                if (recognition) {
                    recognition.stop();
                    isDictating = false;
                    if (dictateBtn) {
                        dictateBtn.textContent = 'Dictate';
                        dictateBtn.style.background = '#2E2C2A50';
                    }
                }
            }
        };
        
        // Audio readback functionality
        let synth = window.speechSynthesis;
        let isReading = false;
        let currentUtterance = null;
        
        window.lunaComposerToggleReadback = function() {
            const editor = document.getElementById('luna-composer-editor');
            const readbackBtn = document.getElementById('luna-composer-readback-btn');
            
            if (!editor) {
                console.error('[Luna Composer] Editor not found');
                return;
            }
            
            if (!synth) {
                alert('Speech synthesis is not supported in your browser.');
                return;
            }
            
            if (isReading) {
                // Stop reading
                synth.cancel();
                isReading = false;
                if (readbackBtn) {
                    readbackBtn.textContent = 'Read Aloud';
                    readbackBtn.style.background = '#2E2C2A50';
                }
            } else {
                // Start reading
                const text = editor.innerText || editor.textContent || '';
                if (!text.trim()) {
                    alert('No text to read.');
                    return;
                }
                
                // Cancel any ongoing speech
                synth.cancel();
                
                currentUtterance = new SpeechSynthesisUtterance(text);
                currentUtterance.lang = 'en-US';
                currentUtterance.rate = 1.0;
                currentUtterance.pitch = 1.0;
                currentUtterance.volume = 1.0;
                
                currentUtterance.onend = function() {
                    isReading = false;
                    if (readbackBtn) {
                        readbackBtn.textContent = 'Read Aloud';
                        readbackBtn.style.background = '#2E2C2A50';
                    }
                };
                
                currentUtterance.onerror = function(event) {
                    console.error('[Luna Composer] Speech synthesis error:', event.error);
                    isReading = false;
                    if (readbackBtn) {
                        readbackBtn.textContent = 'Read Aloud';
                        readbackBtn.style.background = '#2E2C2A50';
                    }
                };
                
                synth.speak(currentUtterance);
                isReading = true;
                if (readbackBtn) {
                    readbackBtn.textContent = 'Stop Reading';
                    readbackBtn.style.background = '#d63638';
                }
            }
        };
        
        // Delete functions - make globally accessible
        window.lunaComposerShowDeleteModal = function() {
            console.log('[Luna Composer] Showing delete modal');
            const modal = document.getElementById('luna-composer-delete-modal');
            if (modal) {
                modal.style.display = 'flex';
                // Reset delete button state
                const deleteBtn = document.getElementById('luna-composer-delete-confirm');
                if (deleteBtn) {
                    deleteBtn.disabled = true;
                    deleteBtn.style.opacity = '0.5';
                    deleteBtn.style.cursor = 'not-allowed';
                }
            } else {
                console.error('[Luna Composer] Delete modal not found');
            }
        };
        
        window.lunaComposerCloseDeleteModal = function() {
            console.log('[Luna Composer] Closing delete modal');
            const modal = document.getElementById('luna-composer-delete-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        };
        
        window.lunaComposerDownloadBackup = function() {
            console.log('[Luna Composer] Downloading backup');
            const editor = document.getElementById('luna-composer-editor');
            if (!editor) {
                console.error('[Luna Composer] Editor not found');
                return;
            }
            
            const content = editor.innerText || editor.textContent || '';
            const htmlContent = editor.innerHTML;
            
            // Export as PDF with exact formatting using browser print
            const printWindow = window.open('', '_blank');
            if (!printWindow) {
                alert('Please allow popups to download backup');
                return;
            }
            
            // Create a styled document that preserves formatting
            printWindow.document.write(`
                <!DOCTYPE html>
                <html>
                    <head>
                        <title>Luna Composer Backup</title>
                        <meta charset="utf-8">
                        <style>
                            body { 
                                font-family: Arial, sans-serif; 
                                padding: 40px; 
                                color: #000; 
                                background: #fff;
                                line-height: 1.6;
                            }
                            .content { 
                                white-space: pre-wrap;
                                word-wrap: break-word;
                            }
                            p { margin: 1em 0; }
                            strong { font-weight: bold; }
                            em { font-style: italic; }
                            u { text-decoration: underline; }
                            s { text-decoration: line-through; }
                            ul, ol { margin: 1em 0; padding-left: 2em; }
                        </style>
                    </head>
                    <body>
                        <div class="content">${htmlContent}</div>
                    </body>
                </html>
            `);
            printWindow.document.close();
            
            // Wait for content to load, then print
            setTimeout(() => {
                printWindow.print();
            }, 250);
            
            // Enable delete button after download
            const deleteBtn = document.getElementById('luna-composer-delete-confirm');
            if (deleteBtn) {
                deleteBtn.disabled = false;
                deleteBtn.style.opacity = '1';
                deleteBtn.style.cursor = 'pointer';
            }
        };
        
        window.lunaComposerDeleteDocument = async function() {
            console.log('[Luna Composer] Deleting document');
            const editor = document.getElementById('luna-composer-editor');
            if (!editor) {
                console.error('[Luna Composer] Editor not found');
                return;
            }
            
            const documentId = editor.getAttribute('data-document-id');
            const licenseKey = editor.getAttribute('data-license-key');
            
            if (!documentId || !licenseKey) {
                console.error('[Luna Composer] Document ID or license key not found');
                return;
            }
            
            try {
                // Delete from WordPress
                const response = await fetch('https://visiblelight.ai/wp-json/luna_widget/v1/composer/delete', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                        license: licenseKey,
                        document_id: documentId
                    })
                });
                
                if (response.ok) {
                    console.log('[Luna Composer] Document deleted from WordPress');
                } else {
                    console.warn('[Luna Composer] Failed to delete from WordPress:', response.status);
                }
            } catch (e) {
                console.warn('[Luna Composer] Error deleting from WordPress:', e);
            }
            
            // Delete from localStorage
            const docKey = `luna_composer_doc_${documentId}`;
            localStorage.removeItem(docKey);
            
            // Remove from history
            const historyKey = `luna_composer_history_${licenseKey}`;
            const historyStr = localStorage.getItem(historyKey);
            if (historyStr) {
                try {
                    const history = JSON.parse(historyStr);
                    const filteredHistory = history.filter(doc => doc.id !== documentId);
                    localStorage.setItem(historyKey, JSON.stringify(filteredHistory));
                } catch (e) {
                    console.warn('[Luna Composer] Could not update history:', e);
                }
            }
            
            // Add activity notification to main Supercluster page (not on /luna/compose/)
            const currentParams = new URLSearchParams(window.location.search);
            const currentLicense = currentParams.get('license') || '';
            const isLunaComposePage = currentLicense.includes('/luna/compose/');
            
            if (!isLunaComposePage) {
                // Add to activity stream
                const activityList = document.getElementById('recentActivityList');
                if (activityList) {
                    const now = new Date();
                    const activityItem = document.createElement('li');
                    activityItem.className = 'vl-activity-item';
                    
                    const timeSpan = document.createElement('span');
                    timeSpan.id = 'activityTimeStamp';
                    timeSpan.textContent = now.toLocaleString();
                    activityItem.appendChild(timeSpan);
                    activityItem.appendChild(document.createElement('br'));
                    
                    const labelText = document.createTextNode('Luna Compose Document was deleted');
                    activityItem.appendChild(labelText);
                    
                    // Remove "No recent activity" if present
                    const emptyItem = activityList.querySelector('.vl-activity-empty');
                    if (emptyItem) {
                        emptyItem.remove();
                    }
                    
                    // Insert at the beginning
                    activityList.insertBefore(activityItem, activityList.firstChild);
                    
                    // Keep only last 10 items
                    const items = activityList.querySelectorAll('.vl-activity-item');
                    if (items.length > 10) {
                        for (let i = 10; i < items.length; i++) {
                            items[i].remove();
                        }
                    }
                }
            }
            
            // Close modal
            window.lunaComposerCloseDeleteModal();
            
            // Reload composer screen
            const baseLicense = currentLicense.split('/luna/compose/')[0];
            const newUrl = new URL(window.location.href);
            newUrl.searchParams.set('license', baseLicense + '/luna/compose/');
            window.location.href = newUrl.toString();
        };
        
        // Toggle heart icon (like/dislike)
        window.lunaComposerToggleHeart = async function() {
            const editor = document.getElementById('luna-composer-editor');
            if (!editor) {
                console.error('[Luna Composer] Editor not found');
                return;
            }
            
            const documentId = editor.getAttribute('data-document-id');
            const licenseKey = editor.getAttribute('data-license-key');
            
            if (!documentId || !licenseKey) {
                console.error('[Luna Composer] Document ID or license key not found');
                return;
            }
            
            // Check current state
            const heartIcon = document.getElementById('luna-composer-heart-icon');
            const heartBtn = document.getElementById('luna-composer-editor-heart-btn');
            
            if (!heartIcon || !heartBtn) {
                console.error('[Luna Composer] Heart icon or button not found');
                return;
            }
            
            // Determine current state from icon src
            const currentSrc = heartIcon.getAttribute('src');
            const isLiked = currentSrc.includes('heart-solid-full.svg');
            const newFeedbackType = isLiked ? 'dislike' : 'like';
            
            // Call the main feedback function (which will update state)
            await window.lunaComposerSubmitFeedback(newFeedbackType);
            
            // Update icon based on new state immediately
            if (newFeedbackType === 'like') {
                heartIcon.setAttribute('src', 'https://visiblelight.ai/wp-content/uploads/2025/11/heart-solid-full.svg');
                heartBtn.style.background = '#000000';
                heartBtn.style.borderColor = '#1f1d1a';
            } else {
                heartIcon.setAttribute('src', 'https://visiblelight.ai/wp-content/uploads/2025/11/heart-regular-full-1.svg');
                heartBtn.style.background = '#2E2C2A50';
                heartBtn.style.borderColor = '#1f1d1a';
            }
            
            // Reload history to reflect changes
            setTimeout(() => {
                if (typeof loadLunaComposerHistory === 'function') {
                loadLunaComposerHistory();
                }
            }, 500);
        };
        
        // Initialize heart icon state when document loads
        window.lunaComposerUpdateHeartState = async function() {
            const editor = document.getElementById('luna-composer-editor');
            if (!editor) return;
            
            const documentId = editor.getAttribute('data-document-id');
            const licenseKey = editor.getAttribute('data-license-key');
            
            if (!documentId || !licenseKey) return;
            
            const heartIcon = document.getElementById('luna-composer-heart-icon');
            const heartBtn = document.getElementById('luna-composer-editor-heart-btn');
            
            if (!heartIcon || !heartBtn) return;
            
            // First, try to fetch feedback from WordPress (most reliable - survives cache clears)
            let isLiked = false;
            try {
                const response = await fetch(`https://visiblelight.ai/wp-json/luna_widget/v1/composer/fetch?license=${encodeURIComponent(licenseKey)}&document_id=${encodeURIComponent(documentId)}`, {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include'
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.documents && data.documents.length > 0) {
                        const docData = data.documents[0];
                        if (docData.feedback === 'like') {
                            isLiked = true;
                            // Update localStorage with WordPress data
                            const feedbackKey = `luna_composer_feedback_${documentId}`;
                            localStorage.setItem(feedbackKey, JSON.stringify({
                                feedback: 'like',
                                timestamp: Date.now()
                            }));
                            const docKey = `luna_composer_doc_${documentId}`;
                            const savedDoc = localStorage.getItem(docKey);
                            if (savedDoc) {
                                try {
                                    const docDataLocal = JSON.parse(savedDoc);
                                    docDataLocal.feedback = 'like';
                                    localStorage.setItem(docKey, JSON.stringify(docDataLocal));
                                } catch (e) {
                                    console.warn('[Luna Composer] Could not update doc data:', e);
                                }
                            }
                        }
                    }
                }
            } catch (e) {
                console.warn('[Luna Composer] Could not fetch feedback from WordPress:', e);
            }
            
            // Fallback to localStorage if WordPress fetch failed
            if (!isLiked) {
                const feedbackKey = `luna_composer_feedback_${documentId}`;
                const feedbackStr = localStorage.getItem(feedbackKey);
                
                if (feedbackStr) {
                    try {
                        const feedbackData = JSON.parse(feedbackStr);
                        isLiked = feedbackData.feedback === 'like';
                    } catch (e) {
                        console.warn('[Luna Composer] Could not parse feedback:', e);
                    }
                }
                
                // Also check document data
                if (!isLiked) {
                    const docKey = `luna_composer_doc_${documentId}`;
                    const savedDoc = localStorage.getItem(docKey);
                    if (savedDoc) {
                        try {
                            const docData = JSON.parse(savedDoc);
                            isLiked = docData.feedback === 'like';
                        } catch (e) {
                            console.warn('[Luna Composer] Could not parse doc data:', e);
                        }
                    }
                }
            }
            
            // Update icon and button state
            if (isLiked) {
                heartIcon.setAttribute('src', 'https://visiblelight.ai/wp-content/uploads/2025/11/heart-solid-full.svg');
                heartBtn.style.background = '#000000';
                heartBtn.style.borderColor = '#1f1d1a';
            } else {
                // Default to dislike state
                heartIcon.setAttribute('src', 'https://visiblelight.ai/wp-content/uploads/2025/11/heart-regular-full-1.svg');
                heartBtn.style.background = '#2E2C2A50';
                heartBtn.style.borderColor = '#1f1d1a';
            }
        };
        
        // Show delete modal for history item
        window.lunaComposerShowDeleteModalForHistory = function(documentId, licenseKey) {
            console.log('[Luna Composer] Showing delete modal for history item:', documentId);
            
            // Store document ID and license key for deletion
            window.lunaComposerPendingDelete = {
                documentId: documentId,
                licenseKey: licenseKey
            };
            
            const modal = document.getElementById('luna-composer-delete-modal');
            if (modal) {
                modal.style.display = 'flex';
                // Reset delete button state
                const deleteBtn = document.getElementById('luna-composer-delete-confirm');
                if (deleteBtn) {
                    deleteBtn.disabled = true;
                    deleteBtn.style.opacity = '0.5';
                    deleteBtn.style.cursor = 'not-allowed';
                }
            } else {
                console.error('[Luna Composer] Delete modal not found');
            }
        };
        
        // Override download backup for history items
        const originalDownloadBackup = window.lunaComposerDownloadBackup;
        window.lunaComposerDownloadBackup = function() {
            // If we have a pending delete from history, load that document first
            if (window.lunaComposerPendingDelete) {
                const { documentId, licenseKey } = window.lunaComposerPendingDelete;
                
                // Try to load document content
                const docKey = `luna_composer_doc_${documentId}`;
                const savedDoc = localStorage.getItem(docKey);
                
                if (savedDoc) {
                    try {
                        const docData = JSON.parse(savedDoc);
                        if (docData.content) {
                            // Temporarily set editor content for backup
                            const editor = document.getElementById('luna-composer-editor');
                            if (editor) {
                                const originalContent = editor.innerHTML;
                                editor.innerHTML = docData.content;
                                
                                // Call original function
                                if (originalDownloadBackup) {
                                    originalDownloadBackup();
                                }
                                
                                // Restore original content after a delay
                                setTimeout(() => {
                                    editor.innerHTML = originalContent;
                                }, 1000);
                                
                                return;
                            }
                        }
                    } catch (e) {
                        console.warn('[Luna Composer] Could not parse doc data for backup:', e);
                    }
                }
            }
            
            // Otherwise, use original function
            if (originalDownloadBackup) {
                return originalDownloadBackup();
            }
        };
        
        // Override delete document function to handle history items
        const originalDeleteDocument = window.lunaComposerDeleteDocument;
        window.lunaComposerDeleteDocument = async function() {
            // Check if we're deleting from history
            if (window.lunaComposerPendingDelete) {
                const { documentId, licenseKey } = window.lunaComposerPendingDelete;
                
                try {
                    // Delete from WordPress
                    const response = await fetch('https://visiblelight.ai/wp-json/luna_widget/v1/composer/delete', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify({
                            license: licenseKey,
                            document_id: documentId
                        })
                    });
                    
                    if (response.ok) {
                        console.log('[Luna Composer] Document deleted from WordPress');
                    } else {
                        console.warn('[Luna Composer] Failed to delete from WordPress:', response.status);
                    }
                } catch (e) {
                    console.warn('[Luna Composer] Error deleting from WordPress:', e);
                }
                
                // Delete from localStorage
                const docKey = `luna_composer_doc_${documentId}`;
                localStorage.removeItem(docKey);
                
                // Remove feedback
                const feedbackKey = `luna_composer_feedback_${documentId}`;
                localStorage.removeItem(feedbackKey);
                
                // Remove from history
                const historyKey = `luna_composer_history_${licenseKey}`;
                const historyStr = localStorage.getItem(historyKey);
                if (historyStr) {
                    try {
                        const history = JSON.parse(historyStr);
                        const filteredHistory = history.filter(doc => doc.id !== documentId);
                        localStorage.setItem(historyKey, JSON.stringify(filteredHistory));
                    } catch (e) {
                        console.warn('[Luna Composer] Could not update history:', e);
                    }
                }
                
                // Close modal
                window.lunaComposerCloseDeleteModal();
                
                // Clear pending delete
                window.lunaComposerPendingDelete = null;
                
                // Reload history
                setTimeout(() => {
                    loadLunaComposerHistory();
                }, 300);
                
                return;
            }
            
            // Otherwise, use original function
            if (originalDeleteDocument) {
                return originalDeleteDocument();
            }
        };
        
        window.lunaComposerSubmitFeedback = async function(feedbackType) {
            const editor = document.getElementById('luna-composer-editor');
            if (!editor) {
                console.error('[Luna Composer] Editor not found');
                return;
            }
            
            const documentId = editor.getAttribute('data-document-id');
            const licenseKey = editor.getAttribute('data-license-key');
            const content = editor.innerHTML || editor.innerText || editor.textContent || '';
            const prompt = editor.getAttribute('data-prompt') || '';
            
            if (!documentId || !licenseKey) {
                console.error('[Luna Composer] Document ID or license key not found');
                return;
            }
            
            try {
                // Save feedback to WordPress
                const response = await fetch('https://visiblelight.ai/wp-json/luna_widget/v1/composer/feedback', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                        license: licenseKey,
                        document_id: documentId,
                        feedback_type: feedbackType,
                        prompt: prompt,
                        content: content.substring(0, 500) // First 500 chars for context
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('[Luna Composer] Feedback saved:', data);
                    
                    // Store feedback in localStorage for history categorization
                    const feedbackKey = `luna_composer_feedback_${documentId}`;
                    localStorage.setItem(feedbackKey, JSON.stringify({
                        feedback: feedbackType,
                        timestamp: Date.now()
                    }));
                    
                    // Also update document data if it exists
                    const docKey = `luna_composer_doc_${documentId}`;
                    const savedDoc = localStorage.getItem(docKey);
                    if (savedDoc) {
                        try {
                            const docData = JSON.parse(savedDoc);
                            docData.feedback = feedbackType;
                            localStorage.setItem(docKey, JSON.stringify(docData));
                        } catch (e) {
                            console.warn('[Luna Composer] Could not update doc data:', e);
                        }
                    }
                    
                    // Feedback saved successfully (heart button will update its state)
                    
                    // Update history immediately to include current document if not already present
                    const currentDocId = documentId;
                    const currentLicense = licenseKey;
                    const currentPrompt = prompt || 'Untitled Document';
                    const currentContent = content;
                    
                    if (currentDocId && currentLicense) {
                        // Add/update document in history
                        const historyKey = `luna_composer_history_${currentLicense}`;
                        let history = [];
                        try {
                            const historyStr = localStorage.getItem(historyKey);
                            if (historyStr) {
                                history = JSON.parse(historyStr);
                            }
                        } catch (e) {
                            console.warn('[Luna Composer] Could not parse history:', e);
                        }
                        
                        // Find or add current document
                        const existingIndex = history.findIndex(doc => doc.id === currentDocId);
                        if (existingIndex !== -1) {
                            history[existingIndex].prompt = currentPrompt;
                            history[existingIndex].timestamp = Date.now();
                            history[existingIndex].feedback = feedbackType;
                } else {
                            history.unshift({
                                id: currentDocId,
                                prompt: currentPrompt,
                                timestamp: Date.now(),
                                feedback: feedbackType
                            });
                        }
                        
                        // Update document data with feedback, preserving existing content
                        const docKey = `luna_composer_doc_${currentDocId}`;
                        let docData = {
                            id: currentDocId,
                            content: currentContent,
                            prompt: currentPrompt,
                            timestamp: Date.now(),
                            license: currentLicense,
                            feedback: feedbackType
                        };
                        
                        // Preserve existing content if document already exists
                        const existingDoc = localStorage.getItem(docKey);
                        if (existingDoc) {
                            try {
                                const existingData = JSON.parse(existingDoc);
                                // Preserve HTML content if it exists, otherwise use text content
                                docData.content = existingData.content || currentContent;
                            } catch (e) {
                                // Use new content if parse fails
                            }
                        }
                        
                        localStorage.setItem(docKey, JSON.stringify(docData));
                        localStorage.setItem(historyKey, JSON.stringify(history));
                        
                        // Update heart icon state immediately
                        window.lunaComposerUpdateHeartState();
                        
                        // Reload history immediately to move document from Disliked to Liked section
                        setTimeout(() => {
                            if (typeof loadLunaComposerHistory === 'function') {
                                loadLunaComposerHistory();
                            }
                        }, 300);
                    }
                } else {
                    console.warn('[Luna Composer] Failed to save feedback:', response.status);
                }
            } catch (e) {
                console.error('[Luna Composer] Error saving feedback:', e);
            }
        };
        
        // Close dropdowns when clicking outside
        document.addEventListener('click', (e) => {
            const shareMenu = document.getElementById('luna-composer-share-menu');
            const exportMenu = document.getElementById('luna-composer-export-menu');
            const shareBtn = document.getElementById('luna-composer-share-btn');
            const exportBtn = document.getElementById('luna-composer-export-btn');
            
            if (shareMenu && shareBtn && !shareMenu.contains(e.target) && !shareBtn.contains(e.target)) {
                shareMenu.style.display = 'none';
            }
            
            if (exportMenu && exportBtn && !exportMenu.contains(e.target) && !exportBtn.contains(e.target)) {
                exportMenu.style.display = 'none';
            }
        });
        
        } // Close the else block from authentication check
        
    </script>
</body>
</html>
